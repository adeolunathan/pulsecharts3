<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Analytics Platform</title>
    
    <!-- Security: Content Security Policy (meta tag version - some directives require HTTP headers) -->
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; 
                   script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://d3js.org https://cdn.jsdelivr.net; 
                   style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.jsdelivr.net; 
                   font-src 'self' https://fonts.gstatic.com; 
                   img-src 'self' data: blob:; 
                   connect-src 'self' https://fonts.googleapis.com https://fonts.gstatic.com;">
    
    <!-- Note: X-Frame-Options, X-Content-Type-Options, and frame-ancestors CSP directive 
         must be set via HTTP headers, not meta tags. See server configuration below. -->
    
    <!-- External Dependencies with SRI - Note: SRI hashes need to be verified for production -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js" 
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.min.js" 
            crossorigin="anonymous"></script>
    
    <!-- Load Global Chart Config first -->
    <script src="js/utils/GlobalChartConfig.js"></script>
    <!-- Load ChartZoom early to ensure availability -->
    <script src="js/utils/ChartZoom.js"></script>
    <!-- Load ChartColorPicker early to ensure availability -->
    <script src="js/utils/ChartColorPicker.js"></script>
    <!-- Load ChartBrandingUtils early to ensure availability -->
    <script src="js/utils/ChartBrandingUtils.js"></script>
    <!-- Load ChartFlowEditor early to ensure availability -->
    <script src="js/utils/ChartFlowEditor.js"></script>
    
    <!-- Debug: Check if utilities loaded -->
    <script>
        console.log('üîç Checking utility availability:');
        console.log('- ChartZoom:', typeof window.ChartZoom);
        console.log('- ChartColorPicker:', typeof window.ChartColorPicker);
        console.log('- ChartBrandingUtils:', typeof window.ChartBrandingUtils);
        console.log('- ChartFlowEditor:', typeof window.ChartFlowEditor);
    </script>
    
    <!-- Google Fonts for Title Font Control -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Lato:wght@400;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;500;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Consolidated Application Styles -->
    <link rel="stylesheet" href="css/pulse-analytics.css">
    <style>
        /* Reduce table content font sizes for compact layout */
        .flow-table td, 
        .spreadsheet-cell,
        .cell-content {
            font-size: 11px !important;
        }
        
        .flow-table td input,
        .flow-table td select,
        .flow-table td button {
            font-size: 10px !important;
        }
        
        /* Make chart more prominent */
        .chart-panel {
            flex: 1 !important;
        }
        
        /* Enhanced title styling for better color control */
        text[data-editable="true"] {
            transition: fill 0.2s ease !important;
        }
        
        /* Removed: Hover color now handled by JavaScript to use current title color */
        
        /* Prevent color flickering */
        text[data-custom-color] {
            fill: var(--custom-color) !important;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" 
          crossorigin="anonymous" />
    <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"
            crossorigin="anonymous"></script>
    
    <!-- Modern UI Enhancements -->
    <style>
        .modern-action-btn {
            transition: all 0.2s ease !important;
        }
        
        .modern-action-btn:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2) !important;
            background: rgba(255,255,255,0.3) !important;
        }
        
        .modern-action-btn:active {
            transform: translateY(0) !important;
        }
        
        .featured-card {
            transition: all 0.3s ease !important;
        }
        
        .featured-card:hover {
            transform: scale(1.05) !important;
            box-shadow: 0 25px 50px rgba(102, 126, 234, 0.4) !important;
        }
        
        /* Variance color styling */
        .variance-positive {
            color: #16a34a !important;
            font-weight: 700 !important;
        }
        
        .variance-negative {
            color: #dc2626 !important;
            font-weight: 700 !important;
        }
        
        .variance-neutral {
            color: #6b7280 !important;
            font-weight: 600 !important;
        }
        
        /* Bar chart data input styles */
        .data-input-option:hover {
            border-color: #3498db !important;
            background-color: #f8fafc !important;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="pulse-app">
        <!-- Application Header -->
        <header class="app-header">
            <h1>Pulse Analytics Platform</h1>
            <div class="header-controls">
                <!-- Chart Selector -->
                <div class="chart-selector">
                    <label for="chart-type-select">Chart:</label>
                    <select id="chart-type-select">
                        <option value="sankey">üåä Sankey Flow</option>
                        <option value="bar">üìä Bar Chart</option>
                    </select>
                </div>
                
                <!-- Export moved to Data controls menu -->
            </div>
        </header>


        <!-- Main Chart Interface -->
        <div id="data-builder" class="tab-content active" style="display: block !important; padding: 0; margin: 0;">
            <!-- Horizontal Chart Controls Menu -->
            <div class="horizontal-controls-menu" style="display: block !important; visibility: visible !important;">
                <div class="controls-menu-wrapper">
                    <!-- Menu Sections (Left to Right) -->
                    <div class="menu-section" data-section="data">
                        <button class="menu-trigger" data-target="data">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <line x1="9" y1="9" x2="15" y2="9"/>
                                <line x1="9" y1="13" x2="15" y2="13"/>
                                <line x1="9" y1="17" x2="15" y2="17"/>
                            </svg>
                            <span>Data</span>
                            <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6,9 12,15 18,9"/>
                            </svg>
                        </button>
                        <div class="menu-dropdown" id="data-dropdown">
                            <div id="data-controls" class="dropdown-content">
                                <!-- Data Management Overview -->
                                <div style="background: #f0f9ff; padding: 12px; border-radius: 8px; margin-bottom: 16px; border-left: 4px solid #3b82f6;">
                                    <h4 style="margin: 0 0 8px 0; color: #1e40af; font-size: 14px; font-weight: 600;">üí∞ Data Management</h4>
                                    <p style="margin: 0; color: #64748b; font-size: 12px;">Manage your financial flow data and chart exports</p>
                                </div>

                                <!-- Flow Actions -->
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                                    <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px; font-weight: 600;">üöÄ Flow Actions</h4>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        <button class="btn-small" onclick="applyFlowChanges()" style="background: #22c55e; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            üöÄ Apply
                                        </button>
                                        <button class="btn-small" onclick="validateFlows()" style="background: #f59e0b; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            ‚úÖ Validate
                                        </button>
                                        <button class="btn-small" onclick="resetToChartData()" style="background: #ef4444; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            üîÑ Reset
                                        </button>
                                    </div>
                                </div>

                                <!-- Export Options -->
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                                    <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px; font-weight: 600;">üì§ Export Options</h4>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        <button class="btn-small" onclick="exportFlowsToCSV()" style="background: #06b6d4; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            üíæ Export CSV
                                        </button>
                                        <button class="btn-small" onclick="downloadTemplate()" style="background: #8b5cf6; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            üìã Template
                                        </button>
                                        <button class="btn-small" onclick="importFlowsFromCSV()" style="background: #10b981; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            üì§ Upload
                                        </button>
                                    </div>
                                </div>

                                <!-- Chart Export -->
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px;">
                                    <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px; font-weight: 600;">üìä Chart Export</h4>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        <button class="btn-small" onclick="exportCurrentChart('png')" style="background: #10b981; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            üñºÔ∏è PNG
                                        </button>
                                        <button class="btn-small" onclick="exportCurrentChart('svg')" style="background: #3b82f6; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            ‚ö° SVG
                                        </button>
                                        <button class="btn-small" onclick="exportCurrentChart('csv')" style="background: #f59e0b; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer;">
                                            üìÑ Data CSV
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="menu-section" data-section="style">
                        <button class="menu-trigger" data-target="style">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="3"/>
                                <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
                            </svg>
                            <span>Style</span>
                            <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6,9 12,15 18,9"/>
                            </svg>
                        </button>
                        <div class="menu-dropdown" id="style-dropdown">
                            <div id="style-controls" class="dropdown-content"></div>
                        </div>
                    </div>

                    <div class="menu-section" data-section="layout">
                        <button class="menu-trigger" data-target="layout">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M3 9h18M9 21V9"/>
                            </svg>
                            <span>Layout</span>
                            <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="name" stroke="currentColor" stroke-width="2">
                                <polyline points="6,9 12,15 18,9"/>
                            </svg>
                        </button>
                        <div class="menu-dropdown" id="layout-dropdown">
                            <div id="layout-controls" class="dropdown-content"></div>
                        </div>
                    </div>


                    <div class="menu-section" data-section="colors">
                        <button class="menu-trigger" data-target="colors">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="13.5" cy="6.5" r=".5"/>
                                <circle cx="17.5" cy="10.5" r=".5"/>
                                <circle cx="8.5" cy="7.5" r=".5"/>
                                <circle cx="6.5" cy="12.5" r=".5"/>
                                <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/>
                            </svg>
                            <span>Colors</span>
                            <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6,9 12,15 18,9"/>
                            </svg>
                        </button>
                        <div class="menu-dropdown" id="colors-dropdown">
                            <div id="colors-controls" class="dropdown-content"></div>
                        </div>
                    </div>

                </div>
            </div>

            <div class="flow-builder-container">
                <!-- Flow Builder actions moved to Chart View menu -->

                <!-- Form fields removed - using click-to-edit chart title instead -->

                <!-- Full Width Layout: Maximized Space Usage -->
                <div class="full-width-layout" style="display: flex; gap: 16px; min-height: 750px; margin: 0; padding: 8px;">
                    
                    <!-- Left Panel: Spreadsheet -->
                    <div class="spreadsheet-panel" style="flex: 0 0 35%; min-width: 480px; position: relative; background: white; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); border: 1px solid rgba(0,0,0,0.05); overflow: visible;">
                        <!-- Business Flows Section -->
                        <div class="section">
                            <div class="section-header" style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-bottom: 1px solid #dee2e6; border-radius: 12px 12px 0 0;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <h3 class="section-title" style="margin: 0; display: flex; align-items: center; gap: 6px;">
                                        <div class="flow-controls-group">
                                            <div class="period-comparison-toggle">
                                                <input type="checkbox" id="comparison-mode-toggle" onchange="toggleComparisonMode()" checked>
                                                <label for="comparison-mode-toggle" title="Shows variance % and trends between periods">üìà</label>
                                            </div>
                                            <div class="margin-display-toggle">
                                                <input type="checkbox" id="margin-display-toggle" onchange="toggleMarginDisplay()">
                                                <label for="margin-display-toggle" title="Show margin percentages on chart nodes">üí∞</label>
                                            </div>
                                            <div class="margin-type-selector" style="display: none;">
                                                <select id="margin-type-select" onchange="updateMarginType()" title="Choose which nodes show margins">
                                                    <option value="profit">Profit Only</option>
                                                    <option value="all">All Nodes</option>
                                                </select>
                                            </div>
                                        </div>
                                    </h3>
                                </div>
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <button class="add-flow-btn" onclick="addFlows()">+ Add Rows</button>
                                    <input type="number" id="rows-to-add" min="1" max="50" value="1" style="width: 40px; padding: 2px 4px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                                </div>
                            </div>
                            <div class="section-content">
                                <div style="overflow-x: auto; height: 600px; overflow-y: auto;">
                                    <table class="flow-table" id="main-flow-table">
                                        <thead>
                                            <tr>
                                                <th style="width: 30px; display: table-cell; font-size: 11px;" id="actions-col"></th>
                                                <th style="width: 120px; font-size: 11px;">From</th>
                                                <th style="width: 120px; font-size: 11px;">To</th>
                                                <th style="width: 180px; display: table-cell; font-size: 11px;" id="description-col">Description</th>
                                                <th style="width: 70px; display: table-cell; font-size: 11px;" id="current-value-col">Current</th>
                                                <th style="width: 70px; display: table-cell; font-size: 11px;" id="previous-value-col">Previous</th>
                                                <th style="width: 60px; display: table-cell; font-size: 11px;" id="variance-col">Variance</th>
                                            </tr>
                                        </thead>
                                        <tbody id="flows-tbody">
                                            <!-- Rows will be dynamically generated by renderFlowTable() -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                    
                    <!-- Right Panel: Chart Canvas -->
                    <div class="chart-panel" style="flex: 1; position: relative; background: white; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); border: 1px solid rgba(0,0,0,0.05); min-height: 750px;">
                        
                        <!-- Main Chart Container for PulseApplication -->
                        <div id="main-chart" style="width: 100%; height: 700px; padding: 10px; background: #fafbfc; border-radius: 8px; margin: 3px;">
                            <!-- Chart will render here -->
                        </div>
                        
                    </div>
                    
                </div>

                <!-- Action buttons moved to header -->
            </div>

        </div>

    </div>

    <!-- Chart Title Edit Modal - Compact & Elegant -->
    <div id="chart-title-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 10000; backdrop-filter: blur(2px);">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 16px; padding: 20px; width: 380px; box-shadow: 0 25px 50px rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.2);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #1f2937; display: flex; align-items: center; gap: 8px;">
                    Edit Chart Info
                </h3>
                <button onclick="cancelTitleEdit()" style="background: none; border: none; font-size: 18px; color: #9ca3af; cursor: pointer; padding: 4px; border-radius: 4px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">√ó</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 12px; margin-bottom: 12px;">
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Company Name</label>
                    <input type="text" id="modal-company-name" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; transition: border-color 0.2s;" onfocus="this.style.borderColor='#3b82f6'" onblur="this.style.borderColor='#e5e7eb'">
                </div>
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Period</label>
                    <input type="text" id="modal-period" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; transition: border-color 0.2s;" onfocus="this.style.borderColor='#3b82f6'" onblur="this.style.borderColor='#e5e7eb'">
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Currency</label>
                    <select id="modal-currency" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; background: white;">
                        <option value="USD ($)" selected>USD ($)</option>
                        <option value="EUR (‚Ç¨)">EUR (‚Ç¨)</option>
                        <option value="GBP (¬£)">GBP (¬£)</option>
                        <option value="JPY (¬•)">JPY (¬•)</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Statement</label>
                    <select id="modal-statement-type" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; background: white;">
                        <option value="Income Statement">Income Statement</option>
                        <option value="Balance Sheet">Balance Sheet</option>
                        <option value="Cash Flow">Cash Flow</option>
                    </select>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Units</label>
                    <select id="modal-units" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; background: white;">
                        <option value="Millions" selected>Millions</option>
                        <option value="Thousands">Thousands</option>
                        <option value="Billions">Billions</option>
                        <option value="Actual">Actual</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Period Type</label>
                    <select id="modal-period-type" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; background: white;">
                        <option value="Q/Q">Quarter-over-Quarter (Q/Q)</option>
                        <option value="Y/Y">Year-over-Year (Y/Y)</option>
                    </select>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Title Font Size</label>
                    <input type="range" id="modal-title-font-size" min="20" max="60" value="40" style="width: 100%;">
                    <div style="text-align: center; font-size: 10px; color: #9ca3af; margin-top: 2px;">
                        <span id="modal-title-font-size-value">40px</span>
                    </div>
                </div>
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Title Color</label>
                    <input type="color" id="modal-title-color" value="#1f2937" style="width: 100%; height: 32px; border: 1px solid #e5e7eb; border-radius: 6px; cursor: pointer;">
                </div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 8px;">
                <button onclick="cancelTitleEdit()" style="background: #f3f4f6; color: #6b7280; border: none; padding: 8px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">Cancel</button>
                <button onclick="saveTitleEdit()" style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; border: none; padding: 8px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500; box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3); transition: all 0.2s;" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(59, 130, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(59, 130, 246, 0.3)'">Save</button>
            </div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" style="display: none;" accept=".json">
    <input type="file" id="csv-file-input" style="display: none;" accept=".csv,.json">

    <!-- Core Scripts -->
    <script src="js/utils/ExportUtils.js"></script>
    <script src="js/utils/ChartBranding.js"></script>
    <script src="js/utils/ChartUtils.js"></script>
    <script src="js/utils/ChartExports.js"></script>
    <script src="js/core/DataManager.js"></script>
    <script src="js/core/ControlPanel.js"></script>
    <!-- Sankey Chart Components -->
    <script src="js/charts/sankey/SankeyChartConfig.js"></script>
    <script src="js/charts/sankey/FinancialDataProcessor.js"></script>
    <script src="js/charts/sankey/SankeyChart.js"></script>
    <script src="js/charts/sankey/SankeyControls.js"></script>
    
    <!-- Bar Chart Components -->
    <script src="js/charts/bar/BarChartConfig.js"></script>
    <script src="js/charts/bar/BarChart.js"></script>
    <script src="js/charts/bar/BarControls.js"></script>
    <script src="js/charts/bar/BarDataEditor.js"></script>
    
    <!-- Verify utilities before app loads -->
    <script>
        console.log('üîç Final utility check before app initialization:');
        console.log('- ChartZoom:', typeof window.ChartZoom, window.ChartZoom ? 'AVAILABLE' : 'MISSING');
        console.log('- ChartColorPicker:', typeof window.ChartColorPicker, window.ChartColorPicker ? 'AVAILABLE' : 'MISSING');
        console.log('- ChartBrandingUtils:', typeof window.ChartBrandingUtils, window.ChartBrandingUtils ? 'AVAILABLE' : 'MISSING');
        console.log('- FinancialDataProcessor:', typeof window.FinancialDataProcessor, window.FinancialDataProcessor ? 'AVAILABLE' : 'MISSING');
        console.log('- d3:', typeof d3, d3 ? 'AVAILABLE' : 'MISSING');
    </script>
    
    <!-- Enhanced app.js -->
    <script src="js/app.js"></script>
    
    <!-- Data Bridge Integration -->
    <script>
        window.PulseDataBridge = {
            currentData: null,
            chartInstance: null,
            isInitialized: false,
            realTimeMode: true,
            appReadyCallbacks: [],
            
            init() {
                this.isInitialized = true;
                console.log('üåâ Real-time Data Bridge initialized');
                
                this.waitForAppReady().then(() => {
                    this.setupEventListeners();
                });
            },
            
            onAppReady(callback) {
                if (window.pulseApp) {
                    callback();
                } else {
                    this.appReadyCallbacks.push(callback);
                }
            },
            
            setData(data, source = 'unknown') {
                this.currentData = data;
                console.log(`üìä Data updated from ${source}:`, data);
                this.notifyDataChanged(source);
            },
            
            getData() {
                if (this.currentData) {
                    return this.currentData;
                }
                
                if (window.pulseApp?.getCurrentData()) {
                    this.currentData = window.pulseApp.getCurrentData();
                    return this.currentData;
                }
                
                if (window.pulseApp?.getCurrentChart()?.data) {
                    this.currentData = window.pulseApp.getCurrentChart().data;
                    return this.currentData;
                }
                
                return null;
            },
            
            setChartInstance(chart) {
                this.chartInstance = chart;
                console.log('üìà Chart instance registered');
            },
            
            setRealTimeMode(enabled) {
                this.realTimeMode = enabled;
                console.log(`üîÑ Real-time mode ${enabled ? 'ENABLED' : 'DISABLED'}`);
                this.updateRealTimeIndicator();
            },
            
            notifyDataChanged(source) {
                console.log(`üîÑ Broadcasting data change from ${source}`);
                
                if (this.chartInstance && this.currentData && source !== 'chart-update') {
                    console.log('üé® Updating chart with new data');
                    this.chartInstance.render(this.currentData);
                }
                
                if (window.currentMainTab === 'data-builder' && window.currentChartType === 'sankey') {
                    this.refreshFlowBuilder();
                    // Also update the flow builder chart instance if it exists
                    if (window.flowBuilderChart && source === 'flow-builder') {
                        console.log('üé® Updating flow builder chart directly');
                        window.flowBuilderChart.render(this.currentData);
                    }
                }
                
                if (window.pulseApp && source !== 'app' && source !== 'app-initial') {
                    window.pulseApp.currentData = this.currentData;
                }
                
                window.dispatchEvent(new CustomEvent('pulseDataChanged', {
                    detail: { data: this.currentData, source }
                }));
            },
            
            refreshFlowBuilder() {
                console.log('üîß Refreshing Flow Builder...');
                
                const data = this.getData();
                if (data && data.nodes && data.links) {
                    console.log('‚úÖ Found data for Flow Builder refresh:', data);
                    window.flowData = convertSankeyDataToFlows(data);
                    
                    if (typeof renderFlowTable === 'function') {
                        renderFlowTable();
                        updateAllStats();
                        console.log('‚úÖ Flow Builder refreshed successfully');
                    }
                    
                    // Update the chart preview in Flow Builder
                    if (typeof renderChartInFlowBuilder === 'function') {
                        setTimeout(() => renderChartInFlowBuilder(), 100);
                    }
                } else {
                    console.warn('‚ö†Ô∏è No data available for Flow Builder refresh');
                }
            },
            
            updateRealTimeIndicator() {
                const indicator = document.getElementById('realtime-indicator');
                const button = document.getElementById('realtime-toggle');
                
                if (indicator && button) {
                    if (this.realTimeMode) {
                        indicator.className = 'realtime-indicator live';
                        button.textContent = '‚ö™ Disable Live Updates';
                        button.className = 'btn btn-secondary';
                    } else {
                        indicator.className = 'realtime-indicator manual';
                        button.textContent = 'üî¥ Enable Live Updates';
                        button.className = 'btn btn-primary';
                    }
                }
            },
            
            applyImmediateChange(newData) {
                if (this.realTimeMode) {
                    console.log('‚ö° Applying immediate change in real-time mode');
                    this.setData(newData, 'flow-builder-realtime');
                }
            },
            
            applyFlowBuilderChanges(newData) {
                console.log('‚úÖ Applying Flow Builder changes:', newData);
                this.setData(newData, 'flow-builder');
            },
            
            setupEventListeners() {
                window.addEventListener('pulseTabSwitch', (e) => {
                    this.handleTabSwitch(e.detail.tabName);
                });
            },
            
            async waitForAppReady() {
                const maxAttempts = 50;
                const checkInterval = 200;
                let attempts = 0;
                
                return new Promise((resolve, reject) => {
                    const checkApp = () => {
                        attempts++;
                        
                        if (window.pulseApp && window.pulseApp.isInitialized) {
                            console.log('‚úÖ Main app found and ready, hooking into data flow');
                            this.hookIntoApp();
                            
                            this.appReadyCallbacks.forEach(callback => callback());
                            this.appReadyCallbacks = [];
                            
                            resolve();
                            return;
                        }
                        
                        // Also check if app exists but is still initializing
                        if (window.pulseApp && !window.pulseApp.isInitialized) {
                            console.log(`‚è≥ App found but still initializing (attempt ${attempts}/${maxAttempts})`);
                        }
                        
                        if (attempts >= maxAttempts) {
                            console.warn('‚ö†Ô∏è Main app initialization timeout - continuing without full integration');
                            // Try to hook into app anyway if it exists
                            if (window.pulseApp) {
                                this.hookIntoApp();
                            }
                            resolve();
                            return;
                        }
                        
                        setTimeout(checkApp, checkInterval);
                    };
                    
                    checkApp();
                });
            },
            
            hookIntoApp() {
                const app = window.pulseApp;
                if (!app) return;
                
                const originalLoadDataset = app.loadDataset.bind(app);
                app.loadDataset = async function(datasetKey) {
                    const result = await originalLoadDataset(datasetKey);
                    window.PulseDataBridge.setData(result, `dataset-${datasetKey}`);
                    return result;
                };
                
                if (app.chart) {
                    this.setChartInstance(app.chart);
                }
                
                const initialData = app.getCurrentData();
                if (initialData) {
                    this.setData(initialData, 'app-initial');
                }
                
                console.log('üîó Successfully hooked into main app');
            },
            
            handleTabSwitch(tabName) {
                console.log(`üîÑ Tab switched to: ${tabName}`);
                
                if (tabName === 'data-builder') {
                    if (!this.currentData && window.pulseApp) {
                        const appData = window.pulseApp.getCurrentData();
                        if (appData) {
                            this.currentData = appData;
                            console.log('üìä Retrieved data from app for flow builder');
                        }
                    }
                    
                    // Only refresh Flow Builder for Sankey charts
                    if (window.currentChartType === 'sankey') {
                        setTimeout(() => {
                            this.refreshFlowBuilder();
                        }, 50);
                    }
                }
            }
        };

        // Initialize Data Bridge after DOM is ready and app.js has loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => window.PulseDataBridge.init(), 100);
            });
        } else {
            setTimeout(() => window.PulseDataBridge.init(), 100);
        }
    </script>
    
    <!-- Flow Builder Implementation -->
    <script>
        let currentMainTab = 'data-builder';
        let selectedChartType = null; // 'income' or 'balance'
        let isInitialized = false; // Prevent multiple initializations
        let lockChartView = false; // Lock chart view when coming from type selector
        let flowData = {
            metadata: {
                title: "Financial Flow",
                currency: "USD",
                unit: "millions",
                company: "Your Company",
                period: "Current Period",
                colorPalette: {} // CRITICAL: Always preserve color palette
            },
            flows: []
        };

        let flowIdCounter = 0;

        // Parse URL parameters to get chart type
        function getURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            return {
                type: urlParams.get('type'), // 'income' or 'balance' (for Sankey)
                chartType: urlParams.get('chartType'), // 'sankey' or 'bar' (main chart type)
                tab: urlParams.get('tab'), // 'data-builder' only
                data: urlParams.get('data') // Encoded JSON data
            };
        }

        // Load JSON data file based on chart type
        async function loadChartTypeData(chartType) {
            try {
                let dataFile = '';
                if (chartType === 'income') {
                    dataFile = 'data/samples/saas-company.json';
                } else if (chartType === 'balance') {
                    dataFile = 'data/samples/medocare.json';
                } else if (chartType === 'bar') {
                    dataFile = 'data/samples/bar-chart-sample.json';
                } else {
                    console.warn('Unknown chart type:', chartType);
                    return null;
                }

                console.log(`üìÅ Loading ${chartType} data from ${dataFile}`);
                const response = await fetch(dataFile);
                
                if (!response.ok) {
                    throw new Error(`Failed to load ${dataFile}: ${response.status}`);
                }
                
                const data = await response.json();
                console.log(`‚úÖ Successfully loaded ${chartType} data:`, data);
                console.log(`üìä Data nodes:`, data.nodes?.slice(0, 3));
                console.log(`üîó Data links:`, data.links?.slice(0, 3));
                return data;
                
            } catch (error) {
                console.error('Error loading chart type data:', error);
                alert(`Error loading sample data: ${error.message}`);
                return null;
            }
        }

        // FIXED: Add missing convertSankeyDataToFlows function
        function convertSankeyDataToFlows(sankeyData) {
            const flows = [];
            
            sankeyData.links.forEach((link, index) => {
                const sourceNode = sankeyData.nodes.find(n => n.id === link.source);
                const targetNode = sankeyData.nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode) {
                    flows.push(new BusinessFlow({
                        source: link.source,
                        target: link.target,
                        value: link.value,
                        previousValue: link.previousValue || 0,
                        flowType: link.type || 'revenue_flow',
                        sourceLayer: sourceNode.depth || 0,
                        targetLayer: targetNode.depth || 1,
                        sourceCategory: sourceNode.category || 'revenue',
                        targetCategory: targetNode.category || 'revenue',
                        description: link.description || targetNode.description || ''
                    }));
                }
            });

            return {
                metadata: {
                    title: sankeyData.metadata?.title || "Financial Flow",
                    currency: sankeyData.metadata?.currency || "USD",
                    unit: sankeyData.metadata?.unit || "millions",
                    company: sankeyData.metadata?.company || "Your Company",
                    period: sankeyData.metadata?.period || "Current Period",
                    comparisonMode: sankeyData.metadata?.comparisonMode || false,
                    // CRITICAL: Preserve the existing color palette
                    colorPalette: sankeyData.metadata?.colorPalette || flowData.metadata?.colorPalette || {}
                },
                flows: flows
            };
        }

        // FIXED: Comparison Mode Toggle with color preservation
        function toggleComparisonMode() {
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            
            // CRITICAL: Store existing colors before any changes
            const existingColors = { ...flowData.metadata.colorPalette };
            
            // Previous Value and Variance columns are now always visible since they're core functionality
            // This function now mainly manages the comparison calculation logic
            
            // Update metadata with comparison mode but preserve colors
            flowData.metadata.comparisonMode = comparisonMode;
            flowData.metadata.colorPalette = existingColors; // CRITICAL: Restore colors
            
            // Re-render table to update variance calculations
            renderFlowTable();
            
            // If in real-time mode, trigger update with color preservation
            if (window.PulseDataBridge.realTimeMode) {
                const sankeyData = generateNodesAndLinksFromFlows();
                // CRITICAL: Ensure colors are preserved in the generated data
                sankeyData.metadata.colorPalette = existingColors;
                debouncedRealTimeUpdate();
            }
            
            console.log(`üìà Comparison mode ${comparisonMode ? 'ENABLED' : 'DISABLED'} with colors preserved`);
        }

        // Margin Display Toggle - Uses existing logic from SankeyChart
        function toggleMarginDisplay() {
            const marginToggle = document.getElementById('margin-display-toggle');
            const marginSelector = document.querySelector('.margin-type-selector');
            const showMargin = marginToggle.checked;
            
            // Show/hide margin type selector
            if (showMargin) {
                marginSelector.style.display = 'block';
            } else {
                marginSelector.style.display = 'none';
            }
            
            // Get the current chart instance - try multiple sources
            let chart = null;
            if (window.flowBuilderChart && window.flowBuilderChart.updateConfig) {
                chart = window.flowBuilderChart;
            } else if (window.pulseApp && window.pulseApp.chart && window.pulseApp.chart.updateConfig) {
                chart = window.pulseApp.chart;
            }
            
            // Debug logging
            console.log('üí∞ Margin toggle debug:', {
                showMargin: showMargin,
                flowBuilderChart: !!window.flowBuilderChart,
                pulseAppChart: !!(window.pulseApp && window.pulseApp.chart),
                chartSelected: !!chart,
                marginTypeValue: document.getElementById('margin-type-select').value
            });
            
            // Update chart configuration through existing config system
            if (chart && chart.updateConfig) {
                chart.updateConfig({
                    showMargin: showMargin,
                    showMarginFor: document.getElementById('margin-type-select').value
                });
                console.log('üí∞ Margin display toggled:', showMargin);
            } else {
                console.warn('‚ö†Ô∏è No chart with updateConfig method found');
            }
        }

        function updateMarginType() {
            const marginType = document.getElementById('margin-type-select').value;
            const showMargin = document.getElementById('margin-display-toggle').checked;
            
            // Get the current chart instance - try multiple sources
            let chart = null;
            if (window.flowBuilderChart && window.flowBuilderChart.updateConfig) {
                chart = window.flowBuilderChart;
            } else if (window.pulseApp && window.pulseApp.chart && window.pulseApp.chart.updateConfig) {
                chart = window.pulseApp.chart;
            }
            
            if (showMargin && chart && chart.updateConfig) {
                chart.updateConfig({
                    showMarginFor: marginType
                });
                console.log('üí∞ Margin type updated:', marginType);
            } else {
                console.warn('‚ö†Ô∏è Cannot update margin type - no chart available or margin disabled');
            }
        }

        // Flow structure definition
        class BusinessFlow {
            constructor(options = {}) {
                this.id = options.id || `flow_${++flowIdCounter}`;
                this.source = options.source || '';
                this.target = options.target || '';
                this.value = options.value || 0;
                this.previousValue = options.previousValue || 0;
                this.flowType = options.flowType || 'revenue_flow';
                this.sourceLayer = options.sourceLayer || 0;
                this.targetLayer = options.targetLayer || 1;
                this.sourceOrder = options.sourceOrder || 1;
                this.targetOrder = options.targetOrder || 1;
                this.sourceCategory = options.sourceCategory || 'revenue';
                this.targetCategory = options.targetCategory || 'revenue';
                this.description = options.description || '';
            }
            
            // Calculate variance between current and previous period
            getVariance() {
                if (this.previousValue === 0) {
                    return this.value > 0 ? { amount: this.value, percentage: 100, trend: 'new' } : { amount: 0, percentage: 0, trend: 'none' };
                }
                
                const amount = this.value - this.previousValue;
                const percentage = (amount / Math.abs(this.previousValue)) * 100;
                let trend = 'none';
                
                if (percentage > 0.1) trend = 'up';
                else if (percentage < -0.1) trend = 'down';
                
                return { amount, percentage, trend };
            }
            
            // Get formatted variance display
            getVarianceDisplay() {
                const variance = this.getVariance();
                if (variance.trend === 'none') return '‚Üí 0%';
                if (variance.trend === 'new') return ''; // Return empty string for new items (consistent with getGrowthDeclineDisplay)
                
                const symbol = variance.trend === 'up' ? '‚ñ≤' : '‚ñº';
                const sign = variance.percentage > 0 ? '+' : '';
                return `${symbol} ${sign}${variance.percentage.toFixed(1)}%`;
            }
            
            // Calculate margin percentage (for Income Statement only)
            getMarginPercentage(revenueBase) {
                if (!revenueBase || revenueBase === 0) {
                    return { percentage: 0, display: 'N/A' };
                }
                
                const percentage = (this.value / revenueBase) * 100;
                return {
                    percentage: percentage,
                    display: `${percentage.toFixed(1)}%`
                };
            }
            
            // Get formatted growth/decline display (for both IS and BS)
            getGrowthDeclineDisplay() {
                const variance = this.getVariance();
                if (variance.trend === 'none') return ''; // Return empty string for no change
                if (variance.trend === 'new') return ''; // Return empty string for new items too
                
                const sign = variance.percentage > 0 ? '+' : '';
                const periodIndicator = this.getPeriodIndicator();
                return `${sign}${variance.percentage.toFixed(1)}% ${periodIndicator}`;
            }
            
            // Get period indicator (Y/Y or Q/Q) based on user selection
            getPeriodIndicator() {
                // Use user-selected period type if available
                if (flowData.metadata?.periodType) {
                    return flowData.metadata.periodType;
                }
                
                // Fallback to automatic detection for backward compatibility
                const period = flowData.metadata?.period || '';
                const periodLower = period.toLowerCase();
                
                // Check for quarter indicators
                if (periodLower.includes('q1') || periodLower.includes('q2') || 
                    periodLower.includes('q3') || periodLower.includes('q4') || 
                    periodLower.includes('quarter')) {
                    return 'Q/Q';
                }
                
                // Default to Q/Q for quarterly periods, Y/Y otherwise
                return 'Y/Y';
            }
        }

        // Find revenue base by looking for Total Revenue node (calculated sum)
        function findRevenueBase(flowData) {
            if (!flowData || !flowData.flows) return 0;
            
            // Build a map of nodes and their incoming flows to find the aggregated total
            const nodeInflows = new Map();
            
            flowData.flows.forEach(flow => {
                if (!nodeInflows.has(flow.target)) {
                    nodeInflows.set(flow.target, []);
                }
                nodeInflows.get(flow.target).push({
                    source: flow.source,
                    value: flow.value
                });
            });
            
            // Look for "Total Revenue" node or a node that aggregates multiple revenue sources
            let revenueBase = 0;
            let revenueNodeName = null;
            
            for (const [nodeName, inflows] of nodeInflows) {
                const lowerName = nodeName.toLowerCase();
                
                // Check if this is "Total Revenue" or aggregates multiple revenue sources
                if (lowerName.includes('total') && lowerName.includes('revenue')) {
                    // Calculate the sum of incoming revenue flows
                    const totalIncoming = inflows.reduce((sum, inflow) => sum + inflow.value, 0);
                    revenueBase = totalIncoming;
                    revenueNodeName = nodeName;
                    console.log(`‚úÖ Found Total Revenue node: ${nodeName} = ${totalIncoming}`);
                    break;
                } else if (lowerName.includes('revenue') && inflows.length >= 2) {
                    // Revenue node with multiple inputs (likely an aggregation)
                    const revenueInflows = inflows.filter(inflow => {
                        const sourceLower = inflow.source.toLowerCase();
                        return sourceLower.includes('revenue') || 
                               sourceLower.includes('subscription') ||
                               sourceLower.includes('service') ||
                               sourceLower.includes('platform') ||
                               sourceLower.includes('sales');
                    });
                    
                    if (revenueInflows.length >= 2) {
                        const totalIncoming = revenueInflows.reduce((sum, inflow) => sum + inflow.value, 0);
                        if (totalIncoming > revenueBase) {
                            revenueBase = totalIncoming;
                            revenueNodeName = nodeName;
                            console.log(`‚úÖ Found revenue aggregation node: ${nodeName} = ${totalIncoming}`);
                        }
                    }
                }
            }
            
            // Fallback: if no aggregation found, sum all primary revenue sources
            if (revenueBase === 0) {
                console.log('üîç No total revenue node found, summing primary revenue sources...');
                const primarySources = flowData.flows.filter(flow => {
                    const sourceLower = flow.source.toLowerCase();
                    return (sourceLower.includes('revenue') || 
                           sourceLower.includes('') ||
                           sourceLower.includes('service') ||
                           sourceLower.includes('platform')) &&
                           !nodeInflows.has(flow.source); // Primary source (no inputs)
                });
                
                revenueBase = primarySources.reduce((sum, flow) => sum + flow.value, 0);
                revenueNodeName = `Calculated from ${primarySources.length} primary sources`;
            }
            
            console.log(`üí∞ Revenue base: ${revenueNodeName} = ${revenueBase}`);
            return revenueBase;
        }

        // Get percentage of revenue for any node value
        function getRevenuePercentage(nodeValue, revenueBase) {
            if (!revenueBase || revenueBase === 0) return 'N/A';
            
            // If this is the revenue base itself, it's 100%
            if (nodeValue === revenueBase) {
                return '100.0%';
            }
            
            const percentage = (nodeValue / revenueBase) * 100;
            return `${percentage.toFixed(1)}%`;
        }

        // Debounce function for real-time updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedRealTimeUpdate = debounce(() => {
            if (window.PulseDataBridge.realTimeMode) {
                console.log('‚ö° Triggering debounced real-time update');
                const sankeyData = generateNodesAndLinksFromFlows();
                window.PulseDataBridge.applyImmediateChange(sankeyData);
            }
        }, 500);

        // Collapsible Section Management
        // Collapsible functionality removed - sections now always expanded
        function toggleSection(sectionName) {
            // Function kept for compatibility but does nothing
            console.log('Section collapse functionality has been removed');
        }

        // Toggle function for the compact Business Flows update mode button

        function toggleRealTimeMode() {
            const currentMode = window.PulseDataBridge.realTimeMode;
            const newMode = !currentMode;
            window.PulseDataBridge.setRealTimeMode(newMode);
            
            console.log(`üîÑ Real-time mode ${newMode ? 'ENABLED' : 'DISABLED'}`);
        }


        function resetNodeHighlighting() {
            // Reset any chart highlighting effects
            const chart = window.flowBuilderChart || window.pulseApp?.chart;
            if (chart && typeof chart.highlightNodesByCategory === 'function') {
                chart.highlightNodesByCategory(null);
            }
            
            // Re-initialize category buttons to match current data
            setTimeout(() => initializeCategoryButtons(), 100);
        }

        // Target category cycling functionality
        const targetCategories = ['revenue', 'expense', 'profit']; // Cycle: Revenue ‚Üí Expense ‚Üí Profit ‚Üí Revenue...

        // cycleTargetCategory function moved to SankeyChart.js color picker modal
        // Functionality preserved but relocated to modal interface

        function updateTargetCategoryCell(rowIndex, category) {
            const cell = document.querySelector(`td[data-col="targetCategory"][data-row="${rowIndex}"] .cell-content`);
            if (cell) {
                const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
                cell.textContent = categoryName;
            }
        }

        function updateCategoryButton(button, category) {
            // Category button functionality moved to color picker modal
            // This function is kept for compatibility but no longer needed
            console.log('Category button functionality moved to color picker modal');
        }

        function initializeCategoryButtons() {
            // Category buttons have been moved to the color picker modal
            // This function is kept for compatibility but no longer needed
            console.log('Category buttons are now in the color picker modal');
        }

        function resetAllCategoryButtons() {
            // Category buttons have been moved to the color picker modal
            // This function is kept for compatibility but no longer needed
            console.log('Category buttons are now in the color picker modal');
        }

        function updateFlowProperty(index, property, value) {
            if (flowData.flows[index]) {
                flowData.flows[index][property] = value;
                console.log(`üìù Updated flow ${index} ${property}: ${value}`);
                
                
                // Trigger update in live mode
                debouncedRealTimeUpdate();
            }
        }

        // Initialize Flow Builder Chart Canvas
        function initializeFlowBuilderChart() {
            const chartContainer = document.getElementById('main-chart');
            if (!chartContainer) return;
            
            console.log('üìä Initializing Flow Builder chart canvas');
            
            // Clear existing content and prepare for chart rendering
            chartContainer.innerHTML = '';
            chartContainer.style.background = 'white';
            
            // Initialize chart controls
            initializeFlowBuilderControlPanel();
            
            // Try to render current chart data if available
            if (window.pulseApp && window.pulseApp.getCurrentChart()) {
                console.log('üé® Rendering existing chart in Flow Builder canvas');
                renderChartInFlowBuilder();
            } else {
                // Show placeholder
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280; font-size: 14px; flex-direction: column; gap: 12px;">
                        <div style="font-size: 24px;">üìä</div>
                        <div>Chart canvas ready for data</div>
                        <div style="font-size: 12px; color: #9ca3af;">Add flows and click Apply to see the chart</div>
                    </div>
                `;
            }
        }
        
        // Basic control functions
        function randomizeColors() {
            console.log('üé® Randomizing chart colors');
            // Implement color randomization
            if (window.flowBuilderChart && typeof window.flowBuilderChart.randomizeColors === 'function') {
                window.flowBuilderChart.randomizeColors();
            } else {
                console.log('‚ö†Ô∏è randomizeColors method not available on chart instance');
            }
            showNotification('Colors randomized', 'success');
        }
        
        function refreshChart() {
            console.log('üîÑ Refreshing chart');
            
            // Instead of recreating the chart, update it through the Data Bridge
            const sankeyData = generateNodesAndLinksFromFlows();
            console.log('üìà Refreshing with Sankey data:', sankeyData);
            window.PulseDataBridge.setData(sankeyData, 'chart-refresh');
            
            // Reset highlighting when chart refreshes
            resetNodeHighlighting();
        }
        
        // Initialize Flow Builder Control Panel (same as Chart View)
        function initializeFlowBuilderControlPanel() {
            console.log('üéõÔ∏è Initializing Flow Builder Control Panel');
            
            // Wait for PulseControlPanel to be available
            setTimeout(() => {
                try {
                    // Check if PulseControlPanel is available
                    if (typeof PulseControlPanel !== 'undefined') {
                        // Create a single control panel instance that will distribute controls across all dropdowns
                        window.flowBuilderControlPanel = new PulseControlPanel('data-controls');
                        
                        // Initialize with current chart if available
                        if (window.flowBuilderChart) {
                            console.log('üéØ Flow Builder chart found, initializing controls');
                            
                            // Determine control module based on chart type
                            let controlModule = null;
                            if (window.flowBuilderChart.type === 'sankey' && typeof SankeyControlModule !== 'undefined') {
                                controlModule = new SankeyControlModule();
                                console.log('üìã Created SankeyControlModule for Flow Builder');
                                
                                // Initialize dynamic controls for Sankey charts
                                if (controlModule.initializeDynamicControls && window.flowBuilderChart.data) {
                                    controlModule.initializeDynamicControls(window.flowBuilderChart);
                                    console.log('üé® Initialized dynamic controls with chart data');
                                }
                            } else if (window.flowBuilderChart.type === 'bar' && typeof BarControlModule !== 'undefined') {
                                controlModule = new BarControlModule();
                                console.log('üìä Created BarControlModule for Flow Builder');
                            }
                            
                            if (controlModule) {
                                window.flowBuilderControlPanel.init(window.flowBuilderChart, controlModule);
                                console.log('‚úÖ Flow Builder Control Panel initialized with chart and controls populated');
                            } else {
                                console.warn('‚ö†Ô∏è No suitable control module found for chart type:', window.flowBuilderChart.type);
                            }
                        } else {
                            console.log('‚ö†Ô∏è Chart not available yet for control panel initialization');
                        }
                    } else {
                        console.warn('‚ö†Ô∏è PulseControlPanel class not loaded yet');
                        // Try again in 500ms
                        setTimeout(initializeFlowBuilderControlPanel, 500);
                    }
                } catch (error) {
                    console.error('‚ùå Error initializing Flow Builder Control Panel:', error);
                }
            }, 100);
        }
        
        // Toggle chart controls panel
        function toggleChartControls() {
            const panel = document.getElementById('chart-controls-panel');
            const button = document.getElementById('controls-toggle-btn');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                button.innerHTML = '‚öôÔ∏è Hide Controls';
                button.style.background = '#ef4444';
                
                // Refresh controls
                initializeFlowBuilderControlPanel();
            } else {
                panel.style.display = 'none';
                button.innerHTML = '‚öôÔ∏è Controls';
                button.style.background = '#6366f1';
            }
        }
        
        
        // Toggle export menu
        function toggleExportMenu() {
            const menu = document.getElementById('export-menu');
            const button = document.getElementById('export-toggle-btn');
            
            if (menu.style.display === 'none') {
                menu.style.display = 'block';
                button.innerHTML = 'üì∑ Export ‚ñ≤';
            } else {
                menu.style.display = 'none';
                button.innerHTML = 'üì∑ Export ‚ñº';
            }
        }
        
        // Close export menu when clicking outside
        document.addEventListener('click', function(event) {
            const exportDropdown = document.querySelector('.export-dropdown');
            const menu = document.getElementById('export-menu');
            
            if (exportDropdown && !exportDropdown.contains(event.target)) {
                menu.style.display = 'none';
                document.getElementById('export-toggle-btn').innerHTML = 'üì∑ Export ‚ñº';
            }
        });
        
        // Export chart from Flow Builder
        function exportChart(format) {
            console.log(`üì∑ Exporting chart as ${format}`);
            
            // Close export menu
            document.getElementById('export-menu').style.display = 'none';
            document.getElementById('export-toggle-btn').innerHTML = 'üì∑ Export ‚ñº';
            
            const chartElement = document.getElementById('flow-builder-chart');
            if (!chartElement) {
                showNotification('No chart to export', 'error');
                return;
            }
            
            try {
                if (format === 'png') {
                    if (window.flowBuilderChart && window.flowBuilderChart.exportToPNG) {
                        window.flowBuilderChart.exportToPNG();
                    } else if (window.ChartExports?.exportToPNG) {
                        window.ChartExports.exportToPNG(chartElement, 'flow-chart.png');
                    } else {
                        throw new Error('PNG export not available');
                    }
                } else if (format === 'svg') {
                    if (window.flowBuilderChart && window.flowBuilderChart.exportToSVG) {
                        window.flowBuilderChart.exportToSVG();
                    } else if (window.ChartExports?.exportToSVG) {
                        window.ChartExports.exportToSVG(chartElement, 'flow-chart.svg');
                    } else {
                        throw new Error('SVG export not available');
                    }
                } else if (format === 'csv') {
                    if (window.flowBuilderChart && window.flowBuilderChart.exportDataToCSV) {
                        window.flowBuilderChart.exportDataToCSV();
                    } else {
                        // Export flow data as CSV
                        exportFlowDataToCSV();
                    }
                }
                showNotification(`Chart exported as ${format.toUpperCase()}`, 'success');
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Export failed: ' + error.message, 'error');
            }
        }
        
        // Universal export function that works for both Chart View and Flow Builder
        function exportCurrentChart(format) {
            console.log(`üì∑ Exporting current chart as ${format}`);
            
            let chartInstance = null;
            
            // Determine which chart instance to use
            if (window.pulseApp && window.pulseApp.flowBuilderMode && window.pulseApp.flowBuilderChart) {
                chartInstance = window.pulseApp.flowBuilderChart;
                console.log('üìä Using Flow Builder chart for export');
            } else if (window.pulseApp && window.pulseApp.chart) {
                chartInstance = window.pulseApp.chart;
                console.log('üìä Using main chart for export');
            }
            
            if (!chartInstance) {
                showNotification('No chart available for export', 'error');
                return;
            }
            
            try {
                if (format === 'png' && chartInstance.exportToPNG) {
                    chartInstance.exportToPNG();
                } else if (format === 'svg' && chartInstance.exportToSVG) {
                    chartInstance.exportToSVG();
                } else if (format === 'csv' && chartInstance.exportDataToCSV) {
                    chartInstance.exportDataToCSV();
                } else {
                    throw new Error(`${format.toUpperCase()} export not available for this chart`);
                }
                showNotification(`Chart exported as ${format.toUpperCase()}`, 'success');
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Export failed: ' + error.message, 'error');
            }
        }
        
        // Override the main app's chart getter to use Flow Builder chart when appropriate
        function getCurrentChart() {
            // Only return the main chart - Flow Builder chart should be handled separately
            if (window.pulseApp && window.pulseApp.chart) {
                return window.pulseApp.chart;
            }
            return null;
        }
        
        // Ensure Flow Builder controls work independently
        function ensureFlowBuilderControlsWork() {
            // Flow Builder controls should be self-contained and only affect the Flow Builder chart
            // No need to intercept main app control panel updates
            console.log('üîó Flow Builder controls configured to work independently');
        }
        
        // Export flow data to CSV
        function exportFlowDataToCSV() {
            const flows = flowData.flows;
            if (!flows || flows.length === 0) {
                throw new Error('No flow data to export');
            }
            
            // Create CSV content
            const headers = ['Source', 'Target', 'Current Value', 'Previous Value', 'Variance %', 'Description'];
            const csvContent = [
                headers.join(','),
                ...flows.map(flow => [
                    flow.source,
                    flow.target,
                    flow.value,
                    flow.previousValue || 0,
                    flow.getVariance().percentage.toFixed(1),
                    flow.description || ''
                ].map(value => `"${value}"`).join(','))
            ].join('\n');
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'flow-data.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        // Show notification
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 16px;
                border-radius: 6px;
                color: white;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                transition: all 0.3s ease;
                max-width: 300px;
            `;
            
            // Set background color based on type
            switch (type) {
                case 'success':
                    notification.style.background = '#22c55e';
                    break;
                case 'error':
                    notification.style.background = '#ef4444';
                    break;
                case 'warning':
                    notification.style.background = '#f59e0b';
                    break;
                default:
                    notification.style.background = '#6366f1';
            }
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Render chart in Flow Builder canvas (copying from app.js approach)
        function renderChartInFlowBuilder() {
            const chartContainer = document.getElementById('main-chart');
            if (!chartContainer) return;
            
            console.log('üé® Rendering chart in Flow Builder canvas');
            
            // Clear container
            chartContainer.innerHTML = '';
            
            // Get current data
            const currentData = window.PulseDataBridge?.getData();
            if (!currentData) {
                console.warn('‚ö†Ô∏è No data available for Flow Builder chart');
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280; font-size: 14px; flex-direction: column; gap: 12px;">
                        <div style="font-size: 24px;">üìä</div>
                        <div>No data to display</div>
                        <div style="font-size: 12px; color: #9ca3af;">Add flows to see the chart</div>
                    </div>
                `;
                return;
            }
            
            // Get current chart type
            const chartType = window.currentChartType || 'sankey';
            
            try {
                // Use the same chart registry approach as app.js
                const chartRegistry = {
                    sankey: {
                        name: 'Sankey Flow Chart',
                        chartClass: PulseSankeyChart,
                        controlModuleClass: SankeyControlModule,
                        description: 'Financial flow visualization'
                    },
                    bar: {
                        name: 'Bar Chart',
                        chartClass: PulseBarChart,
                        controlModuleClass: BarControlModule,
                        description: 'Categorical data visualization'
                    }
                };
                
                const chartDefinition = chartRegistry[chartType];
                if (!chartDefinition || !chartDefinition.chartClass) {
                    throw new Error(`Chart type '${chartType}' not found or chart class not available`);
                }
                
                console.log(`üéØ Creating ${chartType} chart instance for Flow Builder`);
                
                // Create chart instance using the same pattern as app.js (line 200)
                const flowBuilderChart = new chartDefinition.chartClass('main-chart');
                
                // Apply control defaults if control module is available
                if (chartDefinition.controlModuleClass) {
                    const controlModule = new chartDefinition.controlModuleClass();
                    flowBuilderChart.applyControlDefaults(controlModule);
                }
                
                // Render the chart with data
                flowBuilderChart.render(currentData);
                
                // Store reference for controls and future operations
                window.flowBuilderChart = flowBuilderChart;
                
                // Register with Data Bridge so it can update this chart
                window.PulseDataBridge.setChartInstance(flowBuilderChart);
                
                console.log(`‚úÖ ${chartType} chart rendered successfully in Flow Builder canvas`);
                
            } catch (error) {
                console.error('‚ùå Error rendering chart in Flow Builder:', error);
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444; font-size: 14px; flex-direction: column; gap: 8px;">
                        <div>Error rendering chart</div>
                        <div style="font-size: 12px;">${error.message}</div>
                    </div>
                `;
            }
        }


        function switchMainTab(tabName, isManualClick = false) {
            // Check if chart view is locked (from type selector) - but allow manual clicks
            if (lockChartView && tabName === 'data-builder' && !isManualClick) {
                console.log('üîí Chart view is locked, ignoring automatic switch to data-builder');
                return;
            }
            
            console.log(`üéØ Switching to tab: ${tabName}`);
            
            // If user manually clicks any tab, unlock chart view
            if (isManualClick) {
                lockChartView = false;
                console.log('üîì Chart view unlocked by manual click');
            }
            
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const targetTab = document.querySelector(`[onclick="switchMainTab('${tabName}')"]`);
            if (targetTab) {
                targetTab.classList.add('active');
            }
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const targetContent = document.getElementById(tabName);
            if (targetContent) {
                targetContent.classList.add('active');
            }
            
            currentMainTab = tabName;
            
            window.dispatchEvent(new CustomEvent('pulseTabSwitch', {
                detail: { tabName }
            }));
            
            if (tabName === 'data-builder') {
                // Main chart is always visible in single-page interface
                
                // Flow Builder now uses the same horizontal menu structure as Chart View
                // No need to hide the menu since it's the same interface
                
                // Only initialize if not already done
                if (!isInitialized) {
                    // Check chart type to determine initialization method
                    const urlParams = getURLParameters();
                    if (urlParams.type === 'bar' || urlParams.chartType === 'bar') {
                        console.log('üìä Bar chart detected, skipping flow-based initialization for data-builder tab');
                        isInitialized = true; // Mark as initialized to prevent future calls
                    } else {
                        setTimeout(() => {
                            initializeChartInterface();
                        }, 100);
                    }
                } else {
                    console.log('üìä Data-builder tab activated, data already loaded');
                }
                
                // Initialize Flow Builder chart canvas independently
                setTimeout(() => {
                    initializeFlowBuilderChart();
                    
                    // Initialize Flow Builder chart controls independently
                    setTimeout(() => {
                        if (window.flowBuilderChart) {
                            console.log('üîó Initializing Flow Builder chart controls independently');
                            
                            // Initialize Flow Builder controls independently
                            initializeFlowBuilderControlPanel();
                            
                            // Ensure controls work with Flow Builder independently
                            ensureFlowBuilderControlsWork();
                        }
                    }, 500);
                }, 200);
                
            } else {
                // Single-page interface - main chart always visible
                console.log('üìä Single-page interface active');
            }
        }

        async function initializeChartInterface() {
            if (isInitialized) {
                console.log('‚ö†Ô∏è Chart interface already initialized, skipping...');
                return;
            }
            
            console.log('üîß Initializing Chart Interface...');
            
            // Get URL parameters once at the beginning
            const urlParams = getURLParameters();
            console.log('üîç URL params check: type=', urlParams.type, 'chartType=', urlParams.chartType);
            
            // Handle bar charts separately - they don't use flow data
            if (urlParams.type === 'bar' || urlParams.chartType === 'bar') {
                console.log('üìä Bar chart detected, skipping flow-based initialization');
                isInitialized = true;
                return;
            }
            
            console.log('üåä Initializing Flow Builder for Sankey charts...');
            
            // Check for existing data first (priority for uploaded/custom data)
            let existingData = null;
            
            if (window.PulseDataBridge && window.PulseDataBridge.currentData) {
                existingData = window.PulseDataBridge.currentData;
                console.log('üìä Found existing data in Data Bridge:', existingData);
            } else if (window.pulseApp && window.pulseApp.getCurrentData()) {
                existingData = window.pulseApp.getCurrentData();
                console.log('üìä Found existing data from pulseApp:', existingData);
            }
            
            // If we have existing custom data, use it instead of loading sample data
            if (existingData && existingData.nodes && existingData.links) {
                console.log('‚úÖ Using existing custom data, skipping sample data load');
                // CRITICAL: Preserve existing colors before conversion
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData = convertSankeyDataToFlows(existingData);
                
                // CRITICAL: Restore colors after conversion
                flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                
                updateMetadataInputs();
                renderFlowTable();
                updateAllStats();
                
                // Handle tab switching based on URL parameter
                if (urlParams.tab === 'data-builder') {
                    currentMainTab = 'data-builder';
                    setTimeout(() => switchMainTab('data-builder'), 100);
                } else {
                    currentMainTab = 'data-builder';
                    console.log('üìä Staying on data-builder with existing data');
                }
                
                console.log('‚úÖ Flow Builder initialized with existing custom data');
                isInitialized = true;
                return;
            }
            
            // Check for URL parameters (only if no existing data)
            
            if (urlParams.type) {
                console.log(`üéØ Chart type specified in URL: ${urlParams.type}`);
                selectedChartType = urlParams.type;
                
                // Load the appropriate sample data
                const sampleData = await loadChartTypeData(urlParams.type);
                if (sampleData) {
                    // CRITICAL: Preserve existing colors before conversion
                    const existingColors = { ...flowData.metadata.colorPalette };
                    
                    flowData = convertSankeyDataToFlows(sampleData);
                    
                    // CRITICAL: Restore colors after conversion
                    flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                    
                    updateMetadataInputs();
                    renderFlowTable();
                    updateAllStats();
                    
                    // CRITICAL: Update the chart data bridge with the new data
                    const sankeyData = generateNodesAndLinksFromFlows();
                    console.log(`üìä Setting ${urlParams.type} data in bridge:`, sankeyData);
                    window.PulseDataBridge.setData(sankeyData, `chart-type-${urlParams.type}`);
                    
                    // Handle tab switching based on URL parameter
                    if (urlParams.tab === 'data-builder') {
                        // Only switch to data-builder if explicitly requested
                        currentMainTab = 'data-builder';
                        setTimeout(() => switchMainTab('data-builder'), 100);
                    } else {
                        // Explicitly stay on data-builder
                        currentMainTab = 'data-builder';
                        console.log('üìä Staying on data-builder with loaded data');
                        
                        // Ensure data-builder tab stays active
                        document.querySelectorAll('.main-tab').forEach(tab => {
                            tab.classList.remove('active');
                        });
                        const dataBuilderTab = document.querySelector(`[onclick="switchMainTab('data-builder')"]`);
                        if (dataBuilderTab) {
                            dataBuilderTab.classList.add('active');
                        }
                        
                        document.querySelectorAll('.tab-content').forEach(content => {
                            content.classList.remove('active');
                        });
                        const dataBuilderContent = document.getElementById('data-builder');
                        if (dataBuilderContent) {
                            dataBuilderContent.classList.add('active');
                        }
                        
                        // Lock data builder to prevent automatic switching
                        lockChartView = true;
                        
                        console.log('üìä Data builder explicitly activated and locked');
                    }
                    
                    console.log(`‚úÖ Flow Builder initialized with ${urlParams.type} sample data`);
                    isInitialized = true;
                    return;
                }
            }
            
            // No URL parameters and no existing data - handle based on chart type
            console.log('‚ö†Ô∏è No data found, checking chart type');
            
            // Check for chart type in URL (either 'type' or 'chartType' parameter)
            const chartType = urlParams.type || urlParams.chartType;
            
            if (!chartType) {
                // No chart type specified, redirect to guided selection
                console.log('üåä No chart type specified, redirecting to guided selection');
                window.location.href = 'guided.html';
            } else if (chartType === 'bar') {
                // Bar chart - initialize bar chart mode with data input interface
                console.log('üìä Bar chart mode - initializing data input interface');
                
                // Ensure DOM is ready before calling handleChartTypeChange
                setTimeout(() => {
                    console.log('üìä DOM ready, calling handleChartTypeChange for bar chart');
                    if (typeof handleChartTypeChange === 'function') {
                        // **CRITICAL FIX: Wait for app to be ready before switching**
                        const waitForAppInit = () => {
                            if (window.pulseApp && window.pulseApp.isInitialized) {
                                console.log('‚úÖ App initialized, switching to bar chart');
                                handleChartTypeChange('bar');
                                console.log('üìä handleChartTypeChange called successfully');
                            } else {
                                console.log('‚è≥ Waiting for app initialization...');
                                setTimeout(waitForAppInit, 200);
                            }
                        };
                        waitForAppInit();
                    } else {
                        console.error('‚ùå handleChartTypeChange function not found');
                    }
                }, 100);
                
                isInitialized = true;
            } else {
                // Sankey chart without data - redirect to type selector
                console.log('üåä Sankey chart mode - redirecting to type selector');
                window.location.href = 'js/charts/sankey/sankey-type-selector.html';
            }
        }

        function loadCurrentChartData() {
            const data = window.PulseDataBridge.getData();
            if (data) {
                // CRITICAL: Preserve existing colors
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData = convertSankeyDataToFlows(data);
                
                // CRITICAL: Restore colors
                flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                
                updateMetadataInputs();
                renderFlowTable();
                updateAllStats();
                
            } else {
                alert('‚ùå No chart data available. Please load a dataset in Chart View first.');
            }
        }

        function loadCompleteTemplate() {
            // CRITICAL: Preserve existing colors
            const existingColors = { ...flowData.metadata.colorPalette };
            
            flowData.metadata.company = "TechFlow Corporation";
            flowData.metadata.title = "TechFlow Financial Flow";
            
            // CRITICAL: Restore colors
            flowData.metadata.colorPalette = existingColors;
            
            flowData.flows = [
                new BusinessFlow({
                    source: "Subscription Revenue",
                    target: "Total Revenue",
                    value: 300,
                    previousValue: 305,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Recurring subscription income"
                }),
                new BusinessFlow({
                    source: "Professional Services",
                    target: "Total Revenue",
                    value: 60,
                    previousValue: 55,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Implementation and consulting"
                }),
                new BusinessFlow({
                    source: "Platform & Other",
                    target: "Total Revenue",
                    value: 135,
                    previousValue: 120,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Platform fees and other revenue"
                }),
                new BusinessFlow({
                    source: "Total Revenue",
                    target: "Gross Profit",
                    value: 340,
                    previousValue: 290,
                    flowType: "profit_flow",
                    sourceLayer: 1,
                    targetLayer: 2,
                    sourceCategory: "revenue",
                    targetCategory: "profit",
                    description: "Revenue after cost of revenue"
                }),
                new BusinessFlow({
                    source: "Total Revenue",
                    target: "Cost of Revenue",
                    value: 55,
                    previousValue: 50,
                    flowType: "expense_flow",
                    sourceLayer: 1,
                    targetLayer: 2,
                    sourceCategory: "revenue",
                    targetCategory: "expense",
                    description: "Direct costs to deliver services"
                }),
                new BusinessFlow({
                    source: "Gross Profit",
                    target: "Operating Profit",
                    value: 65,
                    previousValue: 55,
                    flowType: "profit_flow",
                    sourceLayer: 2,
                    targetLayer: 3,
                    sourceCategory: "profit",
                    targetCategory: "profit",
                    description: "Profit from core operations"
                }),
                new BusinessFlow({
                    source: "Gross Profit",
                    target: "Operating Expenses",
                    value: 155,
                    previousValue: 140,
                    flowType: "expense_flow",
                    sourceLayer: 2,
                    targetLayer: 3,
                    sourceCategory: "profit",
                    targetCategory: "expense",
                    description: "Total operating expenses"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "Sales & Marketing",
                    value: 85,
                    previousValue: 75,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "Customer acquisition expenses"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "R&D",
                    value: 45,
                    previousValue: 40,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "Research and development"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "G&A",
                    value: 20,
                    previousValue: 18,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "General and administrative"
                }),
                new BusinessFlow({
                    source: "Operating Profit",
                    target: "Net Income",
                    value: 50,
                    previousValue: 42,
                    flowType: "profit",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "profit",
                    targetCategory: "profit",
                    description: "Final net income"
                }),
                new BusinessFlow({
                    source: "Operating Profit",
                    target: "Tax Expense",
                    value: 12,
                    previousValue: 10,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "profit",
                    targetCategory: "expense",
                    description: "Income tax expense"
                })
            ];
            
            // Form field removed - metadata now handled via click-to-edit title
            renderFlowTable();
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        function loadBlankFlows() {
            if (confirm('This will clear all current flows. Continue?')) {
                // CRITICAL: Preserve existing colors
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData.flows = [
                    new BusinessFlow({
                        source: "Revenue Source",
                        target: "Total Revenue",
                        value: 100,
                        previousValue: 0,
                        description: "Start building your flow here"
                    })
                ];
                
                // CRITICAL: Restore colors
                flowData.metadata.colorPalette = existingColors;
                
                renderFlowTable();
                updateAllStats();
                debouncedRealTimeUpdate();
            }
        }

        function resetToChartData() {
            loadCurrentChartData();
        }

        // Node highlighting functionality
        let highlightState = 'off'; // 'off', 'profit', 'revenue', 'expense'
        const highlightStates = ['off', 'profit', 'revenue', 'expense'];

        function toggleNodeHighlighting() {
            console.log('üí° Toggling node highlighting...');
            
            // Cycle through highlight states
            const currentIndex = highlightStates.indexOf(highlightState);
            const nextIndex = (currentIndex + 1) % highlightStates.length;
            highlightState = highlightStates[nextIndex];
            
            // Update button text and color
            const button = document.getElementById('highlight-toggle-btn');
            if (button) {
                if (highlightState === 'off') {
                    button.innerHTML = 'üí° Highlight: Off';
                    button.style.background = '#6366f1';
                } else {
                    button.innerHTML = `üí° Highlight: ${highlightState.charAt(0).toUpperCase() + highlightState.slice(1)}`;
                    // Set color based on category
                    if (highlightState === 'profit') {
                        button.style.background = '#059669'; // Green
                    } else if (highlightState === 'revenue') {
                        button.style.background = '#1e40af'; // Blue
                    } else if (highlightState === 'expense') {
                        button.style.background = '#dc2626'; // Red
                    }
                }
            }
            
            // Apply highlighting to chart
            applyNodeHighlighting();
        }

        function applyNodeHighlighting() {
            console.log(`üéØ Applying node highlighting: ${highlightState}`);
            
            // Get current chart instance
            let chart = null;
            if (window.flowBuilderChart) {
                chart = window.flowBuilderChart;
            } else if (window.pulseApp && window.pulseApp.chart) {
                chart = window.pulseApp.chart;
            }
            
            if (!chart) {
                console.warn('‚ö†Ô∏è No chart instance found for highlighting');
                return;
            }
            
            // Use the chart's built-in highlighting method if available
            if (typeof chart.highlightNodesByCategory === 'function') {
                chart.highlightNodesByCategory(highlightState);
                return;
            }
            
            // Fallback to direct DOM manipulation
            if (highlightState === 'off') {
                // Reset all nodes to normal opacity
                chart.chart.selectAll('.sankey-node rect')
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', chart.config.nodeOpacity)
                    .style('stroke-width', '2px')
                    .style('stroke', 'white');
                
                // Reset all links to normal opacity
                chart.chart.selectAll('.sankey-link path')
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', chart.config.linkOpacity);
                    
                // Reset all labels to normal opacity
                chart.chart.selectAll('.node-text-group')
                    .transition()
                    .duration(300)
                    .style('opacity', 1);
            } else {
                // Dim all nodes first
                chart.chart.selectAll('.sankey-node rect')
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', 0.2)
                    .style('stroke-width', '1px')
                    .style('stroke', '#e5e7eb');
                
                // Dim all links
                chart.chart.selectAll('.sankey-link path')
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', 0.1);
                    
                // Dim all labels
                chart.chart.selectAll('.node-text-group')
                    .transition()
                    .duration(300)
                    .style('opacity', 0.3);
                
                // Highlight matching nodes
                chart.chart.selectAll('.sankey-node rect')
                    .filter(function(d) {
                        return d.category === highlightState;
                    })
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', 1)
                    .style('stroke-width', '3px')
                    .style('stroke', function() {
                        if (highlightState === 'profit') return '#059669';
                        if (highlightState === 'revenue') return '#1e40af';
                        if (highlightState === 'expense') return '#dc2626';
                        return 'white';
                    });
                
                // Highlight matching labels
                chart.chart.selectAll('.node-text-group')
                    .filter(function(d) {
                        return d.category === highlightState;
                    })
                    .transition()
                    .duration(300)
                    .style('opacity', 1);
                
                // Highlight related links
                chart.chart.selectAll('.sankey-link path')
                    .filter(function(d) {
                        return d.source.category === highlightState || d.target.category === highlightState;
                    })
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', chart.config.linkOpacity);
            }
        }

        function updateMetadataInputs() {
            const fields = [
                { id: 'company-name', value: flowData.metadata.company },
                { id: 'period', value: flowData.metadata.period },
                { id: 'currency', value: flowData.metadata.currency },
                { id: 'units', value: flowData.metadata.unit },
                { id: 'period-type', value: flowData.metadata.periodType || 'Q/Q' }
            ];
            
            fields.forEach(({ id, value }) => {
                const element = document.getElementById(id);
                if (element && value) {
                    element.value = value;
                }
            });
        }

        function renderFlowTable() {
            const tbody = document.getElementById('flows-tbody');
            tbody.innerHTML = '';
            
            // Auto-calculate layers and flow types before rendering
            autoCalculateFlowProperties();
            
            // Always ensure we have at least one empty row
            if (flowData.flows.length === 0) {
                addFlow(); // This will add one empty row
                return; // renderFlowTable will be called again
            }
            
            // Check if the last row is empty, if not add an empty row
            const lastFlow = flowData.flows[flowData.flows.length - 1];
            const isLastRowEmpty = !lastFlow.source && !lastFlow.target && lastFlow.value === 0;
            
            if (!isLastRowEmpty) {
                // Add an empty row at the end
                const statementType = detectFinancialStatementType();
                const categories = getCategoriesForStatementType(statementType);
                const defaultCategory = categories[0].value;
                
                const emptyFlow = new BusinessFlow({
                    source: "",
                    target: "", 
                    value: 0,
                    previousValue: 0,
                    sourceCategory: defaultCategory,
                    targetCategory: defaultCategory,
                    description: ""
                });
                
                flowData.flows.push(emptyFlow);
            }
            
            flowData.flows.forEach((flow, index) => {
                const row = createFlowRow(flow, index);
                tbody.appendChild(row);
            });
            
            // Apply variance colors after all rows are added
            applyVarianceColors();
            
            // Initialize category buttons to show current categories
            setTimeout(() => initializeCategoryButtons(), 50);
            
        }

        // Helper function to detect financial statement type
        function detectFinancialStatementType() {
            if (!flowData || !flowData.flows || flowData.flows.length === 0) {
                return 'income_statement'; // Default to income statement
            }
            
            // Check if we have balance sheet categories
            const hasBalanceSheetCategories = flowData.flows.some(flow => 
                flow.sourceCategory === 'asset' || flow.targetCategory === 'asset' ||
                flow.sourceCategory === 'liability' || flow.targetCategory === 'liability' ||
                flow.sourceCategory === 'equity' || flow.targetCategory === 'equity'
            );
            
            return hasBalanceSheetCategories ? 'balance_sheet' : 'income_statement';
        }
        
        // Helper function to get appropriate categories for statement type
        function getCategoriesForStatementType(statementType) {
            if (statementType === 'balance_sheet') {
                return [
                    { value: 'asset', label: 'Asset' },
                    { value: 'liability', label: 'Liability' },
                    { value: 'equity', label: 'Equity' }
                ];
            } else {
                return [
                    { value: 'revenue', label: 'Revenue' },
                    { value: 'expense', label: 'Expense' },
                    { value: 'profit', label: 'Profit' }
                ];
            }
        }

        function createFlowRow(flow, index) {
            const tr = document.createElement('tr');
            tr.setAttribute('data-row', index);
            
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            
            // Check if this is an empty row (declare early to use throughout)
            const isEmpty = !flow.source && !flow.target && flow.value === 0;
            
            let rowHTML = `
                <td class="control-cell">
                    <div class="flow-controls">
                        <button class="flow-control-btn remove" onclick="removeFlow(${index})" title="Remove">√ó</button>
                    </div>
                </td>
                <td class="spreadsheet-cell" data-col="source" data-row="${index}" data-type="text">
                    <div class="cell-content">${flow.source}</div>
                    <input type="text" class="cell-editor" style="display: none;">
                </td>
                <td class="spreadsheet-cell" data-col="target" data-row="${index}" data-type="text">
                    <div class="cell-content">${flow.target}</div>
                    <input type="text" class="cell-editor" style="display: none;">
                </td>
                <td class="spreadsheet-cell" data-col="description" data-row="${index}" data-type="text">
                    <div class="cell-content">${flow.description || ''}</div>
                    <input type="text" class="cell-editor" style="display: none;" placeholder="Flow description...">
                </td>
                <td class="spreadsheet-cell" data-col="value" data-row="${index}" data-type="number">
                    <div class="cell-content">${isEmpty ? '' : (flow.value ? flow.value.toLocaleString() : '0')}</div>
                    <input type="number" class="cell-editor" style="display: none;">
                </td>
                <td class="spreadsheet-cell" data-col="previousValue" data-row="${index}" data-type="number">
                    <div class="cell-content">${flow.previousValue ? flow.previousValue.toLocaleString() : ''}</div>
                    <input type="number" class="cell-editor" style="display: none;" placeholder="0">
                </td>
                <td class="variance-cell">
                    <div style="font-size: 11px; text-align: center;">${isEmpty ? '' : flow.getVarianceDisplay()}</div>
                </td>
`;
            
            // Get context-aware categories
            const statementType = detectFinancialStatementType();
            const categories = getCategoriesForStatementType(statementType);
            
            tr.innerHTML = rowHTML;
            return tr;
        }

        // Helper functions for display formatting
        function getFlowTypeDisplay(flowType) {
            const types = {
                'revenue_flow': 'Revenue Flow',
                'expense_flow': 'Expense Flow', 
                'profit_flow': 'Profit Flow'
            };
            return types[flowType] || flowType;
        }

        function getCategoryDisplay(category) {
            return category.charAt(0).toUpperCase() + category.slice(1);
        }

        function getVarianceClass(flow) {
            const variance = flow.getVariance();
            
            if (variance.trend === 'up') {
                return 'variance-positive';
            } else if (variance.trend === 'down') {
                return 'variance-negative';
            } else {
                return 'variance-neutral';
            }
        }
        
        function applyVarianceColors() {
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            if (!comparisonMode) return;
            
            // Use setTimeout to ensure DOM is fully rendered
            setTimeout(() => {
                const varianceCells = document.querySelectorAll('.variance-cell div');
                varianceCells.forEach((cell, index) => {
                    if (index < flowData.flows.length) {
                        const flow = flowData.flows[index];
                        const variance = flow.getVariance();
                        
                        // Apply colors using CSS classes first, then inline styles as backup
                        cell.className = ''; // Clear existing classes
                        
                        if (variance.trend === 'up') {
                            cell.classList.add('variance-positive');
                            cell.style.color = '#16a34a';
                            cell.style.fontWeight = '700';
                        } else if (variance.trend === 'down') {
                            cell.classList.add('variance-negative');
                            cell.style.color = '#dc2626';
                            cell.style.fontWeight = '700';
                        } else {
                            cell.classList.add('variance-neutral');
                            cell.style.color = '#6b7280';
                            cell.style.fontWeight = '600';
                        }
                    }
                });
            }, 50); // Small delay to ensure DOM is ready
        }

        // Auto-calculate layers and flow types when flows are updated
        function autoCalculateFlowProperties() {
            if (!flowData.flows || flowData.flows.length === 0) return;

            // Build a node hierarchy map
            const nodeInputs = new Map(); // node -> list of sources
            const nodeOutputs = new Map(); // node -> list of targets
            
            flowData.flows.forEach(flow => {
                if (!nodeInputs.has(flow.target)) nodeInputs.set(flow.target, []);
                if (!nodeOutputs.has(flow.source)) nodeOutputs.set(flow.source, []);
                
                nodeInputs.get(flow.target).push(flow.source);
                nodeOutputs.get(flow.source).push(flow.target);
            });

            // Calculate layers using topological ordering
            const layers = new Map();
            const processed = new Set();
            
            // Start with nodes that have no inputs (sources)
            const queue = [];
            for (let flow of flowData.flows) {
                if (!nodeInputs.has(flow.source) || nodeInputs.get(flow.source).length === 0) {
                    if (!layers.has(flow.source)) {
                        layers.set(flow.source, 0);
                        queue.push(flow.source);
                    }
                }
            }
            
            // Process nodes level by level
            while (queue.length > 0) {
                const currentNode = queue.shift();
                if (processed.has(currentNode)) continue;
                processed.add(currentNode);
                
                const currentLayer = layers.get(currentNode) || 0;
                
                // Update targets to be at least one layer deeper
                if (nodeOutputs.has(currentNode)) {
                    for (let target of nodeOutputs.get(currentNode)) {
                        const targetLayer = Math.max(layers.get(target) || 0, currentLayer + 1);
                        layers.set(target, targetLayer);
                        queue.push(target);
                    }
                }
            }

            // Apply calculated layers and auto-determine flow types
            flowData.flows.forEach(flow => {
                flow.sourceLayer = layers.get(flow.source) || 0;
                flow.targetLayer = layers.get(flow.target) || flow.sourceLayer + 1;
                
                // Auto-determine flow type based on categories
                if (flow.sourceCategory === 'revenue' && flow.targetCategory === 'revenue') {
                    flow.flowType = 'revenue_flow';
                } else if (flow.targetCategory === 'expense' || flow.targetCategory === 'cost' || flow.targetCategory === 'tax') {
                    flow.flowType = 'expense_flow';
                } else if (flow.sourceCategory === 'profit' || flow.targetCategory === 'profit' || flow.targetCategory === 'income') {
                    flow.flowType = 'profit_flow';
                } else if (flow.sourceCategory === 'cost' || flow.sourceCategory === 'expense') {
                    flow.flowType = 'expense_flow';
                } else if (flow.sourceCategory === 'asset' || flow.targetCategory === 'asset') {
                    flow.flowType = 'asset_flow';
                } else if (flow.sourceCategory === 'liability' || flow.targetCategory === 'liability') {
                    flow.flowType = 'liability_flow';
                } else if (flow.sourceCategory === 'equity' || flow.targetCategory === 'equity') {
                    flow.flowType = 'equity_flow';
                } else {
                    flow.flowType = 'revenue_flow'; // default
                }
            });
        }

        function getFlowBalanceIndicator(flow) {
            const isValid = flow.source && flow.target && flow.value > 0 && flow.sourceLayer < flow.targetLayer;
            return `<div class="balance-indicator ${isValid ? 'balanced' : 'unbalanced'}">${isValid ? '‚úì' : '‚ö†'}</div>`;
        }

        function addFlow() {
            // Get appropriate default category for the statement type
            const statementType = detectFinancialStatementType();
            const categories = getCategoriesForStatementType(statementType);
            const defaultCategory = categories[0].value;
            
            const newFlow = new BusinessFlow({
                source: "",
                target: "", 
                value: 0,
                previousValue: 0,
                sourceCategory: defaultCategory,
                targetCategory: defaultCategory,
                description: ""
            });
            
            flowData.flows.push(newFlow);
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }
        
        function addFlows() {
            const rowsToAdd = parseInt(document.getElementById('rows-to-add').value) || 1;
            
            // Get appropriate default category for the statement type
            const statementType = detectFinancialStatementType();
            const categories = getCategoriesForStatementType(statementType);
            const defaultCategory = categories[0].value;
            
            for (let i = 0; i < rowsToAdd; i++) {
                const newFlow = new BusinessFlow({
                    source: "",
                    target: "", 
                    value: 0,
                    previousValue: 0,
                    sourceCategory: defaultCategory,
                    targetCategory: defaultCategory,
                    description: ""
                });
                
                flowData.flows.push(newFlow);
            }
            
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        function removeFlow(index) {
            flowData.flows.splice(index, 1);
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        // moveFlowUp, moveFlowDown, and duplicateFlow functions removed
        // Users can now use copy/paste functionality for these operations

        function updateMetadata() {
            // Form fields removed - metadata now extracted from chart title
            const chartTitle = findChartTitle();
            if (chartTitle && chartTitle.textContent) {
                const titleText = chartTitle.textContent.trim();
                if (titleText.includes('Income Statement')) {
                    const parts = titleText.replace(' Income Statement', '').trim().split(' ');
                    if (parts.length >= 2) {
                        flowData.metadata.period = parts.pop();
                        flowData.metadata.company = parts.join(' ');
                    }
                } else if (titleText.includes('Balance Sheet')) {
                    const parts = titleText.replace(' Balance Sheet', '').trim().split(' ');
                    if (parts.length >= 2) {
                        flowData.metadata.period = parts.pop();
                        flowData.metadata.company = parts.join(' ');
                    }
                }
            }
            
            // Set defaults if not found
            flowData.metadata.company = flowData.metadata.company || 'TechFlow SaaS Corp';
            flowData.metadata.period = flowData.metadata.period || 'Q3 2025';
            flowData.metadata.currency = flowData.metadata.currency || 'USD ($)';
            flowData.metadata.unit = flowData.metadata.unit || 'Millions';
            flowData.metadata.periodType = flowData.metadata.periodType || 'Q/Q';
            flowData.metadata.title = `${flowData.metadata.company} Financial Flow`;
            
            debouncedRealTimeUpdate();
        }


        function updateAllStats() {
            const nodeMap = new Map();
            
            flowData.flows.forEach(flow => {
                nodeMap.set(flow.source, flow.sourceLayer);
                nodeMap.set(flow.target, flow.targetLayer);
            });
            
            const flowCount = flowData.flows.length;
            const nodeCount = nodeMap.size;
            const layerCount = new Set(Array.from(nodeMap.values())).size;
            
            let balancedFlows = 0;
            flowData.flows.forEach(flow => {
                const isValid = flow.source && flow.target && flow.value > 0 && flow.sourceLayer < flow.targetLayer;
                if (isValid) balancedFlows++;
            });
            
            const balanceScore = flowCount > 0 ? Math.round((balancedFlows / flowCount) * 100) : 0;
            
            // Chart stats UI removed - keeping calculations for internal use only
            // document.getElementById('flow-count').textContent = flowCount;
            // document.getElementById('node-count').textContent = nodeCount;
            // document.getElementById('layer-count').textContent = layerCount;
            // document.getElementById('balance-score').textContent = balanceScore + '%';
        }

        function applyFlowChanges() {
            console.log('üöÄ Applying Flow Builder changes...');
            console.log('üìä Current flow data:', flowData);
            
            // Form fields removed - use existing metadata or defaults
            flowData.metadata.company = flowData.metadata.company || 'TechFlow SaaS Corp';
            flowData.metadata.period = flowData.metadata.period || 'Q3 2025';
            flowData.metadata.currency = flowData.metadata.currency || 'USD ($)';
            flowData.metadata.unit = flowData.metadata.unit || 'Millions';
            flowData.metadata.title = `${flowData.metadata.company} Financial Flow`;
            
            const sankeyData = generateNodesAndLinksFromFlows();
            console.log('üìà Generated Sankey data:', sankeyData);
            window.PulseDataBridge.applyFlowBuilderChanges(sankeyData);
            
            // Reset highlighting when chart data changes
            resetNodeHighlighting();
            
            // Re-initialize category buttons after data changes
            setTimeout(() => initializeCategoryButtons(), 100);
            
            // Chart view removed - staying on data-builder
            
            console.log('‚úÖ Changes applied and switched to Chart View');
        }

        function validateFlows() {
            const errors = [];
            const warnings = [];
            
            if (flowData.flows.length === 0) {
                errors.push('No flows defined');
            }
            
            flowData.flows.forEach((flow, index) => {
                if (!flow.source || !flow.target) {
                    errors.push(`Flow ${index + 1}: Missing source or target`);
                }
                
                if (flow.value <= 0) {
                    errors.push(`Flow ${index + 1}: Invalid value (${flow.value})`);
                }
                
                if (flow.sourceLayer >= flow.targetLayer) {
                    errors.push(`Flow ${index + 1}: Source layer must be less than target layer`);
                }
                
                if (flow.source === flow.target) {
                    errors.push(`Flow ${index + 1}: Source and target cannot be the same`);
                }
            });
            
            let message = '‚úÖ Flow Validation Results\n\n';
            
            if (errors.length > 0) {
                message += '‚ùå Errors:\n' + errors.map(e => `‚Ä¢ ${e}`).join('\n') + '\n\n';
            }
            
            if (warnings.length > 0) {
                message += '‚ö†Ô∏è Warnings:\n' + warnings.map(w => `‚Ä¢ ${w}`).join('\n') + '\n\n';
            }
            
            if (errors.length === 0 && warnings.length === 0) {
                message += 'Perfect! All flows are valid.\n\n';
            }
            
            // Calculate balance score locally since UI element was removed
            let balancedFlows = 0;
            flowData.flows.forEach(flow => {
                const isValid = flow.source && flow.target && flow.value > 0 && flow.sourceLayer < flow.targetLayer;
                if (isValid) balancedFlows++;
            });
            const balanceScore = flowData.flows.length > 0 ? Math.round((balancedFlows / flowData.flows.length) * 100) : 0;
            message += `üìä Summary:\n‚Ä¢ ${flowData.flows.length} flows\n‚Ä¢ Balance Score: ${balanceScore}%`;
            
            alert(message);
        }

        function exportFlowsToCSV() {
            let csv = 'Source,Target,Current Value,Previous Value,Description\n';
            
            flowData.flows.forEach(flow => {
                csv += `"${flow.source}","${flow.target}",${flow.value},${flow.previousValue || 0},"${flow.description}"\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${flowData.metadata.company.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()}-flows.csv`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importFlowsFromCSV() {
            document.getElementById('csv-file-input').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                
                if (file.name.endsWith('.json')) {
                    try {
                        const data = JSON.parse(content);
                        
                        // CRITICAL: Preserve existing colors before import
                        const existingColors = { ...flowData.metadata.colorPalette };
                        
                        if (data.flows) {
                            flowData = data;
                        } else if (data.nodes && data.links) {
                            flowData = convertSankeyDataToFlows(data);
                        }
                        
                        // CRITICAL: Restore colors after import
                        flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                        
                        renderFlowTable(); // This calls autoCalculateFlowProperties()
                        updateAllStats();
                        
                        // Force chart update with the imported data
                        debouncedRealTimeUpdate();
                        
                        alert('‚úÖ Successfully imported flows!');
                    } catch (error) {
                        alert('‚ùå Error parsing JSON: ' + error.message);
                    }
                } else if (file.name.endsWith('.csv')) {
                    parseCSVFlows(content);
                }
            };
            reader.readAsText(file);
        }

        function parseCSVFlows(csvContent) {
            const lines = csvContent.split('\n').filter(line => line.trim() && !line.startsWith('#'));
            if (lines.length < 2) {
                alert('‚ùå CSV file must have header and at least one data row');
                return;
            }
            
            // Parse header to detect column positions
            const headers = parseCSVLine(lines[0]).map(h => h.toLowerCase().trim());
            const columnMap = {
                source: Math.max(headers.indexOf('source'), headers.indexOf('from')),
                target: Math.max(headers.indexOf('target'), headers.indexOf('to')),
                amount: Math.max(headers.indexOf('amount'), headers.indexOf('current value'), headers.indexOf('value')),
                previousAmount: Math.max(headers.indexOf('previous amount'), headers.indexOf('previous value')),
                description: headers.indexOf('description')
            };
            
            // CRITICAL: Preserve existing colors before import
            const existingColors = { ...flowData.metadata.colorPalette };
            
            const flows = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                
                // Get source and target values with fallback logic
                const sourceValue = columnMap.source >= 0 ? values[columnMap.source] : `Flow ${i} Source`;
                const targetValue = columnMap.target >= 0 ? values[columnMap.target] : `Flow ${i} Target`;
                const amountValue = columnMap.amount >= 0 ? parseFloat(values[columnMap.amount]) : 100;
                
                // Minimum requirement: at least one meaningful value
                if (values.length >= 1 && (sourceValue || targetValue || amountValue)) {
                    const previousValue = columnMap.previousAmount >= 0 && values[columnMap.previousAmount] 
                        ? parseFloat(values[columnMap.previousAmount]) || 0 
                        : 0;
                    
                    flows.push(new BusinessFlow({
                        source: sourceValue || `Flow ${i} Source`,
                        target: targetValue || `Flow ${i} Target`,
                        value: amountValue || 100,
                        previousValue: previousValue,
                        sourceCategory: 'revenue', // Default to revenue
                        targetCategory: 'revenue', // Default to revenue
                        description: (columnMap.description >= 0 ? values[columnMap.description] : null) || `Flow from ${sourceValue || 'Source'} to ${targetValue || 'Target'}`
                        // Note: flowType, sourceLayer, targetLayer will be auto-calculated
                    }));
                }
            }
            
            if (flows.length > 0) {
                flowData.flows = flows;
                
                // CRITICAL: Restore colors after import
                flowData.metadata.colorPalette = existingColors;
                
                // Enable comparison mode if any previous values exist
                const hasPreviousValues = flows.some(flow => flow.previousValue > 0);
                if (hasPreviousValues) {
                    document.getElementById('comparison-mode-toggle').checked = true;
                    toggleComparisonMode();
                }
                
                renderFlowTable(); // This calls autoCalculateFlowProperties()
                updateAllStats();
                
                // Force chart update with the imported data
                debouncedRealTimeUpdate();
                
                console.log('‚úÖ Flow Builder refreshed successfully');
                
                // Provide helpful feedback about what was imported
                let message = `‚úÖ Successfully imported ${flows.length} flows from CSV!\n\n`;
                
                if (columnMap.source < 0 || columnMap.target < 0) {
                    message += '‚ö†Ô∏è Note: Some source/target columns were missing and have been auto-generated. ';
                    message += 'You can edit these in the table below.\n\n';
                }
                
                message += '‚ÑπÔ∏è Categories have been set to default values. You can adjust them using the color picker modal.\n\n';
                
                message += 'The chart will update automatically as you edit the data.';
                
                alert(message);
            } else {
                alert('‚ùå No valid flows found in CSV file');
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result.map(field => field.replace(/^"|"$/g, ''));
        }

        // FIXED: Generate nodes and links with proper color preservation and percentage metrics
        function generateNodesAndLinksFromFlows() {
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            const result = PulseSankeyChart.generateNodesAndLinksFromFlows(flowData, comparisonMode);
            
            // Preserve the comparison mode in metadata
            result.metadata.comparisonMode = comparisonMode;
            
            // Determine chart type based on categories
            const isBalanceSheet = flowData.flows.some(flow => 
                flow.sourceCategory === 'asset' || flow.targetCategory === 'asset' ||
                flow.sourceCategory === 'liability' || flow.targetCategory === 'liability' ||
                flow.sourceCategory === 'equity' || flow.targetCategory === 'equity'
            );
            
            result.metadata.statementType = isBalanceSheet ? 'balance' : 'income';
            
            // Calculate percentage metrics
            if (isBalanceSheet) {
                // For Balance Sheet: Add growth/decline percentages
                result.nodes.forEach(node => {
                    const matchingFlow = flowData.flows.find(flow => 
                        flow.source === node.id || flow.target === node.id
                    );
                    if (matchingFlow) {
                        node.growthDecline = matchingFlow.getGrowthDeclineDisplay();
                        node.hasPercentages = true;
                    }
                });
            } else {
                // For Income Statement: Add both growth/decline and margin percentages
                const revenueBase = findRevenueBase(flowData);
                
                result.nodes.forEach(node => {
                    const matchingFlow = flowData.flows.find(flow => 
                        flow.source === node.id || flow.target === node.id
                    );
                    if (matchingFlow) {
                        node.growthDecline = matchingFlow.getGrowthDeclineDisplay();
                        // Calculate percentage of revenue for this node's value
                        node.marginPercentage = getRevenuePercentage(node.value, revenueBase);
                        node.hasPercentages = true;
                    }
                });
                
                result.metadata.revenueBase = revenueBase;
            }
            
            console.log(`üìä Generated ${result.metadata.statementType} chart data with percentage metrics`);
            return result;
        }

        // IIFE: Single Initialization Controller - Eliminates All Redundancy
        (function() {
            'use strict';
            
            // State management to prevent duplicate operations
            const initState = {
                isInitialized: false,
                chartTypeProcessed: false,
                tabSwitchProcessed: false,
                renderCompleted: false
            };
            
            console.log('üéØ IIFE: Starting single initialization sequence');
            
            document.addEventListener('DOMContentLoaded', async function() {
                if (initState.isInitialized) {
                    console.log('‚ö†Ô∏è Already initialized, skipping');
                    return;
                }
                
                initState.isInitialized = true;
                console.log('üöÄ Single initialization starting...');
                
                // Basic UI setup
                setupBasicUI();
                
                // Add event listener for flow table updates from chart edits
                window.addEventListener('flowTableUpdate', (event) => {
                    console.log('üìä Received flowTableUpdate event:', event.detail);
                    try {
                        if (event.detail.source === 'chart-edit' && event.detail.data) {
                            console.log('üîÑ Processing flow table update for unified interface...');
                            
                            // Method 1: Try to update flowData and renderFlowTable (if available)
                            if (typeof convertSankeyDataToFlows === 'function' && 
                                typeof renderFlowTable === 'function') {
                                
                                console.log('‚úÖ Converting chart data to flow format...');
                                const convertedFlowData = convertSankeyDataToFlows(event.detail.data);
                                
                                // Initialize flowData if it doesn't exist
                                if (!window.flowData) {
                                    console.log('üîß Initializing flowData from chart edit...');
                                    window.flowData = {
                                        flows: [],
                                        metadata: {
                                            company: "Chart Data",
                                            title: "Financial Flow",
                                            period: "Current", 
                                            colorPalette: {},
                                            comparisonMode: false
                                        }
                                    };
                                }
                                
                                // Preserve existing metadata (colors, etc.)
                                const existingMetadata = window.flowData.metadata || {};
                                window.flowData.flows = convertedFlowData.flows;
                                window.flowData.metadata = {
                                    ...existingMetadata,
                                    ...convertedFlowData.metadata
                                };
                                
                                console.log('‚úÖ Updated flowData, following reset button sequence...');
                                
                                // Follow the exact same sequence as the working reset button
                                // Update metadata inputs (critical step)
                                if (typeof updateMetadataInputs === 'function') {
                                    console.log('üìù Calling updateMetadataInputs()...');
                                    updateMetadataInputs();
                                }
                                
                                // Re-render the flow table
                                console.log('üîÑ Calling renderFlowTable()...');
                                renderFlowTable();
                                
                                // Update statistics
                                if (typeof updateAllStats === 'function') {
                                    console.log('üìä Calling updateAllStats()...');
                                    updateAllStats();
                                }
                                
                                console.log('‚úÖ Flow table updated via reset button sequence');
                            } else {
                                console.log('‚ÑπÔ∏è Flow table functions not available, relying on direct update');
                            }
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Error handling flowTableUpdate event:', error.message);
                        console.error(error);
                    }
                });
                
                // Parse URL parameters once
                const urlParams = new URLSearchParams(window.location.search);
                const chartType = urlParams.get('chartType') || urlParams.get('type');
                const targetTab = urlParams.get('tab');
                
                console.log(`üîç URL params - chartType: ${chartType}, tab: ${targetTab}`);
                
                // Wait for pulseApp to be ready
                await waitForPulseApp();
                
                // Handle chart type in one place only
                if (chartType && !initState.chartTypeProcessed) {
                    initState.chartTypeProcessed = true;
                    console.log(`üéØ Processing chart type: ${chartType} (SINGLE)`);
                    
                    // Update selector UI
                    const chartTypeSelect = document.getElementById('chart-type-select');
                    if (chartTypeSelect) {
                        chartTypeSelect.value = chartType;
                    }
                    
                    // Single chart type change
                    if (chartType === 'bar') {
                        await handleBarChartInitialization();
                        
                        // Chart view removed - staying on data-builder
                        console.log('üìä Staying on data-builder (chart-view removed)');
                    } else {
                        await handleOtherChartTypes(chartType);
                    }
                } else if (!chartType) {
                    // No chart type in URL, initialize interface normally
                    console.log('üìä No chart type in URL, initializing interface');
                    initializeChartInterface();
                }
                
                // Set up event listeners only once
                setupEventListeners();
                
                console.log('‚úÖ Single initialization complete');
            });
            
            // Helper: Basic UI setup
            function setupBasicUI() {
                const csvFileInput = document.getElementById('csv-file-input');
                if (csvFileInput) {
                    csvFileInput.addEventListener('change', handleFileImport);
                }
                

                // Initialize SpreadsheetController for Sankey flow builder
                window.spreadsheetController = new SpreadsheetController();
            }
            
            // Helper: Wait for pulseApp to be ready
            function waitForPulseApp() {
                return new Promise((resolve) => {
                    if (window.pulseApp && window.pulseApp.isInitialized) {
                        console.log('‚úÖ PulseApp ready immediately');
                        resolve();
                        return;
                    }
                    
                    console.log('‚è≥ Waiting for PulseApp...');
                    const checkInterval = setInterval(() => {
                        if (window.pulseApp && window.pulseApp.isInitialized) {
                            console.log('‚úÖ PulseApp ready');
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 50);
                    
                    // Timeout after 5 seconds
                    setTimeout(() => {
                        clearInterval(checkInterval);
                        console.warn('‚ö†Ô∏è PulseApp timeout, proceeding anyway');
                        resolve();
                    }, 5000);
                });
            }
            
            // Helper: Handle bar chart initialization with single render
            async function handleBarChartInitialization() {
                try {
                    console.log('üìä SINGLE bar chart initialization - preventing all redundancy');
                    
                    if (!window.pulseApp || !window.pulseApp.switchChartType) {
                        console.error('‚ùå PulseApp not available');
                        return;
                    }
                    
                    // **FIX FLICKER: Update tab content IMMEDIATELY before chart switch**
                    updateTabContentForBarChart();
                    
                    // Switch to bar chart (will render once internally)
                    await window.pulseApp.switchChartType('bar');
                    
                    // Mark render as completed to prevent additional renders
                    initState.renderCompleted = true;
                    
                    console.log('‚úÖ Bar chart initialized with SINGLE render');
                } catch (error) {
                    console.error('‚ùå Error in bar chart initialization:', error);
                    // Continue anyway to prevent blocking
                }
            }
            
            // Helper: Handle other chart types
            async function handleOtherChartTypes(chartType) {
                console.log(`üîÑ Initializing ${chartType} chart`);
                if (chartType === 'bar') {
                    console.log('üìä Bar chart detected, skipping flow-based initialization');
                    // Bar charts are handled by their own initialization system
                    return;
                } else {
                    // Sankey charts (income, balance, etc.)
                    initializeChartInterface();
                }
            }
            
            // Helper: Set up event listeners only once
            function setupEventListeners() {
                const chartTypeSelect = document.getElementById('chart-type-select');
                if (chartTypeSelect && !chartTypeSelect.hasEventListener) {
                    chartTypeSelect.hasEventListener = true;
                    chartTypeSelect.addEventListener('change', (e) => {
                        const selectedType = e.target.value;
                        console.log(`üìä Manual chart type change: ${selectedType}`);
                        handleChartTypeChange(selectedType);
                    });
                }
            }
            
            // Helper: Update tab content for bar chart (prevent flicker)
            function updateTabContentForBarChart() {
                console.log('üöÄ Updating tab content for bar chart immediately');
                
                // Update tab label immediately
                const dataBuilderTabButton = document.querySelector('.main-tab[onclick*="data-builder"]');
                if (dataBuilderTabButton) {
                    dataBuilderTabButton.innerHTML = 'üìä Bar Data';
                    console.log('üìä Updated tab label to Bar Data (immediate)');
                }
                
                // Update tab content immediately to prevent flicker
                const dataBuilderContent = document.getElementById('data-builder');
                if (dataBuilderContent && !dataBuilderContent.querySelector('.bar-chart-data-builder')) {
                    console.log('üìä Switching data-builder to professional spreadsheet editor (immediate)');
                    dataBuilderContent.innerHTML = `
                        <div class="bar-chart-data-builder">
                            <div id="bar-data-editor-container" style="padding: 20px;">
                                <!-- BarDataEditor will be initialized here -->
                            </div>
                        </div>
                    `;
                    
                    // Initialize professional spreadsheet editor with proper timing
                    setTimeout(() => {
                        if (typeof BarDataEditor !== 'undefined') {
                            // Wait for chart to be fully initialized
                            const waitForChart = () => {
                                if (window.pulseApp && window.pulseApp.chart && window.pulseApp.currentData) {
                                    console.log('üìä Chart is ready, initializing BarDataEditor');
                                    const chartInstance = window.pulseApp.chart;
                                    window.barDataEditor = new BarDataEditor('bar-data-editor-container', chartInstance);
                                    console.log('‚úÖ Professional BarDataEditor initialized with chart sync');
                                } else {
                                    console.log('‚è≥ Waiting for chart to be ready...');
                                    setTimeout(waitForChart, 100);
                                }
                            };
                            waitForChart();
                        } else {
                            console.error('‚ùå BarDataEditor class not available');
                        }
                    }, 200);
                }
            }
            
        })();

        // Modern Export Dropdown Functionality

        // ===== TEMPLATE DOWNLOAD FUNCTIONALITY =====

        function downloadTemplate() {
            if (!selectedChartType) {
                alert('Please select a chart type first by clicking on Income Statement or Balance Sheet.');
                return;
            }
            
            let csv = '';
            let filename = '';
            
            if (selectedChartType === 'income') {
                csv = 'Source,Target,Current Value,Previous Value,Description\n';
                csv += '"Subscription Revenue","Total Revenue",300,250,"Recurring subscription income"\n';
                csv += '"Professional Services","Total Revenue",60,55,"Implementation and consulting"\n';
                csv += '"Total Revenue","Gross Profit",290,245,"Revenue after cost of revenue"\n';
                csv += '"Total Revenue","Cost of Revenue",70,60,"Direct costs to deliver services"\n';
                csv += '"Gross Profit","Operating Profit",120,100,"Profit from core operations"\n';
                csv += '"Gross Profit","Operating Expenses",170,145,"Total operating expenses"\n';
                csv += '"Operating Profit","Net Income",95,80,"Final net income"\n';
                csv += '"Operating Profit","Tax Expense",25,20,"Income tax expense"\n';
                filename = 'income-statement-template.csv';
            } else if (selectedChartType === 'balance') {
                csv = 'Source,Target,Current Value,Previous Value,Description\n';
                csv += '"Current Assets","Total Assets",500,450,"Cash, receivables, inventory"\n';
                csv += '"Non-Current Assets","Total Assets",800,750,"Property, equipment, intangibles"\n';
                csv += '"Total Assets","Current Liabilities",300,280,"Short-term obligations"\n';
                csv += '"Total Assets","Non-Current Liabilities",400,370,"Long-term debt and obligations"\n';
                csv += '"Total Assets","Shareholders Equity",600,550,"Owner\'s equity in the business"\n';
                filename = 'balance-sheet-template.csv';
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // ===== CHART TYPE SELECTOR FUNCTIONALITY =====
        
        function initializeChartTypeSelector() {
            // DISABLED: This function is replaced by IIFE pattern to prevent redundancy
            console.log('‚ö†Ô∏è initializeChartTypeSelector() DISABLED - handled by IIFE');
            return;
            
            const chartTypeSelect = document.getElementById('chart-type-select');
            if (!chartTypeSelect) return;
            
            console.log('üéØ Initializing chart type selector');
            
            // Add event listener for chart type changes
            chartTypeSelect.addEventListener('change', (e) => {
                const selectedType = e.target.value;
                console.log(`üìä Chart type changed to: ${selectedType}`);
                handleChartTypeChange(selectedType);
            });
            
            // Check URL parameters for chart type
            const urlParams = new URLSearchParams(window.location.search);
            const urlChartType = urlParams.get('chartType');
            
            if (urlChartType) {
                console.log(`üîó Chart type from URL: ${urlChartType}`);
                chartTypeSelect.value = urlChartType;
                
                // **CRITICAL FIX: Ensure app is ready before switching chart type**
                if (window.pulseApp && window.pulseApp.isInitialized) {
                    console.log('‚úÖ App is ready, switching chart type immediately');
                    handleChartTypeChange(urlChartType);
                } else {
                    console.log('‚è≥ App not ready, waiting for initialization...');
                    // Wait for app to be ready with more robust checking
                    let attempts = 0;
                    const maxAttempts = 100; // 10 seconds max
                    
                    const waitForApp = setInterval(() => {
                        attempts++;
                        console.log(`‚è≥ Waiting for app... attempt ${attempts}/${maxAttempts}`);
                        
                        if (window.pulseApp && window.pulseApp.isInitialized) {
                            console.log('‚úÖ App is now ready, switching chart type');
                            clearInterval(waitForApp);
                            
                            // **ADDITIONAL FIX: Add small delay to ensure everything is settled**
                            setTimeout(() => {
                                handleChartTypeChange(urlChartType);
                            }, 200);
                        } else if (attempts >= maxAttempts) {
                            console.log('‚ö†Ô∏è App initialization timeout, attempting chart type change anyway');
                            clearInterval(waitForApp);
                            handleChartTypeChange(urlChartType);
                        }
                    }, 100);
                }
            }
        }
        
        function handleChartTypeChange(chartType) {
            console.log(`üîÑ Handling chart type change to: ${chartType}`);
            
            // Update the current chart type
            window.currentChartType = chartType;
            
            if (chartType === 'bar') {
                console.log('üìä Switching to bar chart mode');
                
                // **CRITICAL FIX: Use the app's switchChartType method**
                if (window.pulseApp && window.pulseApp.switchChartType) {
                    console.log('üîÑ Using app.switchChartType for proper control panel switching');
                    window.pulseApp.switchChartType('bar');
                }
                
                // Update tab labels for bar chart  
                const dataBuilderTabButton = document.querySelector('.main-tab[onclick*="data-builder"]');
                if (dataBuilderTabButton) {
                    dataBuilderTabButton.innerHTML = 'üìä Bar Data';
                    console.log('üìä Updated tab label to Bar Data');
                } else {
                    console.error('‚ùå Could not find data-builder tab button');
                }
                
                // Update the data builder content for bar charts (prevent duplicate calls)
                const dataBuilderContent = document.getElementById('data-builder');
                console.log('üìä Found data-builder element:', !!dataBuilderContent);
                
                // PREVENT FLICKERING: Only update if not already bar chart content
                if (dataBuilderContent && !dataBuilderContent.querySelector('.bar-chart-data-builder')) {
                    console.log('üìä Switching data-builder to professional spreadsheet editor');
                    dataBuilderContent.innerHTML = `
                        <div class="bar-chart-data-builder">
                            <div id="bar-data-editor-container" style="padding: 20px;">
                                <!-- BarDataEditor will be initialized here -->
                            </div>
                        </div>
                    `;
                } else {
                    console.log('üìä Bar chart content already loaded, skipping innerHTML update');
                }
                
                // Initialize professional spreadsheet editor with proper timing
                setTimeout(() => {
                    console.log('üìä Initializing professional BarDataEditor');
                    if (typeof BarDataEditor !== 'undefined') {
                        if (!window.barDataEditor) {
                            // Wait for chart to be fully initialized
                            const waitForChart = () => {
                                if (window.pulseApp && window.pulseApp.chart && window.pulseApp.currentData) {
                                    console.log('üìä Chart is ready, initializing BarDataEditor');
                                    const chartInstance = window.pulseApp.chart;
                                    window.barDataEditor = new BarDataEditor('bar-data-editor-container', chartInstance);
                                    console.log('‚úÖ Professional BarDataEditor initialized with chart sync');
                                } else {
                                    console.log('‚è≥ Waiting for chart to be ready...');
                                    setTimeout(waitForChart, 100);
                                }
                            };
                            waitForChart();
                        }
                    } else {
                        console.error('‚ùå BarDataEditor class not available');
                    }
                }, 300);
                
            } else if (chartType === 'sankey') {
                console.log('üåä Switching to sankey chart mode');
                
                // **CRITICAL FIX: Use the app's switchChartType method for consistency**
                if (window.pulseApp && window.pulseApp.switchChartType) {
                    console.log('üîÑ Using app.switchChartType for proper control panel switching');
                    window.pulseApp.switchChartType('sankey');
                }
                
                // Restore original tab label for sankey
                const dataBuilderTabButton = document.querySelector('.tab-button[data-tab="data-builder"]');
                if (dataBuilderTabButton) {
                    dataBuilderTabButton.innerHTML = '<span class="tab-icon">üîó</span> Chart Builder';
                }
                
                // Show flow builder
                const flowBuilderTab = document.querySelector('[data-tab="data-builder"]');
                if (flowBuilderTab) {
                    flowBuilderTab.style.display = 'block';
                }
            }
            
            // Update URL to reflect chart type
            const url = new URL(window.location);
            url.searchParams.set('chartType', chartType);
            window.history.replaceState({}, '', url);
        }
        
        function initializeBarChartMode() {
            console.log('üìä Initializing bar chart mode');
            
            // Check if app is ready and has bar chart support
            if (window.pulseApp && window.pulseApp.chartRegistry && window.pulseApp.chartRegistry.bar) {
                console.log('‚úÖ Bar chart support detected');
                
                // Initialize bar chart type
                window.pulseApp.initializeChartType('bar')
                    .then(() => {
                        console.log('‚úÖ Bar chart initialized successfully');
                    })
                    .catch(error => {
                        console.error('‚ùå Bar chart initialization failed:', error);
                    });
            } else {
                console.warn('‚ö†Ô∏è Bar chart support not available');
            }
        }
        
        function loadBarChartSample() {
            console.log('üìä Loading bar chart sample data');
            
            // Load the sample data
            fetch('data/samples/bar-chart-sample.json')
                .then(response => response.json())
                .then(data => {
                    console.log('‚úÖ Sample bar chart data loaded:', data);
                    
                    // Render the bar chart
                    renderBarChart(data);
                    
                    // Show data preview
                    showBarDataPreview(data);
                    
                    // DISABLED: Auto tab switch - handled by IIFE
                    console.log('‚ö†Ô∏è Auto tab switch DISABLED in renderBarChart');
                    // setTimeout(() => {
                    //     switchMainTab('chart-view');
                    // }, 500);
                })
                .catch(error => {
                    console.error('‚ùå Failed to load bar chart sample:', error);
                    alert('Failed to load bar chart sample data. Please check the console for details.');
                });
        }
        
        function handleBarFileUpload(input) {
            const file = input.files[0];
            if (!file) return;
            
            console.log('üìÅ Processing uploaded file:', file.name);
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    let barData = null;
                    
                    if (file.name.toLowerCase().endsWith('.json')) {
                        const jsonData = JSON.parse(content);
                        barData = convertToBarChartData(jsonData);
                    } else {
                        barData = parseCSVToBarData(content);
                    }
                    
                    console.log('‚úÖ File processed successfully:', barData);
                    
                    // Render the chart
                    renderBarChart(barData);
                    
                    // Show data preview
                    showBarDataPreview(barData);
                    
                    // DISABLED: Auto tab switch - handled by IIFE
                    console.log('‚ö†Ô∏è Auto tab switch DISABLED in renderBarChart');
                    // setTimeout(() => {
                    //     switchMainTab('chart-view');
                    // }, 500);
                    
                } catch (error) {
                    console.error('‚ùå File processing error:', error);
                    alert(`Failed to process "${file.name}": ${error.message}`);
                }
            };
            
            reader.readAsText(file);
        }
        
        function convertToBarChartData(data) {
            // Handle different JSON formats
            if (data.categories && data.values) {
                return data;
            }
            
            if (Array.isArray(data)) {
                const categories = [];
                const values = [];
                
                data.forEach(item => {
                    const category = item.category || item.name || item.label;
                    const value = parseFloat(item.value || item.amount || item.y);
                    
                    if (category && !isNaN(value)) {
                        categories.push(category);
                        values.push(value);
                    }
                });
                
                return {
                    metadata: { chartType: "bar", title: "Bar Chart Data" },
                    categories: categories,
                    values: values,
                    labels: categories
                };
            }
            
            throw new Error('Unrecognized JSON format');
        }
        
        function parseCSVToBarData(content) {
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                throw new Error('CSV must have header and data rows');
            }
            
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const categoryIndex = headers.findIndex(h => h.includes('category') || h.includes('name') || h.includes('label'));
            const valueIndex = headers.findIndex(h => h.includes('value') || h.includes('amount') || h.includes('count'));
            
            if (categoryIndex === -1 || valueIndex === -1) {
                throw new Error('Could not find category and value columns');
            }
            
            const categories = [];
            const values = [];
            
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(',').map(cell => cell.trim());
                if (row.length > Math.max(categoryIndex, valueIndex)) {
                    const category = row[categoryIndex];
                    const value = parseFloat(row[valueIndex]);
                    
                    if (category && !isNaN(value)) {
                        categories.push(category);
                        values.push(value);
                    }
                }
            }
            
            return {
                metadata: { chartType: "bar", title: "Bar Chart Data" },
                categories: categories,
                values: values,
                labels: categories
            };
        }
        
        function renderBarChart(data) {
            console.log('üìä Chart.html renderBarChart - delegating to app');
            
            // **CLEAN: Only use app's updateData method, no fallbacks or conflicts**
            if (window.pulseApp && window.pulseApp.updateData) {
                window.pulseApp.updateData(data, 'chart-html');
                window.currentBarChartData = data;
                console.log('‚úÖ Bar chart data updated via app');
            } else {
                console.error('‚ùå PulseApp not available');
            }
        }
        
        function showBarDataPreview(data) {
            const previewDiv = document.getElementById('bar-data-preview');
            const currentDataDiv = document.getElementById('bar-current-data');
            
            if (previewDiv && currentDataDiv && data) {
                let preview = `Categories: ${data.categories.length} items\n\n`;
                
                data.categories.forEach((category, index) => {
                    preview += `${category}: ${data.values[index]}\n`;
                });
                
                previewDiv.textContent = preview;
                currentDataDiv.style.display = 'block';
            }
        }

        function resetChart() {
            if (confirm('This will reset the chart and return to chart type selection. Continue?')) {
                // Redirect to sankey chart type selector
                window.location.href = 'js/charts/sankey/sankey-type-selector.html';
            }
        }

        function clearAllFlowData() {
            if (confirm('‚ö†Ô∏è This will permanently delete all flow data. Are you sure you want to continue?')) {
                // Clear all flows
                flowData.flows = [];
                
                // Reset metadata to defaults
                flowData.metadata = {
                    title: "Financial Flow Analysis",
                    currency: "USD",
                    unit: "millions",
                    company: "Your Company",
                    period: "Current Period",
                    colorPalette: {
                        revenue: "#3498db",
                        profit: "#27ae60",
                        expense: "#e67e22"
                    }
                };
                
                // Form fields removed - metadata now handled via click-to-edit title
                
                // Re-render the table (which will show empty state)
                renderFlowTable();
                
                // Update statistics
                updateAllStats();
                
                // Clear the chart
                if (window.chart) {
                    try {
                        // Clear chart by rendering empty data
                        const emptyData = generateNodesAndLinksFromFlows();
                        window.chart.render(emptyData);
                    } catch (error) {
                        console.log('Chart cleared due to empty data');
                    }
                }
                
                // Show success notification
                showNotification('‚úÖ All flow data cleared successfully', 'success');
                
                console.log('üóëÔ∏è All flow data cleared');
            }
        }

        function showNotification(message, type = 'info') {
            // Create a notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            // Add styles
            Object.assign(notification.style, {
                position: 'fixed',
                top: '20px',
                right: '20px',
                background: type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6',
                color: 'white',
                padding: '12px 20px',
                borderRadius: '8px',
                fontSize: '14px',
                fontWeight: '500',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
                zIndex: '10000',
                opacity: '0',
                transform: 'translateX(100%)',
                transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
            });
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // Animate out and remove
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // ===== GOOGLE SHEETS-STYLE SPREADSHEET FUNCTIONALITY =====
        class SpreadsheetController {
            constructor() {
                this.selectedCell = null;
                this.selectedCells = new Set(); // For multi-cell selection
                this.selectionStart = null; // Starting cell for range selection
                this.editingCell = null;
                this.copiedCells = new Set(); // For multi-cell copy
                this.isDragging = false;
                this.dragStartCell = null;
                this.dragCurrentCell = null;
                this.initializeSpreadsheet();
            }

            initializeSpreadsheet() {
                // Add event listeners for spreadsheet functionality
                document.addEventListener('click', this.handleCellClick.bind(this));
                document.addEventListener('keydown', this.handleKeyNavigation.bind(this));
                document.addEventListener('dblclick', this.handleCellDoubleClick.bind(this));
                document.addEventListener('paste', this.handlePaste.bind(this));
                
                // Copy/Paste and Drag-to-fill functionality
                document.addEventListener('keydown', this.handleCopyPaste.bind(this));
                document.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
            }

            handleCellClick(event) {
                const cell = event.target.closest('.spreadsheet-cell');
                if (!cell) {
                    this.clearSelection();
                    return;
                }

                // Check if this is a SELECT type cell for immediate editing
                const isSelectCell = cell.dataset.type === 'select';
                const isCategoryCell = cell.dataset.type === 'category';
                
                // For category cells, implement hybrid interaction
                if (isCategoryCell) {
                    if (this.selectedCell === cell && !this.editingCell) {
                        // Second click on already selected cell - show dropdown
                        this.startEditingCategory(cell, 'select');
                    } else if (this.editingCell === cell) {
                        // Cell is already being edited - check if we should toggle to dropdown
                        const textEditor = cell.querySelector('.cell-editor-text');
                        const selectEditor = cell.querySelector('.cell-editor-select');
                        
                        // If currently in text mode, switch to dropdown
                        if (textEditor.style.display === 'block') {
                            this.stopEditingCategory();
                            setTimeout(() => {
                                this.startEditingCategory(cell, 'select');
                            }, 10);
                        }
                    } else {
                        // First click - select cell and activate text input
                        this.selectCell(cell);
                        setTimeout(() => {
                            this.startEditingCategory(cell, 'text');
                        }, 10);
                    }
                } else {
                    this.selectCell(cell);
                    
                    // For SELECT elements, start editing immediately on single click
                    if (isSelectCell) {
                        // Prevent the double-click requirement for dropdowns
                        setTimeout(() => {
                            this.startEditing(cell);
                        }, 10);
                    }
                }
            }

            handleCellDoubleClick(event) {
                const cell = event.target.closest('.spreadsheet-cell');
                if (cell) {
                    if (cell.dataset.type === 'category') {
                        // Double click should show dropdown
                        this.startEditingCategory(cell, 'select');
                    } else {
                        this.startEditing(cell);
                    }
                }
            }

            selectCell(cell) {
                // Clear previous selection
                this.clearSelection();
                
                // Set new selection
                this.selectedCell = cell;
                this.selectedCells.clear();
                this.selectedCells.add(cell);
                this.selectionStart = null; // Reset range selection
                
                cell.classList.add('selected');
                cell.setAttribute('tabindex', '0');
                cell.focus();
            }

            clearSelection() {
                if (this.selectedCell) {
                    this.selectedCell.classList.remove('selected');
                    this.selectedCell.removeAttribute('tabindex');
                }
                
                // Clear multi-selection
                this.selectedCells.forEach(cell => {
                    cell.classList.remove('selected', 'multi-selected');
                });
                
                this.selectedCell = null;
                this.selectedCells.clear();
                this.selectionStart = null;
            }

            startEditingCategory(cell, mode) {
                if (this.editingCell) {
                    this.stopEditing();
                }

                this.editingCell = cell;
                cell.classList.add('editing');
                
                const content = cell.querySelector('.cell-content');
                const textEditor = cell.querySelector('.cell-editor-text');
                const selectEditor = cell.querySelector('.cell-editor-select');
                
                // Get current flow data for this cell
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const currentFlow = flowData.flows[row];
                
                content.style.display = 'none';
                
                if (mode === 'text') {
                    // Use text input with autocomplete
                    textEditor.style.display = 'block';
                    selectEditor.style.display = 'none';
                    textEditor.value = currentFlow[col] || '';
                    textEditor.focus();
                    textEditor.select();
                    
                    // Set up autocomplete
                    this.setupCategoryAutocomplete(textEditor, selectEditor);
                    
                    // Add event listeners for text editor
                    textEditor.addEventListener('blur', () => this.stopEditingCategory());
                    textEditor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                } else {
                    // Use select dropdown
                    selectEditor.style.display = 'block';
                    textEditor.style.display = 'none';
                    selectEditor.value = currentFlow[col] || '';
                    selectEditor.focus();
                    
                    // Add event listeners for select editor
                    selectEditor.addEventListener('blur', () => this.stopEditingCategory());
                    selectEditor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                }
            }

            setupCategoryAutocomplete(textEditor, selectEditor) {
                // Get available options from the select element
                const options = Array.from(selectEditor.options).map(option => option.value).filter(v => v);
                
                textEditor.addEventListener('input', (e) => {
                    const value = e.target.value.toLowerCase();
                    if (value.length > 0) {
                        const matches = options.filter(option => option.toLowerCase().includes(value));
                        if (matches.length > 0) {
                            const exactMatch = matches.find(match => match.toLowerCase() === value);
                            if (exactMatch) {
                                textEditor.style.backgroundColor = '#e8f5e8'; // Light green for exact match
                                textEditor.style.borderColor = '#28a745';
                            } else {
                                textEditor.style.backgroundColor = '#fff3cd'; // Light yellow for partial match
                                textEditor.style.borderColor = '#ffc107';
                            }
                        } else {
                            textEditor.style.backgroundColor = '#f8d7da'; // Light red for no match
                            textEditor.style.borderColor = '#dc3545';
                        }
                    } else {
                        textEditor.style.backgroundColor = 'white';
                        textEditor.style.borderColor = '#ddd';
                    }
                });
                
                // Add Tab key support for autocomplete
                textEditor.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const value = textEditor.value.toLowerCase();
                        if (value.length > 0) {
                            const matches = options.filter(option => option.toLowerCase().includes(value));
                            if (matches.length > 0) {
                                // Auto-complete with first match
                                textEditor.value = matches[0];
                                textEditor.style.backgroundColor = '#e8f5e8';
                                textEditor.style.borderColor = '#28a745';
                                textEditor.select();
                            }
                        }
                    } else if (e.key === 'ArrowDown') {
                        // Switch to dropdown mode on arrow down
                        e.preventDefault();
                        const cell = textEditor.closest('.spreadsheet-cell');
                        this.stopEditingCategory();
                        setTimeout(() => {
                            this.startEditingCategory(cell, 'select');
                        }, 10);
                    }
                });
            }

            startEditingHybrid(cell, mode) {
                if (this.editingCell) {
                    this.stopEditing();
                }

                this.editingCell = cell;
                cell.classList.add('editing');
                
                const content = cell.querySelector('.cell-content');
                const textEditor = cell.querySelector('.cell-editor-text');
                const selectEditor = cell.querySelector('.cell-editor-select');
                
                // Get current flow data for this cell
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const currentFlow = flowData.flows[row];
                
                content.style.display = 'none';
                
                if (mode === 'text') {
                    // Use text input
                    textEditor.style.display = 'block';
                    selectEditor.style.display = 'none';
                    textEditor.value = currentFlow[col] || '';
                    textEditor.focus();
                    textEditor.select();
                    
                    // Add event listeners for text editor
                    textEditor.addEventListener('blur', () => this.stopEditingHybrid(), { once: true });
                    textEditor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                } else {
                    // Use select dropdown
                    selectEditor.style.display = 'block';
                    textEditor.style.display = 'none';
                    selectEditor.value = currentFlow[col] || '';
                    selectEditor.focus();
                    
                    // Add event listeners for select editor
                    selectEditor.addEventListener('blur', () => this.stopEditingHybrid(), { once: true });
                    selectEditor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                }
            }

            startEditing(cell) {
                if (this.editingCell) {
                    this.stopEditing();
                }

                this.editingCell = cell;
                cell.classList.add('editing');
                
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Get current flow data for this cell
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const currentFlow = flowData.flows[row];
                
                // Set editor value from flow data (not display text)
                if (editor.tagName === 'SELECT') {
                    editor.value = currentFlow[col];
                } else {
                    // For number inputs, handle the 0 default value issue
                    if (editor.type === 'number' && (col === 'value' || col === 'previousValue')) {
                        const currentValue = currentFlow[col];
                        // If the value is 0 and it's a previousValue, set empty string
                        if (currentValue === 0 && col === 'previousValue') {
                            editor.value = '';
                        } else {
                            editor.value = currentValue;
                        }
                    } else {
                        editor.value = currentFlow[col];
                    }
                }
                
                // Show editor and hide content
                content.style.display = 'none';
                editor.style.display = 'block';
                editor.focus();
                
                // Select all text for quick editing - now works for number inputs too
                if (editor.tagName !== 'SELECT') {
                    // For number inputs, select all text
                    if (editor.type === 'number') {
                        editor.select();
                    } else {
                        editor.select();
                    }
                }

                // Add event listeners with enhanced cross-browser SELECT element handling
                if (editor.tagName === 'SELECT') {
                    // Cross-browser dropdown fix: Force dropdown to open and stay open
                    const openDropdown = () => {
                        // Force focus first
                        editor.focus();
                        
                        // For WebKit browsers (Safari, Chrome), trigger the dropdown
                        if (editor.showPicker && typeof editor.showPicker === 'function') {
                            try {
                                editor.showPicker();
                            } catch (e) {
                                // Fallback for older browsers
                                editor.click();
                            }
                        } else {
                            // Fallback: simulate click to open dropdown
                            const clickEvent = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                view: window
                            });
                            editor.dispatchEvent(clickEvent);
                        }
                    };
                    
                    // Delay opening to ensure proper rendering
                    setTimeout(openDropdown, 20);
                    
                    // Prevent event bubbling that could close the dropdown
                    editor.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                    });
                    
                    editor.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    
                    // Handle selection change
                    editor.addEventListener('change', () => {
                        this.stopEditing();
                    }, { once: true });
                    
                    editor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                    
                    // Enhanced blur handling for SELECT stability
                    let blurTimeout;
                    let isInteracting = false;
                    
                    editor.addEventListener('mousedown', () => {
                        isInteracting = true;
                        if (blurTimeout) {
                            clearTimeout(blurTimeout);
                            blurTimeout = null;
                        }
                    });
                    
                    editor.addEventListener('mouseup', () => {
                        setTimeout(() => {
                            isInteracting = false;
                        }, 50);
                    });
                    
                    editor.addEventListener('blur', (e) => {
                        if (blurTimeout) clearTimeout(blurTimeout);
                        
                        blurTimeout = setTimeout(() => {
                            if (!isInteracting && document.activeElement !== editor) {
                                this.stopEditing();
                            }
                        }, 300); // Increased delay for better stability
                    }, { once: true });
                    
                    // Restore focus if dropdown was accidentally closed
                    editor.addEventListener('focus', () => {
                        if (blurTimeout) {
                            clearTimeout(blurTimeout);
                            blurTimeout = null;
                        }
                    });
                } else {
                    editor.addEventListener('blur', () => this.stopEditing(), { once: true });
                    editor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                }
            }

            stopEditingCategory() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const textEditor = cell.querySelector('.cell-editor-text');
                const selectEditor = cell.querySelector('.cell-editor-select');
                
                // Get cell data attributes
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                
                let newValue = '';
                
                // Determine which editor is active
                if (textEditor.style.display !== 'none') {
                    newValue = textEditor.value;
                    textEditor.style.backgroundColor = 'white'; // Reset background color
                } else if (selectEditor.style.display !== 'none') {
                    newValue = selectEditor.value;
                }
                
                // Update content display
                content.textContent = newValue;
                content.style.display = 'flex';
                
                // Hide editors
                textEditor.style.display = 'none';
                selectEditor.style.display = 'none';
                
                // Update the flow data
                if (flowData.flows[row] && col) {
                    flowData.flows[row][col] = newValue;
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    
                    // Live update - trigger chart update immediately
                    updateAllStats();
                    refreshChart();
                }
                
                cell.classList.remove('editing');
                this.editingCell = null;
                cell.focus();
            }

            stopEditingHybrid() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const textEditor = cell.querySelector('.cell-editor-text');
                const selectEditor = cell.querySelector('.cell-editor-select');
                
                // Get cell data attributes
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                
                let newValue = '';
                let activeEditor = null;
                
                // Determine which editor is active
                if (textEditor.style.display !== 'none') {
                    activeEditor = textEditor;
                    newValue = textEditor.value;
                } else if (selectEditor.style.display !== 'none') {
                    activeEditor = selectEditor;
                    newValue = selectEditor.value;
                }
                
                // Update content display
                content.textContent = newValue;
                content.style.display = 'flex';
                
                // Hide editors
                textEditor.style.display = 'none';
                selectEditor.style.display = 'none';
                
                // Update the flow data
                if (flowData.flows[row] && col) {
                    flowData.flows[row][col] = newValue;
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    
                    // Live update - trigger chart update immediately
                    updateAllStats();
                    refreshChart();
                }
                
                cell.classList.remove('editing');
                this.editingCell = null;
                cell.focus();
            }

            stopEditing() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Get cell data attributes
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const type = cell.dataset.type;
                
                let newValue = editor.value;
                
                // Update content with editor value and format based on type
                if (editor.tagName === 'SELECT') {
                    const selectedOption = editor.options[editor.selectedIndex];
                    content.textContent = selectedOption.text;
                    newValue = selectedOption.value;
                } else {
                    if (type === 'number') {
                        newValue = parseFloat(editor.value) || 0;
                        // Format numbers with commas for display
                        content.textContent = newValue > 0 ? newValue.toLocaleString() : (newValue === 0 ? '0' : '');
                    } else {
                        content.textContent = editor.value || '';
                    }
                }
                
                // Update the flow data
                if (flowData.flows[row] && col) {
                    flowData.flows[row][col] = newValue;
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    
                    // Live update - trigger chart update immediately
                    updateAllStats();
                    refreshChart();
                    
                    // Update variance display if this was a value change
                    if (col === 'value' || col === 'previousValue') {
                        const varianceCell = cell.closest('tr').querySelector('.variance-cell div');
                        if (varianceCell) {
                            varianceCell.textContent = flowData.flows[row].getVarianceDisplay();
                            // Apply colors immediately after updating variance display
                            const variance = flowData.flows[row].getVariance();
                            varianceCell.className = ''; // Clear existing classes
                            
                            if (variance.trend === 'up') {
                                varianceCell.classList.add('variance-positive');
                                varianceCell.style.color = '#16a34a';
                                varianceCell.style.fontWeight = '700';
                            } else if (variance.trend === 'down') {
                                varianceCell.classList.add('variance-negative');
                                varianceCell.style.color = '#dc2626';
                                varianceCell.style.fontWeight = '700';
                            } else {
                                varianceCell.classList.add('variance-neutral');
                                varianceCell.style.color = '#6b7280';
                                varianceCell.style.fontWeight = '600';
                            }
                        }
                    }
                }
                
                // Hide editor and show content
                editor.style.display = 'none';
                content.style.display = 'flex';
                
                cell.classList.remove('editing');
                this.editingCell = null;
                
                // Return focus to cell
                cell.focus();
            }

            handleEditorKeys(event) {
                switch (event.key) {
                    case 'Enter':
                        event.preventDefault();
                        this.stopEditingCell();
                        // Add small delay to prevent auto-editing next cell
                        setTimeout(() => {
                            this.moveSelection('down');
                        }, 10);
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.cancelEditing();
                        break;
                    case 'Tab':
                        event.preventDefault();
                        this.stopEditingCell();
                        this.moveSelection(event.shiftKey ? 'left' : 'right');
                        break;
                }
            }

            stopEditingCell() {
                if (!this.editingCell) return;
                
                const cell = this.editingCell;
                const cellType = cell.dataset.type;
                
                // Call the appropriate stop editing method based on cell type
                if (cellType === 'category') {
                    this.stopEditingCategory();
                } else if (cellType === 'hybrid') {
                    this.stopEditingHybrid();
                } else {
                    this.stopEditing();
                }
            }

            cancelEditing() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Don't update content, just hide editor
                editor.style.display = 'none';
                content.style.display = 'flex';
                
                cell.classList.remove('editing');
                this.editingCell = null;
                cell.focus();
            }

            handleKeyNavigation(event) {
                if (!this.selectedCell || this.editingCell) {
                    return;
                }

                switch (event.key) {
                    case 'ArrowUp':
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.extendSelection('up');
                        } else {
                            this.moveSelection('up');
                        }
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.extendSelection('down');
                        } else {
                            this.moveSelection('down');
                        }
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.extendSelection('left');
                        } else {
                            this.moveSelection('left');
                        }
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.extendSelection('right');
                        } else {
                            this.moveSelection('right');
                        }
                        break;
                    case 'Enter':
                        event.preventDefault();
                        // Only start editing if user explicitly presses Enter on a selected cell
                        // Don't auto-edit when navigating with Enter from editing mode
                        if (this.selectedCell && !this.editingCell) {
                            if (this.selectedCell.dataset.type === 'category') {
                                this.startEditingCategory(this.selectedCell, 'text');
                            } else {
                                this.startEditing(this.selectedCell);
                            }
                        }
                        break;
                    case 'F2':
                        event.preventDefault();
                        if (this.selectedCell.dataset.type === 'category') {
                            this.startEditingCategory(this.selectedCell, 'text');
                        } else {
                            this.startEditing(this.selectedCell);
                        }
                        break;
                    case 'Delete':
                    case 'Backspace':
                        event.preventDefault();
                        this.clearCellContent();
                        break;
                    case 'Tab':
                        event.preventDefault();
                        this.moveSelection(event.shiftKey ? 'left' : 'right');
                        break;
                    default:
                        // Start editing on alphanumeric key press
                        if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
                            if (this.selectedCell.dataset.type === 'category') {
                                this.startEditingCategory(this.selectedCell, 'text');
                            } else {
                                this.startEditing(this.selectedCell);
                            }
                        }
                        break;
                }
            }

            moveSelection(direction) {
                if (!this.selectedCell) return;

                const currentRow = this.selectedCell.closest('tr');
                const currentCellIndex = Array.from(currentRow.children).indexOf(this.selectedCell);
                let targetCell = null;

                switch (direction) {
                    case 'up':
                        const prevRow = currentRow.previousElementSibling;
                        if (prevRow) {
                            targetCell = prevRow.children[currentCellIndex];
                        }
                        break;
                    case 'down':
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) {
                            targetCell = nextRow.children[currentCellIndex];
                        }
                        break;
                    case 'left':
                        const prevCell = this.selectedCell.previousElementSibling;
                        if (prevCell && prevCell.classList.contains('spreadsheet-cell')) {
                            targetCell = prevCell;
                        }
                        break;
                    case 'right':
                        const nextCell = this.selectedCell.nextElementSibling;
                        if (nextCell && nextCell.classList.contains('spreadsheet-cell')) {
                            targetCell = nextCell;
                        }
                        break;
                }

                if (targetCell && targetCell.classList.contains('spreadsheet-cell')) {
                    this.selectCell(targetCell);
                }
            }

            extendSelection(direction) {
                if (!this.selectedCell) return;

                // Initialize selection range if this is the first extend
                if (!this.selectionStart) {
                    this.selectionStart = this.selectedCell;
                    this.selectedCells.add(this.selectedCell);
                }

                const currentRow = this.selectedCell.closest('tr');
                const currentCellIndex = Array.from(currentRow.children).indexOf(this.selectedCell);
                let targetCell = null;

                switch (direction) {
                    case 'up':
                        const prevRow = currentRow.previousElementSibling;
                        if (prevRow) {
                            targetCell = prevRow.children[currentCellIndex];
                        }
                        break;
                    case 'down':
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) {
                            targetCell = nextRow.children[currentCellIndex];
                        }
                        break;
                    case 'left':
                        const prevCell = this.selectedCell.previousElementSibling;
                        if (prevCell && prevCell.classList.contains('spreadsheet-cell')) {
                            targetCell = prevCell;
                        }
                        break;
                    case 'right':
                        const nextCell = this.selectedCell.nextElementSibling;
                        if (nextCell && nextCell.classList.contains('spreadsheet-cell')) {
                            targetCell = nextCell;
                        }
                        break;
                }

                if (targetCell && targetCell.classList.contains('spreadsheet-cell')) {
                    this.selectedCell = targetCell;
                    this.updateSelectionRange();
                }
            }

            updateSelectionRange() {
                if (!this.selectionStart || !this.selectedCell) return;

                // Clear current selection display
                this.selectedCells.forEach(cell => {
                    cell.classList.remove('selected', 'multi-selected');
                });
                this.selectedCells.clear();

                // Get start and end coordinates
                const startRow = parseInt(this.selectionStart.dataset.row);
                const startCol = this.getCellColumnIndex(this.selectionStart);
                const endRow = parseInt(this.selectedCell.dataset.row);
                const endCol = this.getCellColumnIndex(this.selectedCell);

                // Calculate selection bounds
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                const minCol = Math.min(startCol, endCol);
                const maxCol = Math.max(startCol, endCol);

                // Select all cells in range
                const table = this.selectedCell.closest('table');
                const rows = table.querySelectorAll('tbody tr');
                
                for (let r = minRow; r <= maxRow; r++) {
                    if (rows[r]) {
                        const cells = rows[r].querySelectorAll('.spreadsheet-cell');
                        for (let c = minCol; c <= maxCol; c++) {
                            if (cells[c]) {
                                this.selectedCells.add(cells[c]);
                                cells[c].classList.add('multi-selected');
                            }
                        }
                    }
                }

                // Highlight current active cell
                this.selectedCell.classList.add('selected');
            }

            getCellColumnIndex(cell) {
                if (!cell) return -1;
                
                const row = cell.closest('tr');
                if (!row) return -1;
                
                const cells = row.querySelectorAll('.spreadsheet-cell');
                if (!cells) return -1;
                
                return Array.from(cells).indexOf(cell);
            }

            clearCellContent() {
                if (!this.selectedCell) return;
                
                const content = this.selectedCell.querySelector('.cell-content');
                const row = parseInt(this.selectedCell.dataset.row);
                const col = this.selectedCell.dataset.col;
                const type = this.selectedCell.dataset.type;
                
                // Clear display
                content.textContent = '';
                
                // Clear data based on type
                if (flowData.flows[row] && col) {
                    if (type === 'number') {
                        flowData.flows[row][col] = 0;
                        content.textContent = '0';
                    } else {
                        flowData.flows[row][col] = '';
                    }
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    updateAllStats();
                    debouncedRealTimeUpdate();
                }
            }

            // ===== EXCEL/CSV PASTE FUNCTIONALITY =====
            handlePaste(event) {
                // Only handle paste if we're focused on a spreadsheet cell or the table
                const target = event.target;
                const cell = target.closest('.spreadsheet-cell');
                const table = target.closest('.flow-table');
                
                if (!cell && !table) {
                    return; // Not in our spreadsheet
                }

                event.preventDefault();
                
                // Get clipboard data
                const clipboardData = event.clipboardData || window.clipboardData;
                const pastedText = clipboardData.getData('text');
                
                if (!pastedText) {
                    console.log('üìã No text data in clipboard');
                    return;
                }

                console.log('üìã Processing paste data:', pastedText);
                
                // Determine starting cell
                let startCell = cell || this.selectedCell;
                if (!startCell) {
                    // Find first cell if none selected
                    startCell = document.querySelector('.spreadsheet-cell[data-row="0"][data-col="source"]');
                }
                
                if (!startCell) {
                    console.error('‚ùå No starting cell found for paste operation');
                    return;
                }

                try {
                    this.pasteDataToTable(pastedText, startCell);
                } catch (error) {
                    console.error('‚ùå Paste operation failed:', error);
                    this.showPasteError(error.message);
                }
            }

            pasteDataToTable(pastedText, startCell) {
                // Parse the pasted data (could be CSV, TSV, or simple text)
                const parsedData = this.parseClipboardData(pastedText);
                
                if (parsedData.length === 0) {
                    throw new Error('No valid data found in clipboard');
                }

                console.log('üìä Parsed clipboard data:', parsedData);

                // Get starting position
                const startRow = parseInt(startCell.dataset.row);
                const startCol = startCell.dataset.col;
                
                // Define column mapping for flow data
                const columnMap = {
                    'source': 0,
                    'target': 1, 
                    'value': 2,
                    'previousValue': 3,
                    'description': 4
                };
                
                const columnOrder = ['source', 'target', 'value', 'previousValue', 'description'];
                const startColIndex = columnOrder.indexOf(startCol);
                
                if (startColIndex === -1) {
                    throw new Error(`Invalid starting column: ${startCol}`);
                }

                // Process each row of pasted data
                let rowsProcessed = 0;
                let cellsUpdated = 0;

                for (let i = 0; i < parsedData.length; i++) {
                    const dataRow = parsedData[i];
                    const targetRowIndex = startRow + i;
                    
                    // Ensure we have enough flow rows
                    while (flowData.flows.length <= targetRowIndex) {
                        this.addNewFlowRow();
                    }
                    
                    // Process each column in the data row
                    for (let j = 0; j < dataRow.length; j++) {
                        const targetColIndex = startColIndex + j;
                        
                        if (targetColIndex >= columnOrder.length) {
                            continue; // Skip columns beyond our table
                        }
                        
                        const targetCol = columnOrder[targetColIndex];
                        const cellValue = dataRow[j];
                        
                        if (cellValue !== null && cellValue !== '') {
                            this.updateCellValue(targetRowIndex, targetCol, cellValue);
                            cellsUpdated++;
                        }
                    }
                    rowsProcessed++;
                }

                // Update statistics and chart first
                autoCalculateFlowProperties();
                updateAllStats();
                
                // Force refresh the entire table to show the pasted data
                // Clear any cached state and force a complete re-render
                document.getElementById('flows-tbody').innerHTML = '';
                renderFlowTable();
                
                // Trigger chart update
                debouncedRealTimeUpdate();
                
                // Additional debug: log table state
                console.log(`üîç Table state after paste: ${document.getElementById('flows-tbody').children.length} rows visible`);
                
                // Show success message
                this.showPasteSuccess(rowsProcessed, cellsUpdated);
                
                console.log(`‚úÖ Paste complete: ${rowsProcessed} rows, ${cellsUpdated} cells updated`);
            }

            parseClipboardData(text) {
                // Split into lines and remove empty lines
                const lines = text.split(/\r?\n/).filter(line => line.trim());
                
                if (lines.length === 0) {
                    return [];
                }

                // Detect delimiter (tab, comma, or semicolon)
                const firstLine = lines[0];
                let delimiter = '\t'; // Default to tab (Excel/Google Sheets)
                
                if (firstLine.includes('\t')) {
                    delimiter = '\t';
                } else if (firstLine.includes(',')) {
                    delimiter = ',';
                } else if (firstLine.includes(';')) {
                    delimiter = ';';
                }

                console.log(`üìã Detected delimiter: "${delimiter === '\t' ? 'TAB' : delimiter}"`);

                // Parse each line
                return lines.map(line => {
                    return line.split(delimiter).map(cell => {
                        // Clean up the cell value
                        let value = cell.trim();
                        
                        // Remove quotes if present
                        if ((value.startsWith('"') && value.endsWith('"')) || 
                            (value.startsWith("'") && value.endsWith("'"))) {
                            value = value.slice(1, -1);
                        }
                        
                        // Convert numeric values
                        if (/^\d+\.?\d*$/.test(value)) {
                            return parseFloat(value);
                        }
                        
                        return value;
                    });
                });
            }

            updateCellValue(rowIndex, columnName, value) {
                // Validate the value based on column type
                let processedValue = value;
                
                switch (columnName) {
                    case 'value':
                    case 'previousValue':
                        processedValue = parseFloat(value) || 0;
                        break;
                    default:
                        processedValue = value.toString();
                }
                
                // Update the flow data
                if (flowData.flows[rowIndex]) {
                    flowData.flows[rowIndex][columnName] = processedValue;
                }
            }

            addNewFlowRow() {
                // Add a new empty flow to the data
                const newFlow = new BusinessFlow({
                    id: `flow_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    source: '',
                    target: '',
                    value: 0,
                    flowType: 'revenue_flow',
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceOrder: 1,
                    targetOrder: 1,
                    sourceCategory: 'revenue',
                    targetCategory: 'revenue',
                    description: ''
                });
                
                flowData.flows.push(newFlow);
            }

            showPasteSuccess(rows, cells) {
                const message = `‚úÖ Successfully pasted ${rows} row${rows !== 1 ? 's' : ''} and updated ${cells} cell${cells !== 1 ? 's' : ''}`;
                this.showToast(message, 'success');
            }

            showPasteError(errorMessage) {
                const message = `‚ùå Paste failed: ${errorMessage}`;
                this.showToast(message, 'error');
            }

            showToast(message, type = 'info') {
                // Create a toast notification
                const toast = document.createElement('div');
                toast.className = `paste-toast paste-toast-${type}`;
                toast.textContent = message;
                
                // Add styles
                Object.assign(toast.style, {
                    position: 'fixed',
                    top: '20px',
                    right: '20px',
                    background: type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6',
                    color: 'white',
                    padding: '12px 20px',
                    borderRadius: '8px',
                    fontSize: '14px',
                    fontWeight: '500',
                    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
                    zIndex: '10000',
                    opacity: '0',
                    transform: 'translateX(100%)',
                    transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                });
                
                document.body.appendChild(toast);
                
                // Animate in
                setTimeout(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translateX(0)';
                }, 10);
                
                // Animate out and remove
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            document.body.removeChild(toast);
                        }
                    }, 300);
                }, 3000);
            }

            // ===== GOOGLE SHEETS-LIKE COPY/PASTE FUNCTIONALITY =====
            
            handleCopyPaste(event) {
                // Only handle when focused on spreadsheet
                if (!this.selectedCell) return;
                
                if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
                    event.preventDefault();
                    this.copyCells();
                } else if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
                    event.preventDefault();
                    this.pasteCells();
                }
            }
            
            copyCells() {
                if (this.selectedCells.size === 0) return;
                
                // Clear previous copied cell styling
                this.copiedCells.forEach(cell => {
                    cell.classList.remove('copied');
                });
                this.copiedCells.clear();
                
                // Copy current selection
                this.selectedCells.forEach(cell => {
                    this.copiedCells.add(cell);
                    cell.classList.add('copied');
                });
                
                // Create clipboard content
                const clipboardData = this.createClipboardData();
                navigator.clipboard.writeText(clipboardData).catch(() => {
                    console.log('üìã Cells copied:', this.copiedCells.size);
                });
                
                const count = this.copiedCells.size;
                const message = count === 1 ? 'Cell copied!' : `${count} cells copied!`;
                
                // Remove copied styling after 3 seconds
                setTimeout(() => {
                    this.copiedCells.forEach(cell => {
                        cell.classList.remove('copied');
                    });
                }, 3000);
            }
            
            pasteCells() {
                if (!this.selectedCell || this.copiedCells.size === 0) return;
                
                // Get paste target area
                const pasteStartRow = parseInt(this.selectedCell.dataset.row);
                const pasteStartCol = this.getCellColumnIndex(this.selectedCell);
                
                // Validate starting position
                if (isNaN(pasteStartRow) || pasteStartCol < 0) return;
                
                // Get copied data dimensions
                const copiedArray = Array.from(this.copiedCells);
                const copiedRows = new Set();
                const copiedCols = new Set();
                
                // Filter out invalid cells
                const validCopiedCells = copiedArray.filter(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = this.getCellColumnIndex(cell);
                    if (!isNaN(row) && col >= 0) {
                        copiedRows.add(row);
                        copiedCols.add(col);
                        return true;
                    }
                    return false;
                });
                
                if (validCopiedCells.length === 0) return;
                
                const minCopiedRow = Math.min(...copiedRows);
                const minCopiedCol = Math.min(...copiedCols);
                
                let pastedCount = 0;
                
                // Paste each copied cell with relative offset
                validCopiedCells.forEach((sourceCell, index) => {
                    const sourceRow = parseInt(sourceCell.dataset.row);
                    const sourceCol = this.getCellColumnIndex(sourceCell);
                    
                    // Skip if invalid (extra safety check)
                    if (isNaN(sourceRow) || sourceCol < 0) return;
                    
                    // Calculate relative position
                    const rowOffset = sourceRow - minCopiedRow;
                    const colOffset = sourceCol - minCopiedCol;
                    
                    // Find target cell
                    const targetRow = pasteStartRow + rowOffset;
                    const targetCol = pasteStartCol + colOffset;
                    
                    const targetCell = this.getCellAt(targetRow, targetCol);
                    if (targetCell) {
                        const sourceValue = this.getCellValue(sourceCell);
                        this.setCellValue(targetCell, sourceValue);
                        pastedCount++;
                    }
                });
                
                // Simple chart update after all cells are pasted (no table rebuild needed)
                if (pastedCount > 0) {
                    debouncedRealTimeUpdate();
                }
                
                const message = pastedCount === 1 ? 'Cell pasted!' : `${pastedCount} cells pasted!`;
            }

            createClipboardData() {
                if (this.copiedCells.size === 0) return '';
                
                // Group cells by row
                const cellsByRow = new Map();
                this.copiedCells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    if (!cellsByRow.has(row)) {
                        cellsByRow.set(row, []);
                    }
                    cellsByRow.get(row).push(cell);
                });
                
                // Sort rows and create tab-separated data
                const sortedRows = Array.from(cellsByRow.keys()).sort((a, b) => a - b);
                const clipboardRows = [];
                
                sortedRows.forEach(rowNum => {
                    const rowCells = cellsByRow.get(rowNum);
                    rowCells.sort((a, b) => this.getCellColumnIndex(a) - this.getCellColumnIndex(b));
                    
                    const rowData = rowCells.map(cell => this.getCellValue(cell));
                    clipboardRows.push(rowData.join('\t'));
                });
                
                return clipboardRows.join('\n');
            }

            getCellAt(row, col) {
                if (!this.selectedCell) return null;
                
                const table = this.selectedCell.closest('table');
                if (!table) return null;
                
                const rows = table.querySelectorAll('tbody tr');
                if (!rows || row < 0 || row >= rows.length) return null;
                
                const targetRow = rows[row];
                if (!targetRow) return null;
                
                const cells = targetRow.querySelectorAll('.spreadsheet-cell');
                if (!cells || col < 0 || col >= cells.length) return null;
                
                return cells[col] || null;
            }
            
            getCellValue(cell) {
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const flow = flowData.flows[row];
                
                if (!flow) return '';
                
                return flow[col] || '';
            }
            
            setCellValue(cell, value) {
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const type = cell.dataset.type;
                
                if (!flowData.flows[row]) return;
                
                // Type conversion based on cell type
                let processedValue = value;
                if (type === 'number') {
                    processedValue = parseFloat(value) || 0;
                } else {
                    processedValue = value.toString();
                }
                
                // Update flow data
                flowData.flows[row][col] = processedValue;
                
                // Update display
                const cellContent = cell.querySelector('.cell-content');
                if (cellContent) {
                    if (type === 'number' && processedValue !== 0) {
                        cellContent.textContent = processedValue.toLocaleString();
                    } else {
                        cellContent.textContent = processedValue;
                    }
                }
                
                // Auto-recalculate variance if value or previousValue changed
                if (col === 'value' || col === 'previousValue') {
                    this.updateVarianceForRow(row);
                }
            }
            
            updateVarianceForRow(rowIndex) {
                const flow = flowData.flows[rowIndex];
                if (!flow) return;
                
                // Find the variance cell for this row (more robust selector)
                const table = document.querySelector('#main-flow-table tbody');
                if (!table) return;
                
                const tableRows = table.querySelectorAll('tr');
                const tableRow = tableRows[rowIndex];
                if (!tableRow) return;
                
                const varianceCell = tableRow.querySelector('.variance-cell');
                if (!varianceCell) return;
                
                // Update variance display
                const varianceDiv = varianceCell.querySelector('div');
                if (varianceDiv) {
                    const isEmpty = !flow.source && !flow.target && flow.value === 0;
                    varianceDiv.textContent = isEmpty ? '' : flow.getVarianceDisplay();
                    
                    // Apply variance colors
                    const variance = flow.getVariance();
                    
                    // Clear existing classes
                    varianceDiv.className = '';
                    varianceDiv.style.color = '';
                    varianceDiv.style.fontWeight = '';
                    
                    // Apply color based on variance trend
                    if (variance.trend === 'up') {
                        varianceDiv.style.color = '#16a34a';
                        varianceDiv.style.fontWeight = '700';
                    } else if (variance.trend === 'down') {
                        varianceDiv.style.color = '#dc2626';
                        varianceDiv.style.fontWeight = '700';
                    } else {
                        varianceDiv.style.color = '#6b7280';
                        varianceDiv.style.fontWeight = '600';
                    }
                }
            }
            
            updateFlowData(cell) {
                // Trigger the same updates as cell editing
                autoCalculateFlowProperties();
                updateAllStats();
                
                // Re-render the table to show changes (like normal cell editing does)
                renderFlowTable();
                
                // Trigger chart update
                debouncedRealTimeUpdate();
            }
            
            // ===== DRAG-TO-FILL FUNCTIONALITY =====
            
            handleMouseDown(event) {
                const cell = event.target.closest('.spreadsheet-cell');
                if (!cell || !cell.classList.contains('selected')) return;
                
                // Check if clicking on the drag handle (bottom-right corner)
                const rect = cell.getBoundingClientRect();
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                const handleSize = 6;
                
                const isOnHandle = (
                    mouseX >= rect.right - handleSize - 2 &&
                    mouseX <= rect.right + 2 &&
                    mouseY >= rect.bottom - handleSize - 2 &&
                    mouseY <= rect.bottom + 2
                );
                
                if (isOnHandle) {
                    event.preventDefault();
                    this.startDragFill(cell, event);
                }
            }
            
            startDragFill(cell, event) {
                this.isDragging = true;
                this.dragStartCell = cell;
                this.dragCurrentCell = cell;
                
                document.body.style.cursor = 'crosshair';
                event.preventDefault();
            }
            
            handleMouseMove(event) {
                if (!this.isDragging) return;
                
                const cell = event.target.closest('.spreadsheet-cell');
                if (!cell) return;
                
                // Clear previous fill range
                this.clearFillRange();
                
                this.dragCurrentCell = cell;
                this.highlightFillRange();
            }
            
            handleMouseUp(event) {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                document.body.style.cursor = '';
                
                if (this.dragCurrentCell && this.dragCurrentCell !== this.dragStartCell) {
                    this.performDragFill();
                }
                
                this.clearFillRange();
                this.dragStartCell = null;
                this.dragCurrentCell = null;
            }
            
            highlightFillRange() {
                if (!this.dragStartCell || !this.dragCurrentCell) return;
                
                const startRow = parseInt(this.dragStartCell.dataset.row);
                const startCol = this.dragStartCell.dataset.col;
                const endRow = parseInt(this.dragCurrentCell.dataset.row);
                const endCol = this.dragCurrentCell.dataset.col;
                
                // For now, only support vertical fill (same column)
                if (startCol !== endCol) return;
                
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                
                for (let row = minRow; row <= maxRow; row++) {
                    const targetCell = document.querySelector(`[data-row="${row}"][data-col="${startCol}"]`);
                    if (targetCell) {
                        targetCell.classList.add('fill-range');
                    }
                }
            }
            
            clearFillRange() {
                document.querySelectorAll('.fill-range').forEach(cell => {
                    cell.classList.remove('fill-range');
                });
            }
            
            performDragFill() {
                if (!this.dragStartCell || !this.dragCurrentCell) return;
                
                const startRow = parseInt(this.dragStartCell.dataset.row);
                const startCol = this.dragStartCell.dataset.col;
                const endRow = parseInt(this.dragCurrentCell.dataset.row);
                const endCol = this.dragCurrentCell.dataset.col;
                
                // Only support vertical fill for now
                if (startCol !== endCol) {
                    return;
                }
                
                const sourceValue = this.getCellValue(this.dragStartCell);
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                
                let fillCount = 0;
                for (let row = minRow; row <= maxRow; row++) {
                    if (row === startRow) continue; // Skip source cell
                    
                    const targetCell = document.querySelector(`[data-row="${row}"][data-col="${startCol}"]`);
                    if (targetCell) {
                        // Smart fill: try to detect patterns for numbers
                        let fillValue = sourceValue;
                        if (this.dragStartCell.dataset.type === 'number' && !isNaN(parseFloat(sourceValue))) {
                            // For numbers, we could implement pattern detection
                            // For now, just copy the same value
                            fillValue = sourceValue;
                        }
                        
                        this.setCellValue(targetCell, fillValue);
                        fillCount++;
                    }
                }
                
                if (fillCount > 0) {
                    // Update data after filling
                    autoCalculateFlowProperties();
                    updateAllStats();
                    
                    // Re-render the table to show changes
                    renderFlowTable();
                    
                    // Trigger chart update
                    debouncedRealTimeUpdate();
                }
            }
            
        }

        // ===== UNIFIED DROPDOWN SYSTEM (IIFE PATTERN) =====
        
        (function() {
            'use strict';
            
            let initialized = false;
            
            // Unified dropdown manager
            const DropdownManager = {
                dropdowns: new Map(),
                
                init() {
                    if (initialized) {
                        console.log('üîÑ Dropdown system already initialized, cleaning up...');
                        this.cleanup();
                    }
                    
                    console.log('üéõÔ∏è Initializing unified dropdown system');
                    
                    // Initialize control menu dropdowns (data, style, layout, etc.)
                    this.initializeControlMenus();
                    
                    // Initialize export dropdown (separate system)
                    this.initializeExportDropdown();
                    
                    // Set up global click handler
                    this.setupGlobalEvents();
                    
                    initialized = true;
                    console.log('‚úÖ Unified dropdown system initialized');
                },
                
                initializeControlMenus() {
                    const menuTriggers = document.querySelectorAll('.horizontal-controls-menu .menu-trigger');
                    const menuDropdowns = document.querySelectorAll('.horizontal-controls-menu .menu-dropdown');
                    
                    if (menuTriggers.length === 0) {
                        console.log('‚ö†Ô∏è No control menu triggers found, retrying in 100ms');
                        setTimeout(() => this.init(), 100);
                        return;
                    }
                    
                    menuTriggers.forEach(trigger => {
                        const target = trigger.getAttribute('data-target');
                        const dropdown = document.getElementById(`${target}-dropdown`);
                        const section = trigger.closest('.menu-section');
                        
                        if (!dropdown || !section) {
                            console.warn(`‚ö†Ô∏è Invalid menu structure for target: ${target}`);
                            return;
                        }
                        
                        // Store dropdown info
                        this.dropdowns.set(trigger, {
                            type: 'menu',
                            target,
                            dropdown,
                            section,
                            isOpen: false
                        });
                        
                        // Add click handler
                        trigger.addEventListener('click', (e) => this.handleMenuClick(e, trigger));
                    });
                    
                    console.log(`üìã Initialized ${menuTriggers.length} control menu dropdowns`);
                },
                
                initializeExportDropdown() {
                    const exportTrigger = document.getElementById('export-trigger');
                    const exportMenu = document.getElementById('export-menu');
                    
                    if (!exportTrigger || !exportMenu) {
                        console.log('‚ö†Ô∏è Export dropdown elements not found');
                        return;
                    }
                    
                    // Store export dropdown info
                    this.dropdowns.set(exportTrigger, {
                        type: 'export',
                        target: 'export',
                        dropdown: exportMenu,
                        section: null,
                        isOpen: false
                    });
                    
                    // Add click handler
                    exportTrigger.addEventListener('click', (e) => this.handleExportClick(e, exportTrigger));
                    
                    // Handle export option clicks
                    const exportOptions = exportMenu.querySelectorAll('.export-option');
                    exportOptions.forEach(option => {
                        option.addEventListener('click', (e) => {
                            e.stopPropagation();
                            option.classList.add('loading');
                            setTimeout(() => option.classList.remove('loading'), 2000);
                        });
                    });
                    
                    console.log('üì§ Initialized export dropdown');
                },
                
                handleMenuClick(e, trigger) {
                    e.stopPropagation();
                    
                    const info = this.dropdowns.get(trigger);
                    if (!info) return;
                    
                    const { target, dropdown, section } = info;
                    
                    // Close all other dropdowns
                    this.closeAllExcept(dropdown);
                    
                    // Toggle current dropdown
                    const isOpen = dropdown.classList.contains('active');
                    
                    if (isOpen) {
                        this.closeDropdown(dropdown, section, trigger);
                        info.isOpen = false;
                        console.log(`üéõÔ∏è Closed menu: ${target}`);
                    } else {
                        this.openDropdown(dropdown, section, trigger);
                        info.isOpen = true;
                        console.log(`üéõÔ∏è Opened menu: ${target}`);
                        
                        // Debug content
                        const content = dropdown.querySelector('.dropdown-content');
                        if (content) {
                            console.log(`üìã Content for ${target}:`, content.innerHTML.length > 0 ? 'HAS CONTENT' : 'EMPTY');
                        }
                    }
                },
                
                handleExportClick(e, trigger) {
                    e.stopPropagation();
                    
                    const info = this.dropdowns.get(trigger);
                    if (!info) return;
                    
                    const { dropdown } = info;
                    
                    // Close all other dropdowns
                    this.closeAllExcept(dropdown);
                    
                    // Toggle export dropdown
                    const isOpen = dropdown.classList.contains('active');
                    
                    if (isOpen) {
                        dropdown.classList.remove('active');
                        trigger.classList.remove('active');
                        info.isOpen = false;
                        console.log('üì§ Closed export dropdown');
                    } else {
                        dropdown.classList.add('active');
                        trigger.classList.add('active');
                        info.isOpen = true;
                        console.log('üì§ Opened export dropdown');
                    }
                },
                
                openDropdown(dropdown, section, trigger) {
                    dropdown.classList.add('active');
                    if (section) section.classList.add('open');
                    trigger.classList.add('active');
                    
                    // Calculate position for fixed positioning
                    const triggerRect = trigger.getBoundingClientRect();
                    const dropdownWidth = 320;
                    const offset = 4;
                    
                    // Apply positioning styles
                    dropdown.style.opacity = '1';
                    dropdown.style.visibility = 'visible';
                    dropdown.style.display = 'block';
                    dropdown.style.pointerEvents = 'auto';
                    dropdown.style.zIndex = '2147483647';
                    dropdown.style.position = 'fixed';
                    dropdown.style.top = (triggerRect.bottom + offset) + 'px';
                    dropdown.style.left = triggerRect.left + 'px';
                },
                
                closeDropdown(dropdown, section, trigger) {
                    dropdown.classList.remove('active');
                    if (section) section.classList.remove('open');
                    trigger.classList.remove('active');
                    
                    // Force hide with inline styles
                    dropdown.style.opacity = '0';
                    dropdown.style.visibility = 'hidden';
                    dropdown.style.pointerEvents = 'none';
                },
                
                closeAllExcept(exceptDropdown) {
                    this.dropdowns.forEach((info, trigger) => {
                        if (info.dropdown !== exceptDropdown && info.isOpen) {
                            this.closeDropdown(info.dropdown, info.section, trigger);
                            info.isOpen = false;
                        }
                    });
                },
                
                closeAll() {
                    this.dropdowns.forEach((info, trigger) => {
                        if (info.isOpen) {
                            this.closeDropdown(info.dropdown, info.section, trigger);
                            info.isOpen = false;
                        }
                    });
                },
                
                setupGlobalEvents() {
                    // Close dropdowns when clicking outside
                    document.addEventListener('click', (e) => {
                        const isDropdownClick = e.target.closest('.horizontal-controls-menu, .export-dropdown');
                        if (!isDropdownClick) {
                            this.closeAll();
                        }
                    });
                    
                    // Prevent dropdown close when clicking inside
                    document.addEventListener('click', (e) => {
                        const dropdown = e.target.closest('.menu-dropdown, .export-menu');
                        if (dropdown) {
                            e.stopPropagation();
                        }
                    });
                },
                
                cleanup() {
                    // Remove old event listeners by cloning and replacing nodes
                    this.dropdowns.forEach((info, trigger) => {
                        const newTrigger = trigger.cloneNode(true);
                        trigger.parentNode.replaceChild(newTrigger, trigger);
                    });
                    this.dropdowns.clear();
                    initialized = false;
                }
            };
            
            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => DropdownManager.init());
            } else {
                DropdownManager.init();
            }
            
            // Re-initialize when controls are regenerated
            window.addEventListener('controlsGenerated', () => {
                console.log('üîÑ Re-initializing dropdowns after controls regenerated');
                setTimeout(() => DropdownManager.init(), 50);
            });
            
            // Expose to global scope for debugging
            window.DropdownManager = DropdownManager;
            
        })();

        // Chart Title Editing Functions with Modal
        function findChartTitle() {
            // Try multiple selectors to find the chart title
            const selectors = [
                '#main-chart text.chart-title',
                '#main-chart .chart-title', 
                '#main-chart text[text-anchor="middle"]',
                '#main-chart text[text-anchor="center"]',
                '#main-chart svg text:first-of-type',
                '#main-chart text',
                '#main-chart svg g text'
            ];
            
            for (const selector of selectors) {
                const elements = document.querySelectorAll(selector);
                for (const element of elements) {
                    const text = element.textContent.trim();
                    // Look for titles that contain typical chart title keywords
                    if (text.length > 10 && (
                        text.includes('Statement') || 
                        text.includes('Corp') || 
                        text.includes('Inc') || 
                        text.includes('Q1') || text.includes('Q2') || text.includes('Q3') || text.includes('Q4') ||
                        text.includes('2023') || text.includes('2024') || text.includes('2025') ||
                        text.includes('Income') || text.includes('Balance')
                    )) {
                        return element;
                    }
                }
            }
            
            // Fallback: get the first text element that's reasonably long
            const allTexts = document.querySelectorAll('#main-chart text');
            for (const text of allTexts) {
                if (text.textContent.trim().length > 15) {
                    return text;
                }
            }
            
            return null;
        }

        function makeChartTitleEditable() {
            let chartTitle = findChartTitle();
            
            // If no title exists, create a default clickable title
            if (!chartTitle) {
                chartTitle = createDefaultTitle();
            }
            
            if (chartTitle) {
                // Restore custom title text if it exists
                if (window.customChartTitle && chartTitle.textContent !== window.customChartTitle) {
                    chartTitle.textContent = window.customChartTitle;
                    console.log('üìù Restored custom title:', window.customChartTitle);
                }
                
                // Restore custom title styling if it exists
                if (window.customTitleFontSize) {
                    chartTitle.style.fontSize = window.customTitleFontSize + 'px';
                    chartTitle.setAttribute('font-size', window.customTitleFontSize + 'px');
                }
                if (window.customTitleColor) {
                    chartTitle.style.setProperty('--custom-color', window.customTitleColor);
                    chartTitle.style.fill = window.customTitleColor;
                    chartTitle.setAttribute('fill', window.customTitleColor);
                    chartTitle.setAttribute('data-custom-color', window.customTitleColor);
                }
                
                // Always apply/reapply styling to ensure title remains editable
                chartTitle.setAttribute('data-editable', 'true');
                chartTitle.style.cursor = 'pointer';
                chartTitle.style.transition = 'fill 0.2s ease';
                
                console.log('‚úÖ Chart title made editable:', chartTitle.textContent);
                return true;
            }
            return false;
        }

        function updateCurrencyDisplayLive(newCurrency) {
            // Map currency values to symbols
            const currencySymbols = {
                'USD ($)': '$',
                'EUR (‚Ç¨)': '‚Ç¨',
                'GBP (¬£)': '¬£',
                'JPY (¬•)': '¬•'
            };
            
            const newSymbol = currencySymbols[newCurrency] || '$';
            
            // Update all currency displays on the chart immediately
            const chartContainer = document.querySelector('#main-chart');
            if (chartContainer) {
                // Find all text elements that contain currency symbols
                const textElements = chartContainer.querySelectorAll('text');
                textElements.forEach(element => {
                    const text = element.textContent;
                    // Check if text contains currency symbols
                    if (text && (text.includes('$') || text.includes('‚Ç¨') || text.includes('¬£') || text.includes('¬•'))) {
                        // Replace the currency symbol
                        const newText = text.replace(/[$‚Ç¨¬£¬•]/, newSymbol);
                        element.textContent = newText;
                    }
                });
            }
            
            // Store for persistence
            window.livePreviewCurrency = newCurrency;
            console.log('üí± Live currency preview:', newCurrency, '‚Üí', newSymbol);
        }

        function updateUnitsDisplayLive(newUnits) {
            // Map units to suffixes
            const unitSuffixes = {
                'Millions': 'M',
                'Thousands': 'K', 
                'Billions': 'B',
                'Actual': ''
            };
            
            const newSuffix = unitSuffixes[newUnits] || 'M';
            
            // Update all unit displays on the chart immediately
            const chartContainer = document.querySelector('#main-chart');
            if (chartContainer) {
                const textElements = chartContainer.querySelectorAll('text');
                textElements.forEach(element => {
                    const text = element.textContent;
                    // Check if text contains unit suffixes and currency symbols
                    if (text && (text.includes('K') || text.includes('M') || text.includes('B')) && 
                        (text.includes('$') || text.includes('‚Ç¨') || text.includes('¬£') || text.includes('¬•'))) {
                        // Replace the unit suffix while preserving currency symbol
                        let newText = text.replace(/[KMB](?=\s*$|[^a-zA-Z])/g, newSuffix);
                        if (newSuffix === '' && newText !== text) {
                            // Remove trailing space if no suffix
                            newText = newText.replace(/\s+([‚Ç¨$¬£¬•])/, '$1');
                        }
                        element.textContent = newText;
                    }
                });
            }
            
            // Store for persistence
            window.livePreviewUnits = newUnits;
            console.log('üìä Live units preview:', newUnits, '‚Üí', newSuffix);
        }

        function rgbToHex(rgb) {
            if (!rgb || rgb === 'none') return '#1f2937';
            if (rgb.startsWith('#')) return rgb;
            
            const match = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            return '#1f2937';
        }

        function createDefaultTitle() {
            const chartContainer = document.querySelector('#main-chart svg');
            if (!chartContainer) {
                console.log('‚ùå No SVG container found for title creation');
                return null;
            }

            // Check if title already exists to avoid duplicates
            const existingTitle = chartContainer.querySelector('.chart-header text');
            if (existingTitle) {
                console.log('üìä Using existing title element');
                return existingTitle;
            }

            // Use default values since form fields are removed
            const companyName = 'TechFlow SaaS Corp';
            const period = 'Q3 2025';
            const defaultTitle = `${companyName} ${period} Income Statement`;

            // Get SVG dimensions
            const svgRect = chartContainer.getBoundingClientRect();
            const centerX = svgRect.width / 2 || 600;

            // Create title group
            const headerGroup = d3.select(chartContainer)
                .append('g')
                .attr('class', 'chart-header');

            // Create title text element
            const titleElement = headerGroup.append('text')
                .attr('x', centerX)
                .attr('y', 40)
                .attr('text-anchor', 'middle')
                .attr('font-size', '28px')
                .attr('font-weight', '600')
                .attr('font-family', 'Inter, sans-serif')
                .attr('fill', '#1f2937')
                .attr('class', 'chart-title')
                .text(defaultTitle);

            console.log('üìä Created default clickable title:', defaultTitle);
            return titleElement.node();
        }

        function openTitleEditModal() {
            // Parse current chart title to get existing values
            const chartTitle = findChartTitle();
            let companyName = 'TechFlow SaaS Corp';
            let period = 'Q3 2025';
            let currency = 'USD ($)';
            let statementType = 'Income Statement';
            let units = 'Millions';
            let periodType = 'Q/Q';
            
            // Try to get values from multiple sources
            if (typeof flowData !== 'undefined' && flowData.metadata) {
                companyName = flowData.metadata.company || companyName;
                period = flowData.metadata.period || period;
                currency = flowData.metadata.currency || currency;
                units = flowData.metadata.unit || units;
                periodType = flowData.metadata.periodType || periodType;
                console.log('üìã Reading existing metadata:', {
                    company: flowData.metadata.company,
                    period: flowData.metadata.period,
                    currency: flowData.metadata.currency,
                    unit: flowData.metadata.unit,
                    periodType: flowData.metadata.periodType
                });
            } else {
                console.log('‚ö†Ô∏è No flowData.metadata found, initializing with defaults');
                // Initialize flowData.metadata if it doesn't exist
                if (typeof flowData !== 'undefined') {
                    if (!flowData.metadata) {
                        flowData.metadata = {};
                    }
                    // Set defaults if not already set
                    flowData.metadata.company = flowData.metadata.company || companyName;
                    flowData.metadata.period = flowData.metadata.period || period;
                    flowData.metadata.currency = flowData.metadata.currency || currency;
                    flowData.metadata.unit = flowData.metadata.unit || units;
                    flowData.metadata.periodType = flowData.metadata.periodType || periodType;
                }
            }
            
            // Also check for chart-specific metadata as additional fallback
            const app = window.pulseApp;
            if (app && app.chart && app.chart.data && app.chart.data.metadata) {
                const chartMeta = app.chart.data.metadata;
                currency = chartMeta.currency || currency;
                units = chartMeta.unit || chartMeta.units || units;
                companyName = chartMeta.company || companyName;
                period = chartMeta.period || period;
                periodType = chartMeta.periodType || periodType;
                console.log('üìä Using chart metadata as fallback:', chartMeta);
            }
            
            if (chartTitle && chartTitle.textContent) {
                const titleText = chartTitle.textContent.trim();
                // Try to parse existing title: "Company Period Statement Type"
                if (titleText.includes('Income Statement')) {
                    statementType = 'Income Statement';
                    const parts = titleText.replace(' Income Statement', '').trim().split(' ');
                    if (parts.length >= 2) {
                        period = parts.pop(); // Last part is period
                        companyName = parts.join(' '); // Rest is company name
                    }
                } else if (titleText.includes('Balance Sheet')) {
                    statementType = 'Balance Sheet';
                    const parts = titleText.replace(' Balance Sheet', '').trim().split(' ');
                    if (parts.length >= 2) {
                        period = parts.pop();
                        companyName = parts.join(' ');
                    }
                }
            }
            
            // Get current title styling
            let titleFontSize = 40;
            let titleColor = '#1f2937';
            const currentTitle = findChartTitle();
            if (currentTitle) {
                const computedStyle = window.getComputedStyle(currentTitle);
                titleFontSize = parseInt(computedStyle.fontSize) || 40;
                
                // Get color from multiple sources (SVG text elements use fill attribute)
                let detectedColor = null;
                
                // Check style.fill first (inline styles)
                if (currentTitle.style.fill) {
                    detectedColor = currentTitle.style.fill;
                }
                // Check fill attribute (SVG attribute)
                else if (currentTitle.getAttribute('fill')) {
                    detectedColor = currentTitle.getAttribute('fill');
                }
                // Check data-custom-color attribute
                else if (currentTitle.getAttribute('data-custom-color')) {
                    detectedColor = currentTitle.getAttribute('data-custom-color');
                }
                // Check global custom title color
                else if (window.customTitleColor) {
                    detectedColor = window.customTitleColor;
                }
                // Check computed style color as fallback
                else if (computedStyle.color) {
                    detectedColor = computedStyle.color;
                }
                
                // Convert to hex if we found a color
                if (detectedColor) {
                    titleColor = rgbToHex(detectedColor) || detectedColor;
                }
                
                console.log('üé® Detected title color:', detectedColor, '‚Üí', titleColor);
            }
            
            // Populate modal fields
            const modalCompanyName = document.getElementById('modal-company-name');
            const modalPeriod = document.getElementById('modal-period');
            const modalCurrency = document.getElementById('modal-currency');
            const modalStatementType = document.getElementById('modal-statement-type');
            const modalUnits = document.getElementById('modal-units');
            const modalPeriodType = document.getElementById('modal-period-type');
            const modalTitleFontSize = document.getElementById('modal-title-font-size');
            const modalTitleFontSizeValue = document.getElementById('modal-title-font-size-value');
            const modalTitleColor = document.getElementById('modal-title-color');
            
            // Show the modal first
            document.getElementById('chart-title-modal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            
            // Use setTimeout to ensure modal is rendered before setting values
            setTimeout(() => {
                console.log('üéõÔ∏è Setting modal values:', { companyName, period, currency, statementType, units, periodType, titleFontSize, titleColor });
                
                if (modalCompanyName) modalCompanyName.value = companyName;
                if (modalPeriod) modalPeriod.value = period;
                if (modalCurrency) {
                    // Normalize currency values to match dropdown options
                    const currencyMap = {
                        'USD': 'USD ($)',
                        'EUR': 'EUR (‚Ç¨)',
                        'GBP': 'GBP (¬£)',
                        'JPY': 'JPY (¬•)'
                    };
                    const normalizedCurrency = currencyMap[currency] || currency;
                    modalCurrency.value = normalizedCurrency;
                    console.log('üí∞ Set currency to:', normalizedCurrency, 'actual value:', modalCurrency.value);
                }
                if (modalStatementType) modalStatementType.value = statementType;
                if (modalUnits) {
                    // Normalize units values to match dropdown options
                    const unitsMap = {
                        'millions': 'Millions',
                        'thousands': 'Thousands',
                        'billions': 'Billions',
                        'actual': 'Actual'
                    };
                    const normalizedUnits = unitsMap[units.toLowerCase()] || units;
                    modalUnits.value = normalizedUnits;
                    console.log('üìä Set units to:', normalizedUnits, 'actual value:', modalUnits.value);
                }
                if (modalPeriodType) modalPeriodType.value = periodType;
                if (modalTitleFontSize) {
                    modalTitleFontSize.value = titleFontSize;
                    if (modalTitleFontSizeValue) modalTitleFontSizeValue.textContent = titleFontSize + 'px';
                }
                if (modalTitleColor) modalTitleColor.value = titleColor;
            }, 10);
            
            // Add event listeners for live preview
            if (modalTitleFontSize && modalTitleFontSizeValue) {
                modalTitleFontSize.addEventListener('input', function() {
                    const newSize = this.value + 'px';
                    modalTitleFontSizeValue.textContent = newSize;
                    
                    // Live preview on chart title
                    const liveTitle = findChartTitle();
                    if (liveTitle) {
                        liveTitle.style.fontSize = newSize;
                        liveTitle.setAttribute('font-size', newSize);
                    }
                });
            }
            
            // Add event listener for live color preview
            if (modalTitleColor) {
                modalTitleColor.addEventListener('input', function() {
                    const newColor = this.value;
                    
                    // Live preview on chart title
                    const liveTitle = findChartTitle();
                    if (liveTitle) {
                        liveTitle.style.fill = newColor;
                        liveTitle.setAttribute('fill', newColor);
                        liveTitle.setAttribute('data-custom-color', newColor);
                    }
                });
            }
            
            // Add event listener for live currency preview
            if (modalCurrency) {
                modalCurrency.addEventListener('change', function() {
                    const newCurrency = this.value;
                    updateCurrencyDisplayLive(newCurrency);
                });
            }
            
            // Add event listener for live units preview
            if (modalUnits) {
                modalUnits.addEventListener('change', function() {
                    const newUnits = this.value;
                    updateUnitsDisplayLive(newUnits);
                });
            }
            
            // Store original values for cancel functionality
            window.originalTitleValues = {
                text: chartTitle ? chartTitle.textContent : '',
                fontSize: titleFontSize,
                color: titleColor
            };
            
            // Modal already shown above - just focus on first input
            setTimeout(() => {
                if (modalCompanyName) {
                    modalCompanyName.focus();
                    modalCompanyName.select();
                }
            }, 20);
        }

        function saveTitleEdit() {
            // Get values from modal (with null checks)
            const companyName = document.getElementById('modal-company-name')?.value || 'TechFlow SaaS Corp';
            const period = document.getElementById('modal-period')?.value || 'Q3 2025';
            const currency = document.getElementById('modal-currency')?.value || 'USD ($)';
            const statementType = document.getElementById('modal-statement-type')?.value || 'Income Statement';
            const units = document.getElementById('modal-units')?.value || 'Millions';
            const periodType = document.getElementById('modal-period-type')?.value || 'Q/Q';
            const titleFontSize = document.getElementById('modal-title-font-size')?.value || '40';
            const titleColor = document.getElementById('modal-title-color')?.value || '#1f2937';
            
            // Update global metadata with all values
            if (typeof flowData !== 'undefined' && flowData.metadata) {
                flowData.metadata.company = companyName;
                flowData.metadata.period = period;
                flowData.metadata.currency = currency;
                flowData.metadata.unit = units;
                flowData.metadata.periodType = periodType;
            }
            
            // Create new title
            const newTitle = `${companyName} ${period} ${statementType}`;
            
            // Update chart title (styling already applied via live preview)
            const chartTitle = findChartTitle();
            if (chartTitle) {
                // Store the title and styling for persistence
                window.customChartTitle = newTitle;
                window.customTitleFontSize = titleFontSize;
                window.customTitleColor = titleColor;
                
                // Only update the text content (styling already done by live preview)
                chartTitle.textContent = newTitle;
                
                // Ensure title remains editable
                chartTitle.setAttribute('data-editable', 'true');
                chartTitle.style.cursor = 'pointer';
                
                console.log('Chart title updated to:', newTitle);
                console.log('Title styling updated:', { fontSize: titleFontSize + 'px', color: titleColor });
                console.log('Metadata updated:', { companyName, period, currency, units, periodType });
            }
            
            // No chart re-render needed - all changes are applied live!
            // Just ensure title remains editable
            setTimeout(() => {
                makeChartTitleEditable();
            }, 50);
            
            // Clear original values since we're saving
            delete window.originalTitleValues;
            
            // Close modal
            document.getElementById('chart-title-modal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function cancelTitleEdit() {
            // Restore original title values if they exist
            if (window.originalTitleValues) {
                const chartTitle = findChartTitle();
                if (chartTitle) {
                    chartTitle.textContent = window.originalTitleValues.text;
                    chartTitle.style.fontSize = window.originalTitleValues.fontSize + 'px';
                    chartTitle.style.fill = window.originalTitleValues.color;
                    chartTitle.setAttribute('font-size', window.originalTitleValues.fontSize + 'px');
                    chartTitle.setAttribute('fill', window.originalTitleValues.color);
                    chartTitle.setAttribute('data-custom-color', window.originalTitleValues.color);
                    
                    // Restore global values
                    window.customTitleFontSize = window.originalTitleValues.fontSize;
                    window.customTitleColor = window.originalTitleValues.color;
                }
                delete window.originalTitleValues;
            }
            
            document.getElementById('chart-title-modal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Universal event delegation for chart title editing
        document.addEventListener('click', function(e) {
            // Check if clicked element is a chart title
            if (e.target.closest('#main-chart') && 
                (e.target.tagName === 'text' || e.target.tagName === 'TEXT') &&
                e.target.hasAttribute('data-editable')) {
                e.stopPropagation();
                console.log('Chart title clicked:', e.target.textContent);
                openTitleEditModal();
            }
        });

        // Universal hover effects with better clickability indication
        document.addEventListener('mouseover', function(e) {
            if (e.target.closest('#main-chart') && 
                (e.target.tagName === 'text' || e.target.tagName === 'TEXT') &&
                e.target.hasAttribute('data-editable')) {
                
                // Store original styles
                e.target.setAttribute('data-original-opacity', e.target.style.opacity || '1');
                e.target.setAttribute('data-original-filter', e.target.style.filter || 'none');
                
                // Get current title color for glow effect
                const currentColor = e.target.style.fill || e.target.getAttribute('fill') || e.target.getAttribute('data-custom-color') || window.customTitleColor || '#1f2937';
                
                // Convert color to rgba format for glow effect
                let glowColor = currentColor;
                if (currentColor.startsWith('#')) {
                    // Convert hex to rgba
                    const hex = currentColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    glowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                } else if (currentColor.startsWith('rgb')) {
                    // Convert rgb to rgba with alpha
                    glowColor = currentColor.replace('rgb(', 'rgba(').replace(')', ', 0.6)');
                }
                
                // Apply hover effects: slightly reduce opacity and add glow using current color
                e.target.style.opacity = '0.8';
                e.target.style.filter = `drop-shadow(0 0 4px ${glowColor})`;
                e.target.style.transition = 'opacity 0.2s ease, filter 0.2s ease';
                
                // Add visual cue that it's clickable
                e.target.style.cursor = 'pointer';
            }
        });

        document.addEventListener('mouseout', function(e) {
            if (e.target.closest('#main-chart') && 
                (e.target.tagName === 'text' || e.target.tagName === 'TEXT') &&
                e.target.hasAttribute('data-editable')) {
                
                // Restore original styles
                const originalOpacity = e.target.getAttribute('data-original-opacity') || '1';
                const originalFilter = e.target.getAttribute('data-original-filter') || 'none';
                
                e.target.style.opacity = originalOpacity;
                e.target.style.filter = originalFilter;
            }
        });

        // Initialize chart title editing
        document.addEventListener('DOMContentLoaded', function() {
            let attempts = 0;
            const maxAttempts = 50;
            
            const titleCheckInterval = setInterval(() => {
                attempts++;
                
                if (makeChartTitleEditable() || attempts >= maxAttempts) {
                    clearInterval(titleCheckInterval);
                    if (attempts >= maxAttempts) {
                        console.log('‚ö†Ô∏è Could not find or create chart title after', maxAttempts, 'attempts');
                    }
                }
            }, 500);
            
            // Also try when window loads and when charts are rendered
            window.addEventListener('load', () => {
                setTimeout(makeChartTitleEditable, 1000);
                setTimeout(makeChartTitleEditable, 3000);
            });
            
            // Listen for chart rendering events
            document.addEventListener('chartRendered', () => {
                setTimeout(makeChartTitleEditable, 200);
            });
            
            // Also listen for DOM mutations to catch chart re-renders
            const chartContainer = document.getElementById('main-chart');
            if (chartContainer) {
                const observer = new MutationObserver(() => {
                    // Debounce the re-enable function
                    clearTimeout(window.titleEditableTimeout);
                    window.titleEditableTimeout = setTimeout(() => {
                        makeChartTitleEditable();
                    }, 500);
                });
                
                observer.observe(chartContainer, {
                    childList: true,
                    subtree: true
                });
            }
        });

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('chart-title-modal');
            if (e.target === modal) {
                cancelTitleEdit();
            }
        });


    </script>
</body>
</html>