<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Analytics Platform</title>
    
    <!-- Security: Content Security Policy (meta tag version - some directives require HTTP headers) -->
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; 
                   script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://d3js.org https://cdn.jsdelivr.net; 
                   style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.jsdelivr.net; 
                   font-src 'self' https://fonts.gstatic.com; 
                   img-src 'self' data: blob:; 
                   connect-src 'self' https://fonts.googleapis.com https://fonts.gstatic.com;">
    
    <!-- Note: X-Frame-Options, X-Content-Type-Options, and frame-ancestors CSP directive 
         must be set via HTTP headers, not meta tags. See server configuration below. -->
    
    <!-- External Dependencies with SRI - Note: SRI hashes need to be verified for production -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js" 
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.min.js" 
            crossorigin="anonymous"></script>
    
    <!-- Load Global Chart Config first -->
    <script src="js/utils/GlobalChartConfig.js"></script>
    <!-- Load ChartZoom early to ensure availability -->
    <script src="js/utils/ChartZoom.js"></script>
    <!-- Load ChartColorPicker early to ensure availability -->
    <script src="js/utils/ChartColorPicker.js"></script>
    <!-- Load ChartBrandingUtils early to ensure availability -->
    <script src="js/utils/ChartBrandingUtils.js"></script>
    <!-- Load ChartFlowEditor early to ensure availability -->
    <script src="js/utils/ChartFlowEditor.js"></script>
    <!-- Load Spreadsheet Editors -->
    <script src="js/core/SpreadsheetEditor.js"></script>
    <script src="js/core/SankeySpreadsheetEditor.js"></script>
    <script src="js/core/BarSpreadsheetEditor.js"></script>
    <script src="js/core/UnifiedSpreadsheetEditor.js"></script>
    <!-- Load Chart Library -->
    <script src="js/core/ChartLibrary.js"></script>
    
    <!-- Debug: Check if utilities loaded -->
    <script>
    </script>
    
    <!-- Google Fonts for Title Font Control -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Lato:wght@400;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;500;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Consolidated Application Styles -->
    <link rel="stylesheet" href="css/pulse-analytics.css">
    <link rel="stylesheet" href="css/chart-library.css">
    <style>
        /* Consistent 15px font size across all spreadsheet elements */
        .flow-table td, 
        .flow-table th,
        .spreadsheet-cell,
        .cell-content,
        .variance-indicator {
            font-size: 13px !important;
        }
        
        .flow-table td input,
        .flow-table td select,
        .flow-table td button {
            font-size: 15px !important;
        }
        
        /* Make chart more prominent */
        .chart-panel {
            flex: 1 !important;
        }
        
        /* Enhanced title styling for better color control */
        text[data-editable="true"] {
            transition: fill 0.2s ease !important;
        }
        
        /* Removed: Hover color now handled by JavaScript to use current title color */
        
        /* Prevent color flickering */
        text[data-custom-color] {
            fill: var(--custom-color) !important;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" 
          crossorigin="anonymous" />
    <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"
            crossorigin="anonymous"></script>
    
    <!-- Modern UI Enhancements -->
    <style>
        .modern-action-btn {
            transition: all 0.2s ease !important;
        }
        
        .modern-action-btn:hover {
            transform: translateY(-2px) !important;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2) !important;
            background: rgba(255,255,255,0.3) !important;
        }
        
        .modern-action-btn:active {
            transform: translateY(0) !important;
        }
        
        .featured-card {
            transition: all 0.3s ease !important;
        }
        
        .featured-card:hover {
            transform: scale(1.05) !important;
            box-shadow: 0 25px 50px rgba(102, 126, 234, 0.4) !important;
        }
        
        /* Variance color styling */
        .variance-positive {
            color: #16a34a !important;
            font-weight: 700 !important;
        }
        
        .variance-negative {
            color: #dc2626 !important;
            font-weight: 700 !important;
        }
        
        .variance-neutral {
            color: #6b7280 !important;
            font-weight: 600 !important;
        }
        
        /* Bar chart data input styles */
        .data-input-option:hover {
            border-color: #3498db !important;
            background-color: #f8fafc !important;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="pulse-app">
        <!-- Application Header -->
        <header class="app-header">
            <h1>Pulse Analytics Platform</h1>
            <div class="header-controls">
                <!-- Chart Selector -->
                <div class="chart-selector">
                    <label for="chart-type-select">Chart:</label>
                    <select id="chart-type-select">
                        <option value="sankey">🌊 Sankey Flow</option>
                        <option value="bar">📊 Bar Chart</option>
                    </select>
                </div>
                
                <!-- Export moved to Data controls menu -->
            </div>
        </header>


        <!-- Main Chart Interface -->
        <div id="data-builder" class="active" style="display: block !important; padding: 0; margin: 0;">
            <!-- Horizontal Chart Controls Menu -->
            <div class="horizontal-controls-menu" style="display: block !important; visibility: visible !important;">
                <div class="controls-menu-wrapper">
                    <!-- Menu Sections (Left to Right) -->
                    <div class="menu-section" data-section="data">
                        <button class="menu-trigger" data-target="data">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <line x1="9" y1="9" x2="15" y2="9"/>
                                <line x1="9" y1="13" x2="15" y2="13"/>
                                <line x1="9" y1="17" x2="15" y2="17"/>
                            </svg>
                            <span>Data</span>
                            <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6,9 12,15 18,9"/>
                            </svg>
                        </button>
                        <div class="menu-dropdown" id="data-dropdown">
                            <div id="data-controls" class="dropdown-content">
                                <!-- Data Management Overview -->
                                <div style="background: #f0f9ff; padding: 12px; border-radius: 8px; margin-bottom: 16px; border-left: 4px solid #3b82f6;">
                                    <h4 style="margin: 0 0 8px 0; color: #1e40af; font-size: 14px; font-weight: 600;">💰 Data Management</h4>
                                    <p style="margin: 0; color: #64748b; font-size: 14px;">Manage your financial flow data and chart exports</p>
                                </div>

                                <!-- Flow Actions -->
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                                    <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px; font-weight: 600;">🚀 Flow Actions</h4>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        <button class="btn-small" onclick="applyFlowChanges()" style="background: #22c55e; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            🚀 Apply
                                        </button>
                                        <button class="btn-small" onclick="validateFlows()" style="background: #f59e0b; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            ✅ Validate
                                        </button>
                                        <button class="btn-small" onclick="resetToChartData()" style="background: #ef4444; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            🔄 Reset
                                        </button>
                                    </div>
                                </div>

                                <!-- Export Options -->
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                                    <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px; font-weight: 600;">📤 Export Options</h4>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        <button class="btn-small" onclick="exportFlowsToCSV()" style="background: #06b6d4; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            💾 Export CSV
                                        </button>
                                        <button class="btn-small" onclick="downloadTemplate()" style="background: #8b5cf6; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            📋 Template
                                        </button>
                                        <button class="btn-small" onclick="importFlowsFromCSV()" style="background: #10b981; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            📤 Upload
                                        </button>
                                    </div>
                                </div>

                                <!-- Chart Export -->
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px;">
                                    <h4 style="margin: 0 0 8px 0; color: #374151; font-size: 14px; font-weight: 600;">📊 Chart Export</h4>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        <button class="btn-small" onclick="exportCurrentChart('png')" style="background: #10b981; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            🖼️ PNG
                                        </button>
                                        <button class="btn-small" onclick="exportCurrentChart('svg')" style="background: #3b82f6; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            ⚡ SVG
                                        </button>
                                        <button class="btn-small" onclick="exportCurrentChart('csv')" style="background: #f59e0b; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                            📄 Data CSV
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="menu-section" data-section="style">
                        <button class="menu-trigger" data-target="style">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="3"/>
                                <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
                            </svg>
                            <span>Style</span>
                            <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6,9 12,15 18,9"/>
                            </svg>
                        </button>
                        <div class="menu-dropdown" id="style-dropdown">
                            <div id="style-controls" class="dropdown-content"></div>
                        </div>
                    </div>

                    <div class="menu-section" data-section="layout">
                        <button class="menu-trigger" data-target="layout">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <path d="M3 9h18M9 21V9"/>
                            </svg>
                            <span>Layout</span>
                            <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="name" stroke="currentColor" stroke-width="2">
                                <polyline points="6,9 12,15 18,9"/>
                            </svg>
                        </button>
                        <div class="menu-dropdown" id="layout-dropdown">
                            <div id="layout-controls" class="dropdown-content"></div>
                        </div>
                    </div>


                    <div class="menu-section" data-section="colors">
                        <button class="menu-trigger" data-target="colors">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="13.5" cy="6.5" r=".5"/>
                                <circle cx="17.5" cy="10.5" r=".5"/>
                                <circle cx="8.5" cy="7.5" r=".5"/>
                                <circle cx="6.5" cy="12.5" r=".5"/>
                                <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/>
                            </svg>
                            <span>Colors</span>
                            <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6,9 12,15 18,9"/>
                            </svg>
                        </button>
                        <div class="menu-dropdown" id="colors-dropdown">
                            <div id="colors-controls" class="dropdown-content"></div>
                        </div>
                    </div>

                </div>
            </div>

            <div>
                <!-- Flow Builder actions moved to Chart View menu -->

                <!-- Form fields removed - using click-to-edit chart title instead -->

                <!-- Full Width Layout: Maximized Space Usage -->
                <div class="full-width-layout" style="display: flex; gap: 16px; min-height: 750px; margin: 0; padding: 8px;">
                    
                    <!-- Left Panel: Spreadsheet -->
                    <div class="spreadsheet-panel" style="flex: 0 0 45%; min-width: 600px; position: relative; background: white; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); border: 1px solid rgba(0,0,0,0.05); overflow: visible;">
                        <!-- Business Flows Section -->
                        <div class="section">
                            <div class="section-header" style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-bottom: 1px solid #dee2e6; border-radius: 12px 12px 0 0;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <h3 class="section-title" style="margin: 0; display: flex; align-items: center; gap: 6px;">
                                        <div class="flow-controls-group">
                                            <div class="period-comparison-toggle">
                                                <input type="checkbox" id="comparison-mode-toggle" onchange="toggleComparisonMode()" checked>
                                                <label for="comparison-mode-toggle" title="Shows variance % and trends between periods">📈</label>
                                            </div>
                                            <div class="margin-display-toggle">
                                                <input type="checkbox" id="margin-display-toggle" onchange="toggleMarginDisplay()">
                                                <label for="margin-display-toggle" title="Show margin percentages on chart nodes">💰</label>
                                            </div>
                                            <div class="margin-type-selector" style="display: none;">
                                                <select id="margin-type-select" onchange="updateMarginType()" title="Choose which nodes show margins">
                                                    <option value="profit">Profit Only</option>
                                                    <option value="all">All Nodes</option>
                                                </select>
                                            </div>
                                            <div class="description-toggle">
                                                <input type="checkbox" id="description-column-toggle" onchange="toggleDescriptionColumn()">
                                                <label for="description-column-toggle" title="Show/hide Description column">📝</label>
                                            </div>
                                        </div>
                                    </h3>
                                </div>
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <button class="add-flow-btn" onclick="addFlows()">+ Add Rows</button>
                                    <input type="number" id="rows-to-add" min="1" max="50" value="1" style="width: 40px; padding: 2px 4px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px;">
                                </div>
                            </div>
                            <div class="section-content">
                                <div style="overflow-x: auto; height: 600px; overflow-y: auto;">
                                    <table class="flow-table" id="main-flow-table">
                                        <thead>
                                            <tr>
                                                <th style="width: 30px; display: table-cell;" id="actions-col"></th>
                                                <th style="width: 120px;">From</th>
                                                <th style="width: 120px;">To</th>
                                                <th style="width: 180px; display: none;" id="description-col">Description</th>
                                                <th style="width: 70px; display: table-cell;" id="current-value-col">Current</th>
                                                <th style="width: 70px; display: table-cell;" id="previous-value-col">Previous</th>
                                                <th style="width: 45px; display: table-cell;" id="variance-col">Variance</th>
                                            </tr>
                                        </thead>
                                        <tbody id="flows-tbody">
                                            <!-- Rows will be dynamically generated by renderFlowTable() -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                    
                    <!-- Right Panel: Chart Canvas -->
                    <div class="chart-panel" style="flex: 1; position: relative; background: white; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); border: 1px solid rgba(0,0,0,0.05); height: fit-content;">
                        
                        <!-- Main Chart Container for PulseApplication -->
                        <div id="main-chart" style="width: 100%; height: auto; min-height: 400px; padding: 10px; background: #fafbfc; border-radius: 8px; margin: 3px; overflow: visible;">
                            <!-- Chart will render here -->
                        </div>
                        
                    </div>
                    
                </div>

                <!-- Action buttons moved to header -->
            </div>

        </div>

    </div>

    <!-- Chart Title Edit Modal - Compact & Elegant -->
    <div id="chart-title-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 10000; backdrop-filter: blur(2px);">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 16px; padding: 20px; width: 380px; box-shadow: 0 25px 50px rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.2);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #1f2937; display: flex; align-items: center; gap: 8px;">
                    Edit Chart Info
                </h3>
                <button onclick="cancelTitleEdit()" style="background: none; border: none; font-size: 18px; color: #9ca3af; cursor: pointer; padding: 4px; border-radius: 4px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;">×</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 12px; margin-bottom: 12px;">
                <div>
                    <label style="display: block; font-size: 14px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Company Name</label>
                    <input type="text" id="modal-company-name" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; transition: border-color 0.2s;" onfocus="this.style.borderColor='#3b82f6'" onblur="this.style.borderColor='#e5e7eb'">
                </div>
                <div>
                    <label style="display: block; font-size: 14px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Period</label>
                    <input type="text" id="modal-period" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; transition: border-color 0.2s;" onfocus="this.style.borderColor='#3b82f6'" onblur="this.style.borderColor='#e5e7eb'">
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                <div>
                    <label style="display: block; font-size: 14px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Currency</label>
                    <select id="modal-currency" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; background: white;">
                        <option value="USD ($)" selected>USD ($)</option>
                        <option value="EUR (€)">EUR (€)</option>
                        <option value="GBP (£)">GBP (£)</option>
                        <option value="JPY (¥)">JPY (¥)</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; font-size: 14px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Statement</label>
                    <select id="modal-statement-type" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; background: white;">
                        <option value="Income Statement">Income Statement</option>
                        <option value="Balance Sheet">Balance Sheet</option>
                        <option value="Cash Flow">Cash Flow</option>
                    </select>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                <div>
                    <label style="display: block; font-size: 14px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Units</label>
                    <select id="modal-units" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; background: white;">
                        <option value="Millions" selected>Millions</option>
                        <option value="Thousands">Thousands</option>
                        <option value="Billions">Billions</option>
                        <option value="Actual">Actual</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; font-size: 14px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Period Type</label>
                    <select id="modal-period-type" style="width: 100%; padding: 8px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; background: white;">
                        <option value="Q/Q">Quarter-over-Quarter (Q/Q)</option>
                        <option value="Y/Y">Year-over-Year (Y/Y)</option>
                    </select>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                <div>
                    <label style="display: block; font-size: 14px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Title Font Size</label>
                    <input type="range" id="modal-title-font-size" min="20" max="60" value="40" style="width: 100%;">
                    <div style="text-align: center; font-size: 12px; color: #9ca3af; margin-top: 2px;">
                        <span id="modal-title-font-size-value">40px</span>
                    </div>
                </div>
                <div>
                    <label style="display: block; font-size: 14px; font-weight: 500; color: #6b7280; margin-bottom: 4px;">Title Color</label>
                    <input type="color" id="modal-title-color" value="#1f2937" style="width: 100%; height: 32px; border: 1px solid #e5e7eb; border-radius: 6px; cursor: pointer;">
                </div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 8px;">
                <button onclick="cancelTitleEdit()" style="background: #f3f4f6; color: #6b7280; border: none; padding: 8px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">Cancel</button>
                <button onclick="saveTitleEdit()" style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; border: none; padding: 8px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; font-weight: 500; box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3); transition: all 0.2s;" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(59, 130, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(59, 130, 246, 0.3)'">Save</button>
            </div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" style="display: none;" accept=".json">
    <input type="file" id="csv-file-input" style="display: none;" accept=".csv,.json">

    <!-- Core Scripts -->
    <script src="js/utils/ExportUtils.js"></script>
    <script src="js/utils/ChartBranding.js"></script>
    <script src="js/utils/ChartUtils.js"></script>
    <script src="js/utils/ChartExports.js"></script>
    <script src="js/core/DataManager.js"></script>
    <script src="js/core/ControlPanel.js"></script>
    <!-- Sankey Chart Components -->
    <script src="js/charts/sankey/SankeyChartConfig.js"></script>
    <script src="js/charts/sankey/FinancialDataProcessor.js"></script>
    <script src="js/charts/sankey/SankeyChart.js"></script>
    <script src="js/charts/sankey/CategoryAssignmentModal.js"></script>
    <script src="js/charts/sankey/SankeyControls.js"></script>
    
    <!-- Bar Chart Components -->
    <script src="js/charts/bar/BarChartConfig.js"></script>
    <script src="js/charts/bar/BarChart.js"></script>
    <script src="js/charts/bar/BarControls.js"></script>
    
    <!-- Verify utilities before app loads -->
    <script>
    </script>
    
    <!-- Enhanced app.js -->
    <script src="js/app.js"></script>
    
    <!-- Data Bridge Integration -->
    <script>
        window.PulseDataBridge = {
            currentData: null,
            chartInstance: null,
            isInitialized: false,
            realTimeMode: true,
            appReadyCallbacks: [],
            
            init() {
                this.isInitialized = true;
                
                this.waitForAppReady().then(() => {
                    this.setupEventListeners();
                });
            },
            
            onAppReady(callback) {
                if (window.pulseApp) {
                    callback();
                } else {
                    this.appReadyCallbacks.push(callback);
                }
            },
            
            setData(data, source = 'unknown') {
                this.currentData = data;
                this.notifyDataChanged(source);
            },
            
            getData() {
                if (this.currentData) {
                    return this.currentData;
                }
                
                if (window.pulseApp?.getCurrentData()) {
                    this.currentData = window.pulseApp.getCurrentData();
                    return this.currentData;
                }
                
                if (window.pulseApp?.getCurrentChart()?.data) {
                    this.currentData = window.pulseApp.getCurrentChart().data;
                    return this.currentData;
                }
                
                return null;
            },
            
            setChartInstance(chart) {
                this.chartInstance = chart;
            },
            
            setRealTimeMode(enabled) {
                this.realTimeMode = enabled;
                console.log(`🔄 Real-time mode ${enabled ? 'ENABLED' : 'DISABLED'}`);
                this.updateRealTimeIndicator();
            },
            
            notifyDataChanged(source) {
                
                if (this.chartInstance && this.currentData && source !== 'chart-update') {
                    this.chartInstance.render(this.currentData);
                }
                
                // Flow builder removed - using unified system
                
                if (window.pulseApp && source !== 'app' && source !== 'app-initial') {
                    window.pulseApp.currentData = this.currentData;
                }
                
                window.dispatchEvent(new CustomEvent('pulseDataChanged', {
                    detail: { data: this.currentData, source }
                }));
            },
            
            
            updateRealTimeIndicator() {
                const indicator = document.getElementById('realtime-indicator');
                const button = document.getElementById('realtime-toggle');
                
                if (indicator && button) {
                    if (this.realTimeMode) {
                        indicator.className = 'realtime-indicator live';
                        button.textContent = '⚪ Disable Live Updates';
                        button.className = 'btn btn-secondary';
                    } else {
                        indicator.className = 'realtime-indicator manual';
                        button.textContent = '🔴 Enable Live Updates';
                        button.className = 'btn btn-primary';
                    }
                }
            },
            
            applyImmediateChange(newData) {
                if (this.realTimeMode) {
                    this.setData(newData, 'flow-builder-realtime');
                }
            },
            
            
            setupEventListeners() {
            },
            
            async waitForAppReady() {
                const maxAttempts = 50;
                const checkInterval = 200;
                let attempts = 0;
                
                return new Promise((resolve, reject) => {
                    const checkApp = () => {
                        attempts++;
                        
                        if (window.pulseApp && window.pulseApp.isInitialized) {
                            this.hookIntoApp();
                            
                            this.appReadyCallbacks.forEach(callback => callback());
                            this.appReadyCallbacks = [];
                            
                            resolve();
                            return;
                        }
                        
                        // Also check if app exists but is still initializing
                        if (window.pulseApp && !window.pulseApp.isInitialized) {
                        }
                        
                        if (attempts >= maxAttempts) {
                            console.warn('⚠️ Main app initialization timeout - continuing without full integration');
                            // Try to hook into app anyway if it exists
                            if (window.pulseApp) {
                                this.hookIntoApp();
                            }
                            resolve();
                            return;
                        }
                        
                        setTimeout(checkApp, checkInterval);
                    };
                    
                    checkApp();
                });
            },
            
            hookIntoApp() {
                const app = window.pulseApp;
                if (!app) return;
                
                const originalLoadDataset = app.loadDataset.bind(app);
                app.loadDataset = async function(datasetKey) {
                    const result = await originalLoadDataset(datasetKey);
                    window.PulseDataBridge.setData(result, `dataset-${datasetKey}`);
                    return result;
                };
                
                if (app.chart) {
                    this.setChartInstance(app.chart);
                }
                
                const initialData = app.getCurrentData();
                if (initialData) {
                    this.setData(initialData, 'app-initial');
                }
                
            },
            
        };

        // Initialize Data Bridge after DOM is ready and app.js has loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => window.PulseDataBridge.init(), 100);
            });
        } else {
            setTimeout(() => window.PulseDataBridge.init(), 100);
        }
    </script>
    
    <!-- Flow Builder Implementation -->
    <script>
        let selectedChartType = null; // 'income' or 'balance'
        let isInitialized = false; // Prevent multiple initializations
        // Single page system - no tab switching needed
        let flowData = {
            metadata: {
                title: "Financial Flow",
                currency: "USD",
                unit: "millions",
                company: "Your Company",
                period: "Current Period",
                colorPalette: {} // CRITICAL: Always preserve color palette
            },
            flows: []
        };

        let flowIdCounter = 0;

        // Parse URL parameters to get chart type
        function getURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            return {
                type: urlParams.get('type'), // 'income' or 'balance' (for Sankey)
                chartType: urlParams.get('chartType'), // 'sankey' or 'bar' (main chart type)
                // Single page system - no tab parameter needed
                data: urlParams.get('data') // Encoded JSON data
            };
        }

        // Load JSON data file based on chart type
        async function loadChartTypeData(chartType) {
            try {
                let dataFile = '';
                if (chartType === 'income') {
                    dataFile = 'data/samples/saas-company.json';
                } else if (chartType === 'balance') {
                    dataFile = 'data/samples/medocare.json';
                } else if (chartType === 'bar') {
                    dataFile = 'data/samples/bar-chart-sample.json';
                } else {
                    console.warn('Unknown chart type:', chartType);
                    return null;
                }

                const response = await fetch(dataFile);
                
                if (!response.ok) {
                    throw new Error(`Failed to load ${dataFile}: ${response.status}`);
                }
                
                const data = await response.json();
                return data;
                
            } catch (error) {
                console.error('Error loading chart type data:', error);
                alert(`Error loading sample data: ${error.message}`);
                return null;
            }
        }

        // FIXED: Add missing convertSankeyDataToFlows function
        function convertSankeyDataToFlows(sankeyData) {
            const flows = [];
            
            sankeyData.links.forEach((link, index) => {
                const sourceNode = sankeyData.nodes.find(n => n.id === link.source);
                const targetNode = sankeyData.nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode) {
                    flows.push(new BusinessFlow({
                        source: link.source,
                        target: link.target,
                        value: link.value,
                        previousValue: link.previousValue || 0,
                        flowType: link.type || 'revenue_flow',
                        sourceLayer: sourceNode.depth || 0,
                        targetLayer: targetNode.depth || 1,
                        sourceCategory: sourceNode.category || 'revenue',
                        targetCategory: targetNode.category || 'revenue',
                        description: link.description || targetNode.description || ''
                    }));
                }
            });

            return {
                metadata: {
                    title: sankeyData.metadata?.title || "Financial Flow",
                    currency: sankeyData.metadata?.currency || "USD",
                    unit: sankeyData.metadata?.unit || "millions",
                    company: sankeyData.metadata?.company || "Your Company",
                    period: sankeyData.metadata?.period || "Current Period",
                    comparisonMode: sankeyData.metadata?.comparisonMode || false,
                    // CRITICAL: Preserve the existing color palette
                    colorPalette: sankeyData.metadata?.colorPalette || flowData.metadata?.colorPalette || {}
                },
                flows: flows
            };
        }

        // FIXED: Comparison Mode Toggle with color preservation
        function toggleComparisonMode() {
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            
            // CRITICAL: Store existing colors before any changes
            const existingColors = { ...flowData.metadata.colorPalette };
            
            // Previous Value and Variance columns are now always visible since they're core functionality
            // This function now mainly manages the comparison calculation logic
            
            // Update metadata with comparison mode but preserve colors
            flowData.metadata.comparisonMode = comparisonMode;
            flowData.metadata.colorPalette = existingColors; // CRITICAL: Restore colors
            
            // Re-render table to update variance calculations
            renderFlowTable();
            
            // If in real-time mode, trigger update with color preservation
            if (window.PulseDataBridge.realTimeMode) {
                const sankeyData = generateNodesAndLinksFromFlows();
                // CRITICAL: Ensure colors are preserved in the generated data
                sankeyData.metadata.colorPalette = existingColors;
                debouncedRealTimeUpdate();
            }
            
        }

        // Margin Display Toggle - Uses existing logic from SankeyChart
        function toggleMarginDisplay() {
            const marginToggle = document.getElementById('margin-display-toggle');
            const marginSelector = document.querySelector('.margin-type-selector');
            const showMargin = marginToggle.checked;
            
            // Show/hide margin type selector
            if (showMargin) {
                marginSelector.style.display = 'block';
            } else {
                marginSelector.style.display = 'none';
            }
            
            // Get the current chart instance - try multiple sources
            let chart = null;
            if (window.pulseApp && window.pulseApp.chart && window.pulseApp.chart.updateConfig) {
                chart = window.pulseApp.chart;
            } else if (window.pulseApp && window.pulseApp.chart && window.pulseApp.chart.updateConfig) {
                chart = window.pulseApp.chart;
            }
            
            
            // Update chart configuration through existing config system
            if (chart && chart.updateConfig) {
                chart.updateConfig({
                    showMargin: showMargin,
                    showMarginFor: document.getElementById('margin-type-select').value
                });
            } else {
                console.warn('⚠️ No chart with updateConfig method found');
            }
        }

        function updateMarginType() {
            const marginType = document.getElementById('margin-type-select').value;
            const showMargin = document.getElementById('margin-display-toggle').checked;
            
            // Get the current chart instance - try multiple sources
            let chart = null;
            if (window.pulseApp && window.pulseApp.chart && window.pulseApp.chart.updateConfig) {
                chart = window.pulseApp.chart;
            } else if (window.pulseApp && window.pulseApp.chart && window.pulseApp.chart.updateConfig) {
                chart = window.pulseApp.chart;
            }
            
            if (showMargin && chart && chart.updateConfig) {
                chart.updateConfig({
                    showMarginFor: marginType
                });
            } else {
                console.warn('⚠️ Cannot update margin type - no chart available or margin disabled');
            }
        }

        // Toggle Description column visibility with dynamic chart resizing
        function toggleDescriptionColumn() {
            const descriptionToggle = document.getElementById('description-column-toggle');
            const showDescription = descriptionToggle.checked;
            
            // Preserve current column widths before toggling
            const table = document.getElementById('main-flow-table');
            if (table && window.storedColumnWidths !== undefined) {
                const headers = table.querySelectorAll('thead th');
                headers.forEach((th, index) => {
                    const columnId = th.dataset?.col || `col-${index}`;
                    if (getComputedStyle(th).display !== 'none') {
                        const currentWidth = parseInt(getComputedStyle(th).width);
                        if (currentWidth > 0) {
                            storedColumnWidths[columnId] = currentWidth;
                        }
                    }
                });
            }
            
            // Toggle the header column
            const descriptionHeader = document.getElementById('description-col');
            if (descriptionHeader) {
                descriptionHeader.style.display = showDescription ? 'table-cell' : 'none';
            }
            
            // Toggle all description cells in the table body
            const descriptionCells = document.querySelectorAll('td[data-col="description"]');
            descriptionCells.forEach(cell => {
                cell.style.display = showDescription ? 'table-cell' : 'none';
            });
            
            // Dynamic chart container resizing based on description column visibility
            const spreadsheetPanel = document.querySelector('.spreadsheet-panel');
            if (spreadsheetPanel) {
                if (showDescription) {
                    // Description visible: Use larger spreadsheet space (45%)
                    spreadsheetPanel.style.flex = '0 0 45%';
                    spreadsheetPanel.style.minWidth = '600px';
                } else {
                    // Description hidden: Use smaller spreadsheet space (35%), chart expands to 65%
                    spreadsheetPanel.style.flex = '0 0 35%';
                    spreadsheetPanel.style.minWidth = '480px';
                }
            }
            
            // Trigger chart resize after panel adjustment (without full rerender to preserve node positions)
            setTimeout(() => {
                // Only trigger resize event to adjust chart container size, not full rerender
                window.dispatchEvent(new Event('resize'));
            }, 100);
            
            console.log(`📝 Description column ${showDescription ? 'SHOWN' : 'HIDDEN'} - Chart container ${showDescription ? 'REDUCED' : 'EXPANDED'}`);
            
            // Reinitialize column resizing after description toggle
            setTimeout(() => {
                if (typeof initializeColumnResizing === 'function') {
                    initializeColumnResizing();
                }
            }, 200);
        }

        // Column width storage for preserving widths across visibility changes
        let storedColumnWidths = {};

        // Truly independent column resizing functionality
        function initializeColumnResizing() {
            const table = document.getElementById('main-flow-table');
            if (!table) return;

            // Clear any existing resize state
            if (table.resizeInitialized) {
                console.log('📏 Reinitializing column resizing...');
            }

            // Remove table-layout fixed and use a different approach
            table.style.tableLayout = 'auto';
            table.style.minWidth = 'max-content';

            let isResizing = false;
            let currentColumn = null;
            let columnIndex = -1;
            let startX = 0;
            let startWidth = 0;
            let originalTableWidth = 0;

            // Get all columns and their current widths (preserving hidden column widths)
            function getAllColumnWidths() {
                const headers = table.querySelectorAll('thead th');
                const widths = [];
                headers.forEach((th, index) => {
                    const columnId = th.dataset?.col || `col-${index}`;
                    
                    if (getComputedStyle(th).display !== 'none') {
                        // Column is visible - get current width and store it
                        const currentWidth = parseInt(getComputedStyle(th).width);
                        storedColumnWidths[columnId] = currentWidth;
                        widths.push(currentWidth);
                    } else {
                        // Column is hidden - use previously stored width or default
                        const storedWidth = storedColumnWidths[columnId] || 140; // Default width
                        widths.push(storedWidth);
                    }
                });
                return widths;
            }

            // Set specific widths for all columns (respecting visibility)
            function setAllColumnWidths(widths) {
                const headers = table.querySelectorAll('thead th');
                let totalWidth = 0;
                
                headers.forEach((th, index) => {
                    const width = widths[index];
                    const columnId = th.dataset?.col || `col-${index}`;
                    
                    // Store width for future reference (even for hidden columns)
                    if (width > 0) {
                        storedColumnWidths[columnId] = width;
                    }
                    
                    // Skip hidden columns for actual width setting
                    if (getComputedStyle(th).display === 'none') {
                        return;
                    }
                    
                    th.style.width = width + 'px';
                    th.style.minWidth = width + 'px';
                    th.style.maxWidth = width + 'px';
                    totalWidth += width;
                    
                    // Set width on all cells in this column (only visible ones)
                    const rows = table.querySelectorAll('tbody tr');
                    rows.forEach(row => {
                        const cell = row.children[index];
                        if (cell && getComputedStyle(cell).display !== 'none') {
                            cell.style.width = width + 'px';
                            cell.style.minWidth = width + 'px';
                            cell.style.maxWidth = width + 'px';
                        }
                    });
                });

                // Set total table width to prevent auto-adjustment (only visible columns)
                table.style.width = totalWidth + 'px';
                table.style.minWidth = totalWidth + 'px';
            }

            // Check if a column is visible
            function isColumnVisible(columnIndex) {
                const headers = table.querySelectorAll('thead th');
                if (headers[columnIndex]) {
                    return getComputedStyle(headers[columnIndex]).display !== 'none';
                }
                return false;
            }

            // Initialize with current widths
            const initialWidths = getAllColumnWidths();
            setAllColumnWidths(initialWidths);

            // Add mousedown event to all table headers
            table.addEventListener('mousedown', function(e) {
                const th = e.target.closest('th');
                if (!th) return;

                // Don't allow resizing of hidden columns
                if (getComputedStyle(th).display === 'none') {
                    return;
                }

                // Check if click is on the resize handle (right edge)
                const rect = th.getBoundingClientRect();
                const isOnRightEdge = e.clientX > rect.right - 6;
                
                if (isOnRightEdge) {
                    const thColumnIndex = Array.from(th.parentNode.children).indexOf(th);
                    
                    // Only allow resizing if this column is visible
                    if (!isColumnVisible(thColumnIndex)) {
                        return;
                    }
                    
                    isResizing = true;
                    currentColumn = th;
                    columnIndex = thColumnIndex;
                    startX = e.clientX;
                    startWidth = parseInt(getComputedStyle(th).width);
                    originalTableWidth = parseInt(getComputedStyle(table).width);
                    
                    // Add resizing class for visual feedback
                    th.classList.add('resizing');
                    
                    // Prevent text selection during resize
                    document.body.style.userSelect = 'none';
                    document.body.style.cursor = 'col-resize';
                    
                    e.preventDefault();
                }
            });

            // Handle mouse move for resizing
            document.addEventListener('mousemove', function(e) {
                if (!isResizing || !currentColumn || columnIndex === -1) return;

                // Make sure the column is still visible before proceeding
                if (!isColumnVisible(columnIndex)) {
                    return;
                }

                const diff = e.clientX - startX;
                const newWidth = Math.max(30, startWidth + diff);
                
                // Get current widths of all columns
                const currentWidths = getAllColumnWidths();
                
                // Update only the target column width (only if it's visible)
                if (currentWidths[columnIndex] !== undefined && currentWidths[columnIndex] > 0) {
                    currentWidths[columnIndex] = newWidth;
                    
                    // Apply the new widths (this keeps other columns unchanged)
                    setAllColumnWidths(currentWidths);
                }
            });

            // Handle mouse up to end resizing
            document.addEventListener('mouseup', function() {
                if (isResizing && currentColumn) {
                    currentColumn.classList.remove('resizing');
                    
                    // Finalize the widths
                    const finalWidths = getAllColumnWidths();
                    setAllColumnWidths(finalWidths);
                    
                    currentColumn = null;
                    columnIndex = -1;
                    isResizing = false;
                    
                    // Reset cursor and selection
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });

            // Handle table content changes (new rows)
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' && mutation.target.tagName === 'TBODY') {
                        setTimeout(() => {
                            const currentWidths = getAllColumnWidths();
                            setAllColumnWidths(currentWidths);
                        }, 100);
                    }
                });
            });

            const tbody = table.querySelector('tbody');
            if (tbody) {
                observer.observe(tbody, { childList: true, subtree: true });
            }

            // Mark table as initialized
            table.resizeInitialized = true;
            console.log('📏 Truly independent column resizing initialized');
        }

        // Initialize column resizing when table is ready
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initializeColumnResizing, 500);
        });

        // Flow structure definition
        class BusinessFlow {
            constructor(options = {}) {
                this.id = options.id || `flow_${++flowIdCounter}`;
                this.source = options.source || '';
                this.target = options.target || '';
                this.value = options.value || 0;
                this.previousValue = options.previousValue || 0;
                this.flowType = options.flowType || 'revenue_flow';
                this.sourceLayer = options.sourceLayer || 0;
                this.targetLayer = options.targetLayer || 1;
                this.sourceOrder = options.sourceOrder || 1;
                this.targetOrder = options.targetOrder || 1;
                this.sourceCategory = options.sourceCategory || 'revenue';
                this.targetCategory = options.targetCategory || 'revenue';
                this.description = options.description || '';
            }
            
            // Calculate variance between current and previous period
            getVariance() {
                if (this.previousValue === 0) {
                    return this.value > 0 ? { amount: this.value, percentage: 100, trend: 'new' } : { amount: 0, percentage: 0, trend: 'none' };
                }
                
                const amount = this.value - this.previousValue;
                const percentage = (amount / Math.abs(this.previousValue)) * 100;
                let trend = 'none';
                
                if (percentage > 0.1) trend = 'up';
                else if (percentage < -0.1) trend = 'down';
                
                return { amount, percentage, trend };
            }
            
            // Get formatted variance display
            getVarianceDisplay() {
                const variance = this.getVariance();
                if (variance.trend === 'none') return '→ 0%';
                if (variance.trend === 'new') return ''; // Return empty string for new items (consistent with getGrowthDeclineDisplay)
                
                const symbol = variance.trend === 'up' ? '▲' : '▼';
                const sign = variance.percentage > 0 ? '+' : '';
                return `${symbol} ${sign}${variance.percentage.toFixed(1)}%`;
            }
            
            // Calculate margin percentage (for Income Statement only)
            getMarginPercentage(revenueBase) {
                if (!revenueBase || revenueBase === 0) {
                    return { percentage: 0, display: 'N/A' };
                }
                
                const percentage = (this.value / revenueBase) * 100;
                return {
                    percentage: percentage,
                    display: `${percentage.toFixed(1)}%`
                };
            }
            
            // Get formatted growth/decline display (for both IS and BS)
            getGrowthDeclineDisplay() {
                const variance = this.getVariance();
                if (variance.trend === 'none') return ''; // Return empty string for no change
                if (variance.trend === 'new') return ''; // Return empty string for new items too
                
                const sign = variance.percentage > 0 ? '+' : '';
                const periodIndicator = this.getPeriodIndicator();
                return `${sign}${variance.percentage.toFixed(1)}% ${periodIndicator}`;
            }
            
            // Get period indicator (Y/Y or Q/Q) based on user selection
            getPeriodIndicator() {
                // Use user-selected period type if available
                if (flowData.metadata?.periodType) {
                    return flowData.metadata.periodType;
                }
                
                // Fallback to automatic detection for backward compatibility
                const period = flowData.metadata?.period || '';
                const periodLower = period.toLowerCase();
                
                // Check for quarter indicators
                if (periodLower.includes('q1') || periodLower.includes('q2') || 
                    periodLower.includes('q3') || periodLower.includes('q4') || 
                    periodLower.includes('quarter')) {
                    return 'Q/Q';
                }
                
                // Default to Q/Q for quarterly periods, Y/Y otherwise
                return 'Y/Y';
            }
        }

        // Find revenue base by looking for Total Revenue node (calculated sum)
        function findRevenueBase(flowData) {
            if (!flowData || !flowData.flows) return 0;
            
            // Build a map of nodes and their incoming flows to find the aggregated total
            const nodeInflows = new Map();
            
            flowData.flows.forEach(flow => {
                if (!nodeInflows.has(flow.target)) {
                    nodeInflows.set(flow.target, []);
                }
                nodeInflows.get(flow.target).push({
                    source: flow.source,
                    value: flow.value
                });
            });
            
            // Look for "Total Revenue" node or a node that aggregates multiple revenue sources
            let revenueBase = 0;
            let revenueNodeName = null;
            
            for (const [nodeName, inflows] of nodeInflows) {
                const lowerName = nodeName.toLowerCase();
                
                // Check if this is "Total Revenue" or aggregates multiple revenue sources
                if (lowerName.includes('total') && lowerName.includes('revenue')) {
                    // Calculate the sum of incoming revenue flows
                    const totalIncoming = inflows.reduce((sum, inflow) => sum + inflow.value, 0);
                    revenueBase = totalIncoming;
                    revenueNodeName = nodeName;
                    break;
                } else if (lowerName.includes('revenue') && inflows.length >= 2) {
                    // Revenue node with multiple inputs (likely an aggregation)
                    const revenueInflows = inflows.filter(inflow => {
                        const sourceLower = inflow.source.toLowerCase();
                        return sourceLower.includes('revenue') || 
                               sourceLower.includes('subscription') ||
                               sourceLower.includes('service') ||
                               sourceLower.includes('platform') ||
                               sourceLower.includes('sales');
                    });
                    
                    if (revenueInflows.length >= 2) {
                        const totalIncoming = revenueInflows.reduce((sum, inflow) => sum + inflow.value, 0);
                        if (totalIncoming > revenueBase) {
                            revenueBase = totalIncoming;
                            revenueNodeName = nodeName;
                        }
                    }
                }
            }
            
            // Fallback: if no aggregation found, sum all primary revenue sources
            if (revenueBase === 0) {
                const primarySources = flowData.flows.filter(flow => {
                    const sourceLower = flow.source.toLowerCase();
                    return (sourceLower.includes('revenue') || 
                           sourceLower.includes('') ||
                           sourceLower.includes('service') ||
                           sourceLower.includes('platform')) &&
                           !nodeInflows.has(flow.source); // Primary source (no inputs)
                });
                
                revenueBase = primarySources.reduce((sum, flow) => sum + flow.value, 0);
                revenueNodeName = `Calculated from ${primarySources.length} primary sources`;
            }
            
            return revenueBase;
        }

        // Get percentage of revenue for any node value
        function getRevenuePercentage(nodeValue, revenueBase) {
            if (!revenueBase || revenueBase === 0) return 'N/A';
            
            // If this is the revenue base itself, it's 100%
            if (nodeValue === revenueBase) {
                return '100.0%';
            }
            
            const percentage = (nodeValue / revenueBase) * 100;
            return `${percentage.toFixed(1)}%`;
        }

        // Debounce function for real-time updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedRealTimeUpdate = debounce(() => {
            if (window.PulseDataBridge.realTimeMode) {
                const sankeyData = generateNodesAndLinksFromFlows();
                window.PulseDataBridge.applyImmediateChange(sankeyData);
            }
        }, 500);

        // Collapsible Section Management
        // Collapsible functionality removed - sections now always expanded
        function toggleSection(sectionName) {
            // Function kept for compatibility but does nothing
            console.log('Section collapse functionality has been removed');
        }

        // Toggle function for the compact Business Flows update mode button

        function toggleRealTimeMode() {
            const currentMode = window.PulseDataBridge.realTimeMode;
            const newMode = !currentMode;
            window.PulseDataBridge.setRealTimeMode(newMode);
            
            console.log(`🔄 Real-time mode ${newMode ? 'ENABLED' : 'DISABLED'}`);
        }


        function resetNodeHighlighting() {
            // Reset any chart highlighting effects
            const chart = window.pulseApp?.chart;
            if (chart && typeof chart.highlightNodesByCategory === 'function') {
                chart.highlightNodesByCategory('off');
            }
            
            // Re-initialize category buttons to match current data
            setTimeout(() => initializeCategoryButtons(), 100);
        }

        // Target category cycling functionality
        const targetCategories = ['revenue', 'expense', 'profit']; // Cycle: Revenue → Expense → Profit → Revenue...

        // cycleTargetCategory function moved to SankeyChart.js color picker modal
        // Functionality preserved but relocated to modal interface

        function updateTargetCategoryCell(rowIndex, category) {
            const cell = document.querySelector(`td[data-col="targetCategory"][data-row="${rowIndex}"] .cell-content`);
            if (cell) {
                const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
                cell.textContent = categoryName;
            }
        }

        function updateCategoryButton(button, category) {
            // Category button functionality moved to color picker modal
            // This function is kept for compatibility but no longer needed
            console.log('Category button functionality moved to color picker modal');
        }

        function initializeCategoryButtons() {
            // Category buttons have been moved to the color picker modal
            // This function is kept for compatibility but no longer needed
            console.log('Category buttons are now in the color picker modal');
        }

        function resetAllCategoryButtons() {
            // Category buttons have been moved to the color picker modal
            // This function is kept for compatibility but no longer needed
            console.log('Category buttons are now in the color picker modal');
        }

        function updateFlowProperty(index, property, value) {
            if (flowData.flows[index]) {
                flowData.flows[index][property] = value;
                console.log(`📝 Updated flow ${index} ${property}: ${value}`);
                
                
                // Trigger update in live mode
                debouncedRealTimeUpdate();
            }
        }

        
        // Basic control functions
        function randomizeColors() {
            // Implement color randomization
            if (window.pulseApp.chart && typeof window.pulseApp.chart.randomizeColors === 'function') {
                window.pulseApp.chart.randomizeColors();
            } else {
            }
            showNotification('Colors randomized', 'success');
        }
        
        function refreshChart() {
            
            // Instead of recreating the chart, update it through the Data Bridge
            const sankeyData = generateNodesAndLinksFromFlows();
            window.PulseDataBridge.setData(sankeyData, 'chart-refresh');
            
            // Reset highlighting when chart refreshes
            resetNodeHighlighting();
        }
        
        
        // Toggle chart controls panel
        function toggleChartControls() {
            const panel = document.getElementById('chart-controls-panel');
            const button = document.getElementById('controls-toggle-btn');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                button.innerHTML = '⚙️ Hide Controls';
                button.style.background = '#ef4444';
                
                // Flow builder removed - no controls to refresh
            } else {
                panel.style.display = 'none';
                button.innerHTML = '⚙️ Controls';
                button.style.background = '#6366f1';
            }
        }
        
        
        // Toggle export menu
        function toggleExportMenu() {
            const menu = document.getElementById('export-menu');
            const button = document.getElementById('export-toggle-btn');
            
            if (menu.style.display === 'none') {
                menu.style.display = 'block';
                button.innerHTML = '📷 Export ▲';
            } else {
                menu.style.display = 'none';
                button.innerHTML = '📷 Export ▼';
            }
        }
        
        // Close export menu when clicking outside
        document.addEventListener('click', function(event) {
            const exportDropdown = document.querySelector('.export-dropdown');
            const menu = document.getElementById('export-menu');
            
            if (exportDropdown && !exportDropdown.contains(event.target)) {
                menu.style.display = 'none';
                document.getElementById('export-toggle-btn').innerHTML = '📷 Export ▼';
            }
        });
        
        // Export chart from Flow Builder
        function exportChart(format) {
            console.log(`📷 Exporting chart as ${format}`);
            
            // Close export menu
            document.getElementById('export-menu').style.display = 'none';
            document.getElementById('export-toggle-btn').innerHTML = '📷 Export ▼';
            
            const chartElement = document.getElementById('flow-builder-chart');
            if (!chartElement) {
                showNotification('No chart to export', 'error');
                return;
            }
            
            try {
                if (format === 'png') {
                    if (window.pulseApp.chart && window.pulseApp.chart.exportToPNG) {
                        window.pulseApp.chart.exportToPNG();
                    } else if (window.ChartExports?.exportToPNG) {
                        window.ChartExports.exportToPNG(chartElement, 'flow-chart.png');
                    } else {
                        throw new Error('PNG export not available');
                    }
                } else if (format === 'svg') {
                    if (window.pulseApp.chart && window.pulseApp.chart.exportToSVG) {
                        window.pulseApp.chart.exportToSVG();
                    } else if (window.ChartExports?.exportToSVG) {
                        window.ChartExports.exportToSVG(chartElement, 'flow-chart.svg');
                    } else {
                        throw new Error('SVG export not available');
                    }
                } else if (format === 'csv') {
                    if (window.pulseApp.chart && window.pulseApp.chart.exportDataToCSV) {
                        window.pulseApp.chart.exportDataToCSV();
                    } else {
                        // Export flow data as CSV
                        exportFlowDataToCSV();
                    }
                }
                showNotification(`Chart exported as ${format.toUpperCase()}`, 'success');
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Export failed: ' + error.message, 'error');
            }
        }
        
        // Universal export function that works for both Chart View and Flow Builder
        function exportCurrentChart(format) {
            console.log(`📷 Exporting current chart as ${format}`);
            
            let chartInstance = null;
            
            // Use the main chart instance (flow builder removed)
            if (window.pulseApp && window.pulseApp.chart) {
                chartInstance = window.pulseApp.chart;
            }
            
            if (!chartInstance) {
                showNotification('No chart available for export', 'error');
                return;
            }
            
            try {
                if (format === 'png' && chartInstance.exportToPNG) {
                    chartInstance.exportToPNG();
                } else if (format === 'svg' && chartInstance.exportToSVG) {
                    chartInstance.exportToSVG();
                } else if (format === 'csv' && chartInstance.exportDataToCSV) {
                    chartInstance.exportDataToCSV();
                } else {
                    throw new Error(`${format.toUpperCase()} export not available for this chart`);
                }
                showNotification(`Chart exported as ${format.toUpperCase()}`, 'success');
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Export failed: ' + error.message, 'error');
            }
        }
        
        // Override the main app's chart getter to use Flow Builder chart when appropriate
        function getCurrentChart() {
            // Only return the main chart - Flow Builder chart should be handled separately
            if (window.pulseApp && window.pulseApp.chart) {
                return window.pulseApp.chart;
            }
            return null;
        }
        
        
        // Export flow data to CSV
        function exportFlowDataToCSV() {
            const flows = flowData.flows;
            if (!flows || flows.length === 0) {
                throw new Error('No flow data to export');
            }
            
            // Create CSV content
            const headers = ['Source', 'Target', 'Current Value', 'Previous Value', 'Variance %', 'Description'];
            const csvContent = [
                headers.join(','),
                ...flows.map(flow => [
                    flow.source,
                    flow.target,
                    flow.value,
                    flow.previousValue || 0,
                    flow.getVariance().percentage.toFixed(1),
                    flow.description || ''
                ].map(value => `"${value}"`).join(','))
            ].join('\n');
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'flow-data.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        // Show notification
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 16px;
                border-radius: 6px;
                color: white;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                transition: all 0.3s ease;
                max-width: 300px;
            `;
            
            // Set background color based on type
            switch (type) {
                case 'success':
                    notification.style.background = '#22c55e';
                    break;
                case 'error':
                    notification.style.background = '#ef4444';
                    break;
                case 'warning':
                    notification.style.background = '#f59e0b';
                    break;
                default:
                    notification.style.background = '#6366f1';
            }
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        



        async function initializeChartInterface() {
            if (isInitialized) {
                return;
            }
            
            
            // Get URL parameters once at the beginning
            const urlParams = getURLParameters();
            
            // Handle bar charts separately - they don't use flow data
            if (urlParams.type === 'bar' || urlParams.chartType === 'bar') {
                isInitialized = true;
                return;
            }
            
            
            // Check for existing data first (priority for uploaded/custom data)
            let existingData = null;
            
            if (window.PulseDataBridge && window.PulseDataBridge.currentData) {
                existingData = window.PulseDataBridge.currentData;
            } else if (window.pulseApp && window.pulseApp.getCurrentData()) {
                existingData = window.pulseApp.getCurrentData();
            }
            
            // If we have existing custom data, use it instead of loading sample data
            if (existingData && existingData.nodes && existingData.links) {
                // CRITICAL: Preserve existing colors before conversion
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData = convertSankeyDataToFlows(existingData);
                
                // CRITICAL: Restore colors after conversion
                flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                
                updateMetadataInputs();
                renderFlowTable();
                updateAllStats();
                
                // Single page system - always data-builder
                
                isInitialized = true;
                return;
            }
            
            // Check for URL parameters (only if no existing data)
            
            if (urlParams.type) {
                selectedChartType = urlParams.type;
                
                // Load the appropriate sample data
                const sampleData = await loadChartTypeData(urlParams.type);
                if (sampleData) {
                    // CRITICAL: Preserve existing colors before conversion
                    const existingColors = { ...flowData.metadata.colorPalette };
                    
                    flowData = convertSankeyDataToFlows(sampleData);
                    
                    // CRITICAL: Restore colors after conversion
                    flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                    
                    updateMetadataInputs();
                    renderFlowTable();
                    updateAllStats();
                    
                    // CRITICAL: Update the chart data bridge with the new data
                    const sankeyData = generateNodesAndLinksFromFlows();
                    window.PulseDataBridge.setData(sankeyData, `chart-type-${urlParams.type}`);
                    
                    isInitialized = true;
                    return;
                }
            }
            
            // No URL parameters and no existing data - handle based on chart type
            console.log('⚠️ No data found, checking chart type');
            
            // Check for chart type in URL (either 'type' or 'chartType' parameter)
            const chartType = urlParams.type || urlParams.chartType;
            
            if (!chartType) {
                // No chart type specified, redirect to guided selection
                window.location.href = 'guided.html';
            } else if (chartType === 'bar') {
                // Bar chart - initialize bar chart mode with data input interface
                
                // Ensure DOM is ready before calling handleChartTypeChange
                setTimeout(() => {
                    if (typeof handleChartTypeChange === 'function') {
                        // **CRITICAL FIX: Wait for app to be ready before switching**
                        const waitForAppInit = () => {
                            if (window.pulseApp && window.pulseApp.isInitialized) {
                                handleChartTypeChange('bar');
                            } else {
                                setTimeout(waitForAppInit, 200);
                            }
                        };
                        waitForAppInit();
                    } else {
                        console.error('❌ handleChartTypeChange function not found');
                    }
                }, 100);
                
                isInitialized = true;
            } else {
                // Sankey chart without data - redirect to type selector
                window.location.href = 'js/charts/sankey/sankey-type-selector.html';
            }
        }

        function updateFlowRowData(row, flow, index) {
            // Update row data attributes
            row.dataset.flowIndex = index;
            
            // Check description column visibility state
            const descriptionToggle = document.getElementById('description-column-toggle');
            const showDescription = descriptionToggle ? descriptionToggle.checked : true;
            const descriptionDisplay = showDescription ? 'table-cell' : 'none';
            
            // Update each cell based on column type
            const cells = row.querySelectorAll('td');
            cells.forEach(cell => {
                const cellType = cell.dataset.col || cell.dataset.field; // Support both data-col and data-field
                
                // Find the cell-content div within the cell to preserve structure
                const cellContentDiv = cell.querySelector('.cell-content');
                
                switch (cellType) {
                    case 'source':
                        if (cellContentDiv) {
                            cellContentDiv.textContent = flow.source;
                        } else {
                            cell.textContent = flow.source;
                        }
                        break;
                    case 'target':
                        if (cellContentDiv) {
                            cellContentDiv.textContent = flow.target;
                        } else {
                            cell.textContent = flow.target;
                        }
                        break;
                    case 'value':
                        const isEmpty = !flow.source && !flow.target && flow.value === 0;
                        const valueText = isEmpty ? '' : (flow.value ? flow.value.toLocaleString() : '0');
                        if (cellContentDiv) {
                            cellContentDiv.textContent = valueText;
                        } else {
                            cell.textContent = valueText;
                        }
                        break;
                    case 'previousValue':
                        const prevValueText = flow.previousValue ? flow.previousValue.toLocaleString() : '';
                        if (cellContentDiv) {
                            cellContentDiv.textContent = prevValueText;
                        } else {
                            cell.textContent = prevValueText;
                        }
                        break;
                    case 'description':
                        if (cellContentDiv) {
                            cellContentDiv.textContent = flow.description || '';
                        } else {
                            cell.textContent = flow.description || '';
                        }
                        // Ensure description cell visibility matches current toggle state
                        cell.style.display = descriptionDisplay;
                        break;
                }
            });
            
            // Update category buttons if they exist
            const sourceCategoryBtn = row.querySelector('.source-category-btn');
            const targetCategoryBtn = row.querySelector('.target-category-btn');
            
            if (sourceCategoryBtn) {
                sourceCategoryBtn.textContent = flow.sourceCategory;
                sourceCategoryBtn.dataset.category = flow.sourceCategory;
            }
            
            if (targetCategoryBtn) {
                targetCategoryBtn.textContent = flow.targetCategory;
                targetCategoryBtn.dataset.category = flow.targetCategory;
            }
        }

        function updateTableRowsPreservingStructure() {
            const data = window.PulseDataBridge.getData();
            if (!data) {
                console.warn('⚠️ No chart data available for table update');
                return;
            }
            
            // CRITICAL: Preserve existing colors
            const existingColors = { ...flowData.metadata.colorPalette };
            
            // Convert chart data to flow format
            const updatedFlowData = convertSankeyDataToFlows(data);
            
            // CRITICAL: Restore colors
            updatedFlowData.metadata.colorPalette = { ...existingColors, ...updatedFlowData.metadata.colorPalette };
            
            // Update only the changed data without rebuilding table structure
            const tbody = document.getElementById('flows-tbody');
            const existingRows = tbody.querySelectorAll('tr');
            
            // Update existing rows in-place
            updatedFlowData.flows.forEach((flow, index) => {
                if (existingRows[index]) {
                    // Update existing row data
                    updateFlowRowData(existingRows[index], flow, index);
                } else {
                    // Add new row if needed
                    const newRow = createFlowRow(flow, index);
                    tbody.appendChild(newRow);
                }
            });
            
            // Remove excess rows if new data has fewer flows
            for (let i = updatedFlowData.flows.length; i < existingRows.length; i++) {
                if (existingRows[i]) {
                    existingRows[i].remove();
                }
            }
            
            // Update the global flow data
            flowData = updatedFlowData;
            
            // Update metadata and stats
            updateMetadataInputs();
            updateAllStats();
            
            // Apply styling without rebuilding
            applyVarianceColors();
            setTimeout(() => initializeCategoryButtons(), 50);
        }

        function loadCurrentChartData() {
            const data = window.PulseDataBridge.getData();
            if (data) {
                // CRITICAL: Preserve existing colors
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData = convertSankeyDataToFlows(data);
                
                // CRITICAL: Restore colors
                flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                
                updateMetadataInputs();
                renderFlowTable();
                updateAllStats();
                
            } else {
                alert('❌ No chart data available. Please load a dataset in Chart View first.');
            }
        }

        function loadCompleteTemplate() {
            // CRITICAL: Preserve existing colors
            const existingColors = { ...flowData.metadata.colorPalette };
            
            flowData.metadata.company = "TechFlow Corporation";
            flowData.metadata.title = "TechFlow Financial Flow";
            
            // CRITICAL: Restore colors
            flowData.metadata.colorPalette = existingColors;
            
            flowData.flows = [
                new BusinessFlow({
                    source: "Subscription Revenue",
                    target: "Total Revenue",
                    value: 300,
                    previousValue: 305,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Recurring subscription income"
                }),
                new BusinessFlow({
                    source: "Professional Services",
                    target: "Total Revenue",
                    value: 60,
                    previousValue: 55,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Implementation and consulting"
                }),
                new BusinessFlow({
                    source: "Platform & Other",
                    target: "Total Revenue",
                    value: 135,
                    previousValue: 120,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Platform fees and other revenue"
                }),
                new BusinessFlow({
                    source: "Total Revenue",
                    target: "Gross Profit",
                    value: 340,
                    previousValue: 290,
                    flowType: "profit_flow",
                    sourceLayer: 1,
                    targetLayer: 2,
                    sourceCategory: "revenue",
                    targetCategory: "profit",
                    description: "Revenue after cost of revenue"
                }),
                new BusinessFlow({
                    source: "Total Revenue",
                    target: "Cost of Revenue",
                    value: 55,
                    previousValue: 50,
                    flowType: "expense_flow",
                    sourceLayer: 1,
                    targetLayer: 2,
                    sourceCategory: "revenue",
                    targetCategory: "expense",
                    description: "Direct costs to deliver services"
                }),
                new BusinessFlow({
                    source: "Gross Profit",
                    target: "Operating Profit",
                    value: 65,
                    previousValue: 55,
                    flowType: "profit_flow",
                    sourceLayer: 2,
                    targetLayer: 3,
                    sourceCategory: "profit",
                    targetCategory: "profit",
                    description: "Profit from core operations"
                }),
                new BusinessFlow({
                    source: "Gross Profit",
                    target: "Operating Expenses",
                    value: 155,
                    previousValue: 140,
                    flowType: "expense_flow",
                    sourceLayer: 2,
                    targetLayer: 3,
                    sourceCategory: "profit",
                    targetCategory: "expense",
                    description: "Total operating expenses"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "Sales & Marketing",
                    value: 85,
                    previousValue: 75,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "Customer acquisition expenses"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "R&D",
                    value: 45,
                    previousValue: 40,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "Research and development"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "G&A",
                    value: 20,
                    previousValue: 18,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "General and administrative"
                }),
                new BusinessFlow({
                    source: "Operating Profit",
                    target: "Net Income",
                    value: 50,
                    previousValue: 42,
                    flowType: "profit",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "profit",
                    targetCategory: "profit",
                    description: "Final net income"
                }),
                new BusinessFlow({
                    source: "Operating Profit",
                    target: "Tax Expense",
                    value: 12,
                    previousValue: 10,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "profit",
                    targetCategory: "expense",
                    description: "Income tax expense"
                })
            ];
            
            // Form field removed - metadata now handled via click-to-edit title
            renderFlowTable();
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        function loadBlankFlows() {
            if (confirm('This will clear all current flows. Continue?')) {
                // CRITICAL: Preserve existing colors
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData.flows = [
                    new BusinessFlow({
                        source: "Revenue Source",
                        target: "Total Revenue",
                        value: 100,
                        previousValue: 0,
                        description: "Start building your flow here"
                    })
                ];
                
                // CRITICAL: Restore colors
                flowData.metadata.colorPalette = existingColors;
                
                renderFlowTable();
                updateAllStats();
                debouncedRealTimeUpdate();
            }
        }

        function resetToChartData() {
            loadCurrentChartData();
        }

        // Node highlighting functionality
        let highlightState = 'off'; // 'off', 'profit', 'revenue', 'expense'
        const highlightStates = ['off', 'profit', 'revenue', 'expense'];

        function toggleNodeHighlighting() {
            console.log('💡 Toggling node highlighting...');
            
            // Cycle through highlight states
            const currentIndex = highlightStates.indexOf(highlightState);
            const nextIndex = (currentIndex + 1) % highlightStates.length;
            highlightState = highlightStates[nextIndex];
            
            // Update button text and color
            const button = document.getElementById('highlight-toggle-btn');
            if (button) {
                if (highlightState === 'off') {
                    button.innerHTML = '💡 Highlight: Off';
                    button.style.background = '#6366f1';
                } else {
                    button.innerHTML = `💡 Highlight: ${highlightState.charAt(0).toUpperCase() + highlightState.slice(1)}`;
                    // Set color based on category
                    if (highlightState === 'profit') {
                        button.style.background = '#059669'; // Green
                    } else if (highlightState === 'revenue') {
                        button.style.background = '#1e40af'; // Blue
                    } else if (highlightState === 'expense') {
                        button.style.background = '#dc2626'; // Red
                    }
                }
            }
            
            // Apply highlighting to chart
            applyNodeHighlighting();
        }

        function applyNodeHighlighting() {
            
            // Get current chart instance
            let chart = null;
            if (window.pulseApp.chart) {
                chart = window.pulseApp.chart;
            } else if (window.pulseApp && window.pulseApp.chart) {
                chart = window.pulseApp.chart;
            }
            
            if (!chart) {
                console.warn('⚠️ No chart instance found for highlighting');
                return;
            }
            
            // Use the chart's built-in highlighting method if available
            if (typeof chart.highlightNodesByCategory === 'function') {
                chart.highlightNodesByCategory(highlightState);
                return;
            }
            
            // Fallback to direct DOM manipulation
            if (highlightState === 'off') {
                // Reset all nodes to normal opacity
                chart.chart.selectAll('.sankey-node rect')
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', chart.config.nodeOpacity)
                    .style('stroke-width', '2px')
                    .style('stroke', 'white');
                
                // Reset all links to normal opacity
                chart.chart.selectAll('.sankey-link path')
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', chart.config.linkOpacity);
                    
                // Reset all labels to normal opacity
                chart.chart.selectAll('.node-text-group')
                    .transition()
                    .duration(300)
                    .style('opacity', 1);
            } else {
                // Dim all nodes first
                chart.chart.selectAll('.sankey-node rect')
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', 0.2)
                    .style('stroke-width', '1px')
                    .style('stroke', '#e5e7eb');
                
                // Dim all links
                chart.chart.selectAll('.sankey-link path')
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', 0.1);
                    
                // Dim all labels
                chart.chart.selectAll('.node-text-group')
                    .transition()
                    .duration(300)
                    .style('opacity', 0.3);
                
                // Highlight matching nodes
                chart.chart.selectAll('.sankey-node rect')
                    .filter(function(d) {
                        return d.category === highlightState;
                    })
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', 1)
                    .style('stroke-width', '3px')
                    .style('stroke', function() {
                        if (highlightState === 'profit') return '#059669';
                        if (highlightState === 'revenue') return '#1e40af';
                        if (highlightState === 'expense') return '#dc2626';
                        return 'white';
                    });
                
                // Highlight matching labels
                chart.chart.selectAll('.node-text-group')
                    .filter(function(d) {
                        return d.category === highlightState;
                    })
                    .transition()
                    .duration(300)
                    .style('opacity', 1);
                
                // Highlight related links
                chart.chart.selectAll('.sankey-link path')
                    .filter(function(d) {
                        return d.source.category === highlightState || d.target.category === highlightState;
                    })
                    .transition()
                    .duration(300)
                    .attr('fill-opacity', chart.config.linkOpacity);
            }
        }

        function updateMetadataInputs() {
            const fields = [
                { id: 'company-name', value: flowData.metadata.company },
                { id: 'period', value: flowData.metadata.period },
                { id: 'currency', value: flowData.metadata.currency },
                { id: 'units', value: flowData.metadata.unit },
                { id: 'period-type', value: flowData.metadata.periodType || 'Q/Q' }
            ];
            
            fields.forEach(({ id, value }) => {
                const element = document.getElementById(id);
                if (element && value) {
                    element.value = value;
                }
            });
        }

        function renderFlowTable() {
            const tbody = document.getElementById('flows-tbody');
            tbody.innerHTML = '';
            
            // Auto-calculate layers and flow types before rendering
            autoCalculateFlowProperties();
            
            // Always ensure we have at least one empty row
            if (flowData.flows.length === 0) {
                addFlow(); // This will add one empty row
                return; // renderFlowTable will be called again
            }
            
            // Check if the last row is empty, if not add an empty row
            const lastFlow = flowData.flows[flowData.flows.length - 1];
            const isLastRowEmpty = !lastFlow.source && !lastFlow.target && lastFlow.value === 0;
            
            if (!isLastRowEmpty) {
                // Add an empty row at the end
                const statementType = detectFinancialStatementType();
                const categories = getCategoriesForStatementType(statementType);
                const defaultCategory = categories[0].value;
                
                const emptyFlow = new BusinessFlow({
                    source: "",
                    target: "", 
                    value: 0,
                    previousValue: 0,
                    sourceCategory: defaultCategory,
                    targetCategory: defaultCategory,
                    description: ""
                });
                
                flowData.flows.push(emptyFlow);
            }
            
            flowData.flows.forEach((flow, index) => {
                const row = createFlowRow(flow, index);
                tbody.appendChild(row);
            });
            
            // Apply variance colors after all rows are added
            applyVarianceColors();
            
            // Initialize category buttons to show current categories
            setTimeout(() => initializeCategoryButtons(), 50);
            
        }

        // Helper function to detect financial statement type
        function detectFinancialStatementType() {
            if (!flowData || !flowData.flows || flowData.flows.length === 0) {
                return 'income_statement'; // Default to income statement
            }
            
            // Check if we have balance sheet categories
            const hasBalanceSheetCategories = flowData.flows.some(flow => 
                flow.sourceCategory === 'asset' || flow.targetCategory === 'asset' ||
                flow.sourceCategory === 'liability' || flow.targetCategory === 'liability' ||
                flow.sourceCategory === 'equity' || flow.targetCategory === 'equity'
            );
            
            return hasBalanceSheetCategories ? 'balance_sheet' : 'income_statement';
        }
        
        // Helper function to get appropriate categories for statement type
        function getCategoriesForStatementType(statementType) {
            if (statementType === 'balance_sheet') {
                return [
                    { value: 'asset', label: 'Asset' },
                    { value: 'liability', label: 'Liability' },
                    { value: 'equity', label: 'Equity' }
                ];
            } else {
                return [
                    { value: 'revenue', label: 'Revenue' },
                    { value: 'expense', label: 'Expense' },
                    { value: 'profit', label: 'Profit' }
                ];
            }
        }

        function createFlowRow(flow, index) {
            const tr = document.createElement('tr');
            tr.setAttribute('data-row', index);
            
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            
            // Check if this is an empty row (declare early to use throughout)
            const isEmpty = !flow.source && !flow.target && flow.value === 0;
            
            // Check if description column should be visible
            const descriptionToggle = document.getElementById('description-column-toggle');
            const showDescription = descriptionToggle ? descriptionToggle.checked : true; // Default to true if toggle not found
            const descriptionDisplay = showDescription ? 'table-cell' : 'none';
            
            let rowHTML = `
                <td class="control-cell">
                    <div class="flow-controls">
                        <button class="flow-control-btn remove" onclick="removeFlow(${index})" title="Remove">×</button>
                    </div>
                </td>
                <td class="spreadsheet-cell" data-col="source" data-row="${index}" data-type="text">
                    <div class="cell-content">${flow.source}</div>
                    <input type="text" class="cell-editor" style="display: none;">
                </td>
                <td class="spreadsheet-cell" data-col="target" data-row="${index}" data-type="text">
                    <div class="cell-content">${flow.target}</div>
                    <input type="text" class="cell-editor" style="display: none;">
                </td>
                <td class="spreadsheet-cell" data-col="description" data-row="${index}" data-type="text" style="display: ${descriptionDisplay};">
                    <div class="cell-content">${flow.description || ''}</div>
                    <input type="text" class="cell-editor" style="display: none;" placeholder="Flow description...">
                </td>
                <td class="spreadsheet-cell" data-col="value" data-row="${index}" data-type="number">
                    <div class="cell-content">${isEmpty ? '' : (flow.value ? flow.value.toLocaleString() : '0')}</div>
                    <input type="number" class="cell-editor" style="display: none;">
                </td>
                <td class="spreadsheet-cell" data-col="previousValue" data-row="${index}" data-type="number">
                    <div class="cell-content">${isEmpty ? '' : (typeof flow.previousValue === 'number' ? flow.previousValue.toLocaleString() : '')}</div>
                    <input type="number" class="cell-editor" style="display: none;" placeholder="0">
                </td>
                <td class="variance-cell">
                    <div style="text-align: center;">${isEmpty ? '' : flow.getVarianceDisplay()}</div>
                </td>
`;
            
            // Get context-aware categories
            const statementType = detectFinancialStatementType();
            const categories = getCategoriesForStatementType(statementType);
            
            tr.innerHTML = rowHTML;
            return tr;
        }

        // Helper functions for display formatting
        function getFlowTypeDisplay(flowType) {
            const types = {
                'revenue_flow': 'Revenue Flow',
                'expense_flow': 'Expense Flow', 
                'profit_flow': 'Profit Flow'
            };
            return types[flowType] || flowType;
        }

        function getCategoryDisplay(category) {
            return category.charAt(0).toUpperCase() + category.slice(1);
        }

        function getVarianceClass(flow) {
            const variance = flow.getVariance();
            
            if (variance.trend === 'up') {
                return 'variance-positive';
            } else if (variance.trend === 'down') {
                return 'variance-negative';
            } else {
                return 'variance-neutral';
            }
        }
        
        function applyVarianceColors() {
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            if (!comparisonMode) return;
            
            // Use setTimeout to ensure DOM is fully rendered
            setTimeout(() => {
                const varianceCells = document.querySelectorAll('.variance-cell div');
                varianceCells.forEach((cell, index) => {
                    if (index < flowData.flows.length) {
                        const flow = flowData.flows[index];
                        const variance = flow.getVariance();
                        
                        // Apply colors using CSS classes first, then inline styles as backup
                        cell.className = ''; // Clear existing classes
                        
                        if (variance.trend === 'up') {
                            cell.classList.add('variance-positive');
                            cell.style.color = '#16a34a';
                            cell.style.fontWeight = '700';
                        } else if (variance.trend === 'down') {
                            cell.classList.add('variance-negative');
                            cell.style.color = '#dc2626';
                            cell.style.fontWeight = '700';
                        } else {
                            cell.classList.add('variance-neutral');
                            cell.style.color = '#6b7280';
                            cell.style.fontWeight = '600';
                        }
                    }
                });
            }, 50); // Small delay to ensure DOM is ready
        }

        // Auto-calculate layers and flow types when flows are updated
        function autoCalculateFlowProperties() {
            if (!flowData.flows || flowData.flows.length === 0) return;

            // Build a node hierarchy map
            const nodeInputs = new Map(); // node -> list of sources
            const nodeOutputs = new Map(); // node -> list of targets
            
            flowData.flows.forEach(flow => {
                if (!nodeInputs.has(flow.target)) nodeInputs.set(flow.target, []);
                if (!nodeOutputs.has(flow.source)) nodeOutputs.set(flow.source, []);
                
                nodeInputs.get(flow.target).push(flow.source);
                nodeOutputs.get(flow.source).push(flow.target);
            });

            // Calculate layers using topological ordering
            const layers = new Map();
            const processed = new Set();
            
            // Start with nodes that have no inputs (sources)
            const queue = [];
            for (let flow of flowData.flows) {
                if (!nodeInputs.has(flow.source) || nodeInputs.get(flow.source).length === 0) {
                    if (!layers.has(flow.source)) {
                        layers.set(flow.source, 0);
                        queue.push(flow.source);
                    }
                }
            }
            
            // Process nodes level by level
            while (queue.length > 0) {
                const currentNode = queue.shift();
                if (processed.has(currentNode)) continue;
                processed.add(currentNode);
                
                const currentLayer = layers.get(currentNode) || 0;
                
                // Update targets to be at least one layer deeper
                if (nodeOutputs.has(currentNode)) {
                    for (let target of nodeOutputs.get(currentNode)) {
                        const targetLayer = Math.max(layers.get(target) || 0, currentLayer + 1);
                        layers.set(target, targetLayer);
                        queue.push(target);
                    }
                }
            }

            // Apply calculated layers and auto-determine flow types
            flowData.flows.forEach(flow => {
                flow.sourceLayer = layers.get(flow.source) || 0;
                flow.targetLayer = layers.get(flow.target) || flow.sourceLayer + 1;
                
                // Auto-determine flow type based on categories
                if (flow.sourceCategory === 'revenue' && flow.targetCategory === 'revenue') {
                    flow.flowType = 'revenue_flow';
                } else if (flow.targetCategory === 'expense' || flow.targetCategory === 'cost' || flow.targetCategory === 'tax') {
                    flow.flowType = 'expense_flow';
                } else if (flow.sourceCategory === 'profit' || flow.targetCategory === 'profit' || flow.targetCategory === 'income') {
                    flow.flowType = 'profit_flow';
                } else if (flow.sourceCategory === 'cost' || flow.sourceCategory === 'expense') {
                    flow.flowType = 'expense_flow';
                } else if (flow.sourceCategory === 'asset' || flow.targetCategory === 'asset') {
                    flow.flowType = 'asset_flow';
                } else if (flow.sourceCategory === 'liability' || flow.targetCategory === 'liability') {
                    flow.flowType = 'liability_flow';
                } else if (flow.sourceCategory === 'equity' || flow.targetCategory === 'equity') {
                    flow.flowType = 'equity_flow';
                } else {
                    flow.flowType = 'revenue_flow'; // default
                }
            });
        }

        function getFlowBalanceIndicator(flow) {
            const isValid = flow.source && flow.target && flow.value > 0 && flow.sourceLayer < flow.targetLayer;
            return `<div class="balance-indicator ${isValid ? 'balanced' : 'unbalanced'}">${isValid ? '✓' : '⚠'}</div>`;
        }

        function addFlow() {
            // Get appropriate default category for the statement type
            const statementType = detectFinancialStatementType();
            const categories = getCategoriesForStatementType(statementType);
            const defaultCategory = categories[0].value;
            
            const newFlow = new BusinessFlow({
                source: "",
                target: "", 
                value: 0,
                previousValue: 0,
                sourceCategory: defaultCategory,
                targetCategory: defaultCategory,
                description: ""
            });
            
            flowData.flows.push(newFlow);
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }
        
        function addFlows() {
            const rowsToAdd = parseInt(document.getElementById('rows-to-add').value) || 1;
            
            // Get appropriate default category for the statement type
            const statementType = detectFinancialStatementType();
            const categories = getCategoriesForStatementType(statementType);
            const defaultCategory = categories[0].value;
            
            for (let i = 0; i < rowsToAdd; i++) {
                const newFlow = new BusinessFlow({
                    source: "",
                    target: "", 
                    value: 0,
                    previousValue: 0,
                    sourceCategory: defaultCategory,
                    targetCategory: defaultCategory,
                    description: ""
                });
                
                flowData.flows.push(newFlow);
            }
            
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        function removeFlow(index) {
            flowData.flows.splice(index, 1);
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        // moveFlowUp, moveFlowDown, and duplicateFlow functions removed
        // Users can now use copy/paste functionality for these operations

        function updateMetadata() {
            // Form fields removed - metadata now extracted from chart title
            const chartTitle = findChartTitle();
            if (chartTitle && chartTitle.textContent) {
                const titleText = chartTitle.textContent.trim();
                if (titleText.includes('Income Statement')) {
                    const parts = titleText.replace(' Income Statement', '').trim().split(' ');
                    if (parts.length >= 2) {
                        flowData.metadata.period = parts.pop();
                        flowData.metadata.company = parts.join(' ');
                    }
                } else if (titleText.includes('Balance Sheet')) {
                    const parts = titleText.replace(' Balance Sheet', '').trim().split(' ');
                    if (parts.length >= 2) {
                        flowData.metadata.period = parts.pop();
                        flowData.metadata.company = parts.join(' ');
                    }
                }
            }
            
            // Set defaults if not found
            flowData.metadata.company = flowData.metadata.company || 'TechFlow SaaS Corp';
            flowData.metadata.period = flowData.metadata.period || 'Q3 2025';
            flowData.metadata.currency = flowData.metadata.currency || 'USD ($)';
            flowData.metadata.unit = flowData.metadata.unit || 'Millions';
            flowData.metadata.periodType = flowData.metadata.periodType || 'Q/Q';
            flowData.metadata.title = `${flowData.metadata.company} Financial Flow`;
            
            debouncedRealTimeUpdate();
        }


        function updateAllStats() {
            const nodeMap = new Map();
            
            flowData.flows.forEach(flow => {
                nodeMap.set(flow.source, flow.sourceLayer);
                nodeMap.set(flow.target, flow.targetLayer);
            });
            
            const flowCount = flowData.flows.length;
            const nodeCount = nodeMap.size;
            const layerCount = new Set(Array.from(nodeMap.values())).size;
            
            let balancedFlows = 0;
            flowData.flows.forEach(flow => {
                const isValid = flow.source && flow.target && flow.value > 0 && flow.sourceLayer < flow.targetLayer;
                if (isValid) balancedFlows++;
            });
            
            const balanceScore = flowCount > 0 ? Math.round((balancedFlows / flowCount) * 100) : 0;
            
            // Chart stats UI removed - keeping calculations for internal use only
            // document.getElementById('flow-count').textContent = flowCount;
            // document.getElementById('node-count').textContent = nodeCount;
            // document.getElementById('layer-count').textContent = layerCount;
            // document.getElementById('balance-score').textContent = balanceScore + '%';
        }

        function applyFlowChanges() {
            console.log('🚀 Applying Flow Builder changes...');
            
            // Form fields removed - use existing metadata or defaults
            flowData.metadata.company = flowData.metadata.company || 'TechFlow SaaS Corp';
            flowData.metadata.period = flowData.metadata.period || 'Q3 2025';
            flowData.metadata.currency = flowData.metadata.currency || 'USD ($)';
            flowData.metadata.unit = flowData.metadata.unit || 'Millions';
            flowData.metadata.title = `${flowData.metadata.company} Financial Flow`;
            
            const sankeyData = generateNodesAndLinksFromFlows();
            window.PulseDataBridge.setData(sankeyData, 'flow-builder');
            
            // Reset highlighting when chart data changes
            resetNodeHighlighting();
            
            // Re-initialize category buttons after data changes
            setTimeout(() => initializeCategoryButtons(), 100);
            
            // Chart view removed - staying on data-builder
            
        }

        function validateFlows() {
            const errors = [];
            const warnings = [];
            
            if (flowData.flows.length === 0) {
                errors.push('No flows defined');
            }
            
            flowData.flows.forEach((flow, index) => {
                if (!flow.source || !flow.target) {
                    errors.push(`Flow ${index + 1}: Missing source or target`);
                }
                
                if (flow.value <= 0) {
                    errors.push(`Flow ${index + 1}: Invalid value (${flow.value})`);
                }
                
                if (flow.sourceLayer >= flow.targetLayer) {
                    errors.push(`Flow ${index + 1}: Source layer must be less than target layer`);
                }
                
                if (flow.source === flow.target) {
                    errors.push(`Flow ${index + 1}: Source and target cannot be the same`);
                }
            });
            
            let message = '✅ Flow Validation Results\n\n';
            
            if (errors.length > 0) {
                message += '❌ Errors:\n' + errors.map(e => `• ${e}`).join('\n') + '\n\n';
            }
            
            if (warnings.length > 0) {
                message += '⚠️ Warnings:\n' + warnings.map(w => `• ${w}`).join('\n') + '\n\n';
            }
            
            if (errors.length === 0 && warnings.length === 0) {
                message += 'Perfect! All flows are valid.\n\n';
            }
            
            // Calculate balance score locally since UI element was removed
            let balancedFlows = 0;
            flowData.flows.forEach(flow => {
                const isValid = flow.source && flow.target && flow.value > 0 && flow.sourceLayer < flow.targetLayer;
                if (isValid) balancedFlows++;
            });
            const balanceScore = flowData.flows.length > 0 ? Math.round((balancedFlows / flowData.flows.length) * 100) : 0;
            message += `📊 Summary:\n• ${flowData.flows.length} flows\n• Balance Score: ${balanceScore}%`;
            
            alert(message);
        }

        function exportFlowsToCSV() {
            let csv = 'Source,Target,Current Value,Previous Value,Description\n';
            
            flowData.flows.forEach(flow => {
                csv += `"${flow.source}","${flow.target}",${flow.value},${flow.previousValue || 0},"${flow.description}"\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${flowData.metadata.company.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()}-flows.csv`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importFlowsFromCSV() {
            document.getElementById('csv-file-input').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                
                if (file.name.endsWith('.json')) {
                    try {
                        const data = JSON.parse(content);
                        
                        // CRITICAL: Preserve existing colors before import
                        const existingColors = { ...flowData.metadata.colorPalette };
                        
                        if (data.flows) {
                            flowData = data;
                        } else if (data.nodes && data.links) {
                            flowData = convertSankeyDataToFlows(data);
                        }
                        
                        // CRITICAL: Restore colors after import
                        flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                        
                        renderFlowTable(); // This calls autoCalculateFlowProperties()
                        updateAllStats();
                        
                        // Force chart update with the imported data
                        debouncedRealTimeUpdate();
                        
                        alert('✅ Successfully imported flows!');
                    } catch (error) {
                        alert('❌ Error parsing JSON: ' + error.message);
                    }
                } else if (file.name.endsWith('.csv')) {
                    parseCSVFlows(content);
                }
            };
            reader.readAsText(file);
        }

        function parseCSVFlows(csvContent) {
            const lines = csvContent.split('\n').filter(line => line.trim() && !line.startsWith('#'));
            if (lines.length < 2) {
                alert('❌ CSV file must have header and at least one data row');
                return;
            }
            
            // Parse header to detect column positions
            const headers = parseCSVLine(lines[0]).map(h => h.toLowerCase().trim());
            const columnMap = {
                source: Math.max(headers.indexOf('source'), headers.indexOf('from')),
                target: Math.max(headers.indexOf('target'), headers.indexOf('to')),
                amount: Math.max(headers.indexOf('amount'), headers.indexOf('current value'), headers.indexOf('value')),
                previousAmount: Math.max(headers.indexOf('previous amount'), headers.indexOf('previous value')),
                description: headers.indexOf('description')
            };
            
            // CRITICAL: Preserve existing colors before import
            const existingColors = { ...flowData.metadata.colorPalette };
            
            const flows = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                
                // Get source and target values with fallback logic
                const sourceValue = columnMap.source >= 0 ? values[columnMap.source] : `Flow ${i} Source`;
                const targetValue = columnMap.target >= 0 ? values[columnMap.target] : `Flow ${i} Target`;
                const amountValue = columnMap.amount >= 0 ? parseFloat(values[columnMap.amount]) : 100;
                
                // Minimum requirement: at least one meaningful value
                if (values.length >= 1 && (sourceValue || targetValue || amountValue)) {
                    const previousValue = columnMap.previousAmount >= 0 && values[columnMap.previousAmount] 
                        ? parseFloat(values[columnMap.previousAmount]) || 0 
                        : 0;
                    
                    flows.push(new BusinessFlow({
                        source: sourceValue || `Flow ${i} Source`,
                        target: targetValue || `Flow ${i} Target`,
                        value: amountValue || 100,
                        previousValue: previousValue,
                        sourceCategory: 'revenue', // Default to revenue
                        targetCategory: 'revenue', // Default to revenue
                        description: (columnMap.description >= 0 ? values[columnMap.description] : null) || `Flow from ${sourceValue || 'Source'} to ${targetValue || 'Target'}`
                        // Note: flowType, sourceLayer, targetLayer will be auto-calculated
                    }));
                }
            }
            
            if (flows.length > 0) {
                flowData.flows = flows;
                
                // CRITICAL: Restore colors after import
                flowData.metadata.colorPalette = existingColors;
                
                // Enable comparison mode if any previous values exist
                const hasPreviousValues = flows.some(flow => flow.previousValue > 0);
                if (hasPreviousValues) {
                    document.getElementById('comparison-mode-toggle').checked = true;
                    toggleComparisonMode();
                }
                
                renderFlowTable(); // This calls autoCalculateFlowProperties()
                updateAllStats();
                
                // Force chart update with the imported data
                debouncedRealTimeUpdate();
                
                
                // Provide helpful feedback about what was imported
                let message = `✅ Successfully imported ${flows.length} flows from CSV!\n\n`;
                
                if (columnMap.source < 0 || columnMap.target < 0) {
                    message += '⚠️ Note: Some source/target columns were missing and have been auto-generated. ';
                    message += 'You can edit these in the table below.\n\n';
                }
                
                message += 'ℹ️ Categories have been set to default values. You can adjust them using the color picker modal.\n\n';
                
                message += 'The chart will update automatically as you edit the data.';
                
                alert(message);
            } else {
                alert('❌ No valid flows found in CSV file');
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result.map(field => field.replace(/^"|"$/g, ''));
        }

        // FIXED: Generate nodes and links with proper color preservation and percentage metrics
        function generateNodesAndLinksFromFlows() {
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            const result = PulseSankeyChart.generateNodesAndLinksFromFlows(flowData, comparisonMode);
            
            // Preserve the comparison mode in metadata
            result.metadata.comparisonMode = comparisonMode;
            
            // Determine chart type based on categories
            const isBalanceSheet = flowData.flows.some(flow => 
                flow.sourceCategory === 'asset' || flow.targetCategory === 'asset' ||
                flow.sourceCategory === 'liability' || flow.targetCategory === 'liability' ||
                flow.sourceCategory === 'equity' || flow.targetCategory === 'equity'
            );
            
            result.metadata.statementType = isBalanceSheet ? 'balance' : 'income';
            
            // Calculate percentage metrics
            if (isBalanceSheet) {
                // For Balance Sheet: Add growth/decline percentages
                result.nodes.forEach(node => {
                    const matchingFlow = flowData.flows.find(flow => 
                        flow.source === node.id || flow.target === node.id
                    );
                    if (matchingFlow) {
                        node.growthDecline = matchingFlow.getGrowthDeclineDisplay();
                        node.hasPercentages = true;
                    }
                });
            } else {
                // For Income Statement: Add both growth/decline and margin percentages
                const revenueBase = findRevenueBase(flowData);
                
                result.nodes.forEach(node => {
                    const matchingFlow = flowData.flows.find(flow => 
                        flow.source === node.id || flow.target === node.id
                    );
                    if (matchingFlow) {
                        node.growthDecline = matchingFlow.getGrowthDeclineDisplay();
                        // Calculate percentage of revenue for this node's value
                        node.marginPercentage = getRevenuePercentage(node.value, revenueBase);
                        node.hasPercentages = true;
                    }
                });
                
                result.metadata.revenueBase = revenueBase;
            }
            
            return result;
        }

        // IIFE: Single Initialization Controller - Eliminates All Redundancy
        (function() {
            'use strict';
            
            // State management to prevent duplicate operations
            const initState = {
                isInitialized: false,
                chartTypeProcessed: false,
                tabSwitchProcessed: false,
                renderCompleted: false
            };
            
            
            document.addEventListener('DOMContentLoaded', async function() {
                if (initState.isInitialized) {
                    return;
                }
                
                initState.isInitialized = true;
                console.log('🚀 Single initialization starting...');
                
                // Basic UI setup
                setupBasicUI();
                
                // Add event listener for flow table updates from chart edits
                window.addEventListener('flowTableUpdate', (event) => {
                    try {
                        if (event.detail.source === 'chart-edit' && event.detail.data) {
                            
                            // Method 1: Try to update flowData and renderFlowTable (if available)
                            if (typeof convertSankeyDataToFlows === 'function' && 
                                typeof renderFlowTable === 'function') {
                                
                                const convertedFlowData = convertSankeyDataToFlows(event.detail.data);
                                
                                // Initialize flowData if it doesn't exist
                                if (!window.flowData) {
                                    window.flowData = {
                                        flows: [],
                                        metadata: {
                                            company: "Chart Data",
                                            title: "Financial Flow",
                                            period: "Current", 
                                            colorPalette: {},
                                            comparisonMode: false
                                        }
                                    };
                                }
                                
                                // Preserve existing metadata (colors, etc.)
                                const existingMetadata = window.flowData.metadata || {};
                                window.flowData.flows = convertedFlowData.flows;
                                window.flowData.metadata = {
                                    ...existingMetadata,
                                    ...convertedFlowData.metadata
                                };
                                
                                
                                // Follow the exact same sequence as the working reset button
                                // Update metadata inputs (critical step)
                                if (typeof updateMetadataInputs === 'function') {
                                    console.log('📝 Calling updateMetadataInputs()...');
                                    updateMetadataInputs();
                                }
                                
                                // Re-render the flow table
                                renderFlowTable();
                                
                                // Update statistics
                                if (typeof updateAllStats === 'function') {
                                    updateAllStats();
                                }
                                
                            } else {
                            }
                        }
                    } catch (error) {
                        console.warn('⚠️ Error handling flowTableUpdate event:', error.message);
                        console.error(error);
                    }
                });
                
                // Parse URL parameters once
                const urlParams = new URLSearchParams(window.location.search);
                const chartType = urlParams.get('chartType') || urlParams.get('type');
                const targetTab = urlParams.get('tab');
                
                
                // Wait for pulseApp to be ready
                await waitForPulseApp();
                
                // Handle chart type in one place only
                if (chartType && !initState.chartTypeProcessed) {
                    initState.chartTypeProcessed = true;
                    
                    // Update selector UI
                    const chartTypeSelect = document.getElementById('chart-type-select');
                    if (chartTypeSelect) {
                        chartTypeSelect.value = chartType;
                    }
                    
                    // Single chart type change
                    if (chartType === 'bar') {
                        await handleBarChartInitialization();
                        
                        // Chart view removed - staying on data-builder
                    } else {
                        await handleOtherChartTypes(chartType);
                    }
                } else if (!chartType) {
                    // No chart type in URL, initialize interface normally
                    initializeChartInterface();
                }
                
                // Set up event listeners only once
                setupEventListeners();
                
            });
            
            // Helper: Basic UI setup
            function setupBasicUI() {
                const csvFileInput = document.getElementById('csv-file-input');
                if (csvFileInput) {
                    csvFileInput.addEventListener('change', handleFileImport);
                }
                

                // Initialize SpreadsheetController for Sankey flow builder
                console.log('📊 Initializing SpreadsheetController for main flow table');
                window.spreadsheetController = new SpreadsheetController();
                
                // Auto-select first cell in main flow table to enable paste immediately
                setTimeout(() => {
                    const firstCell = document.querySelector('#main-flow-table .spreadsheet-cell');
                    if (firstCell && window.spreadsheetController && !window.spreadsheetController.selectedCell) {
                        console.log('📋 SpreadsheetController: Auto-selecting first cell to enable paste');
                        window.spreadsheetController.selectCell(firstCell);
                    }
                }, 500);
            }
            
            // Helper: Wait for pulseApp to be ready
            function waitForPulseApp() {
                return new Promise((resolve) => {
                    if (window.pulseApp && window.pulseApp.isInitialized) {
                        resolve();
                        return;
                    }
                    
                    const checkInterval = setInterval(() => {
                        if (window.pulseApp && window.pulseApp.isInitialized) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 50);
                    
                    // Timeout after 5 seconds
                    setTimeout(() => {
                        clearInterval(checkInterval);
                        console.warn('⚠️ PulseApp timeout, proceeding anyway');
                        resolve();
                    }, 5000);
                });
            }
            
            // Helper: Handle bar chart initialization with single render
            async function handleBarChartInitialization() {
                try {
                    
                    if (!window.pulseApp || !window.pulseApp.switchChartType) {
                        console.error('❌ PulseApp not available');
                        return;
                    }
                    
                    // **FIX FLICKER: Update chart container IMMEDIATELY before chart switch**
                    updateChartContainerForBarChart();
                    
                    // Switch to bar chart (will render once internally)
                    await window.pulseApp.switchChartType('bar');
                    
                    // Mark render as completed to prevent additional renders
                    initState.renderCompleted = true;
                    
                } catch (error) {
                    console.error('❌ Error in bar chart initialization:', error);
                    // Continue anyway to prevent blocking
                }
            }
            
            // Helper: Handle other chart types
            async function handleOtherChartTypes(chartType) {
                if (chartType === 'bar') {
                    // Bar charts are handled by their own initialization system
                    return;
                } else {
                    // Sankey charts (income, balance, etc.)
                    initializeChartInterface();
                }
            }
            
            // Helper: Set up event listeners only once
            function setupEventListeners() {
                const chartTypeSelect = document.getElementById('chart-type-select');
                if (chartTypeSelect && !chartTypeSelect.hasEventListener) {
                    chartTypeSelect.hasEventListener = true;
                    chartTypeSelect.addEventListener('change', (e) => {
                        const selectedType = e.target.value;
                        console.log(`📊 Manual chart type change: ${selectedType}`);
                        handleChartTypeChange(selectedType);
                    });
                }
            }
            
            // Helper: Update chart container for bar chart (prevent flicker)
            function updateChartContainerForBarChart() {
                console.log('🚀 Updating chart container for bar chart immediately');
                
                // Tab system removed - no chart type indicator to update
                
                // Update chart container immediately to prevent flicker
                const dataBuilderContent = document.getElementById('data-builder');
                if (dataBuilderContent && !dataBuilderContent.querySelector('.unified-data-builder')) {
                    dataBuilderContent.innerHTML = `
                        <div class="unified-data-builder">
                            <div id="unified-data-editor-container" style="padding: 20px;">
                                <!-- UnifiedSpreadsheetEditor will be initialized here -->
                            </div>
                        </div>
                    `;
                    
                    // Initialize unified spreadsheet editor with proper timing
                    setTimeout(() => {
                        if (typeof UnifiedSpreadsheetEditor !== 'undefined') {
                            // Wait for chart to be fully initialized
                            const waitForChart = () => {
                                if (window.pulseApp && window.pulseApp.chart) {
                                    const chartInstance = window.pulseApp.chart;
                                    const chartType = window.pulseApp.currentChartType || 'bar';
                                    
                                    // Destroy existing editor if it exists and is wrong type
                                    if (window.unifiedDataEditor && window.unifiedDataEditor.chartType !== chartType) {
                                        window.unifiedDataEditor.destroy();
                                        window.unifiedDataEditor = null;
                                    }
                                    
                                    if (!window.unifiedDataEditor) {
                                        window.unifiedDataEditor = new UnifiedSpreadsheetEditor('unified-data-editor-container', chartInstance, chartType);
                                        console.log('✅ UnifiedSpreadsheetEditor initialized for', chartType);
                                    }
                                } else {
                                    setTimeout(waitForChart, 100);
                                }
                            };
                            waitForChart();
                        } else {
                            console.error('❌ UnifiedSpreadsheetEditor class not available');
                        }
                    }, 200);
                }
            }
            
        })();

        // Modern Export Dropdown Functionality

        // ===== TEMPLATE DOWNLOAD FUNCTIONALITY =====

        function downloadTemplate() {
            if (!selectedChartType) {
                alert('Please select a chart type first by clicking on Income Statement or Balance Sheet.');
                return;
            }
            
            let csv = '';
            let filename = '';
            
            if (selectedChartType === 'income') {
                csv = 'Source,Target,Current Value,Previous Value,Description\n';
                csv += '"Subscription Revenue","Total Revenue",300,250,"Recurring subscription income"\n';
                csv += '"Professional Services","Total Revenue",60,55,"Implementation and consulting"\n';
                csv += '"Total Revenue","Gross Profit",290,245,"Revenue after cost of revenue"\n';
                csv += '"Total Revenue","Cost of Revenue",70,60,"Direct costs to deliver services"\n';
                csv += '"Gross Profit","Operating Profit",120,100,"Profit from core operations"\n';
                csv += '"Gross Profit","Operating Expenses",170,145,"Total operating expenses"\n';
                csv += '"Operating Profit","Net Income",95,80,"Final net income"\n';
                csv += '"Operating Profit","Tax Expense",25,20,"Income tax expense"\n';
                filename = 'income-statement-template.csv';
            } else if (selectedChartType === 'balance') {
                csv = 'Source,Target,Current Value,Previous Value,Description\n';
                csv += '"Current Assets","Total Assets",500,450,"Cash, receivables, inventory"\n';
                csv += '"Non-Current Assets","Total Assets",800,750,"Property, equipment, intangibles"\n';
                csv += '"Total Assets","Current Liabilities",300,280,"Short-term obligations"\n';
                csv += '"Total Assets","Non-Current Liabilities",400,370,"Long-term debt and obligations"\n';
                csv += '"Total Assets","Shareholders Equity",600,550,"Owner\'s equity in the business"\n';
                filename = 'balance-sheet-template.csv';
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // ===== CHART TYPE SELECTOR FUNCTIONALITY =====
        
        function initializeChartTypeSelector() {
            // DISABLED: This function is replaced by IIFE pattern to prevent redundancy
            console.log('⚠️ initializeChartTypeSelector() DISABLED - handled by IIFE');
            return;
            
            const chartTypeSelect = document.getElementById('chart-type-select');
            if (!chartTypeSelect) return;
            
            
            // Add event listener for chart type changes
            chartTypeSelect.addEventListener('change', (e) => {
                const selectedType = e.target.value;
                handleChartTypeChange(selectedType);
            });
            
            // Check URL parameters for chart type
            const urlParams = new URLSearchParams(window.location.search);
            const urlChartType = urlParams.get('chartType');
            
            if (urlChartType) {
                chartTypeSelect.value = urlChartType;
                
                // **CRITICAL FIX: Ensure app is ready before switching chart type**
                if (window.pulseApp && window.pulseApp.isInitialized) {
                    handleChartTypeChange(urlChartType);
                } else {
                    // Wait for app to be ready with more robust checking
                    let attempts = 0;
                    const maxAttempts = 100; // 10 seconds max
                    
                    const waitForApp = setInterval(() => {
                        attempts++;
                        
                        if (window.pulseApp && window.pulseApp.isInitialized) {
                            clearInterval(waitForApp);
                            
                            // **ADDITIONAL FIX: Add small delay to ensure everything is settled**
                            setTimeout(() => {
                                handleChartTypeChange(urlChartType);
                            }, 200);
                        } else if (attempts >= maxAttempts) {
                            clearInterval(waitForApp);
                            handleChartTypeChange(urlChartType);
                        }
                    }, 100);
                }
            }
        }
        
        function handleChartTypeChange(chartType) {
            
            // Update the current chart type
            window.currentChartType = chartType;
            
            if (chartType === 'bar') {
                
                // **CRITICAL FIX: Use the app's switchChartType method**
                if (window.pulseApp && window.pulseApp.switchChartType) {
                    window.pulseApp.switchChartType('bar');
                }
                
                // Tab system removed - no tab labels to update
                
                // Update the data builder content for bar charts (prevent duplicate calls)
                const dataBuilderContent = document.getElementById('data-builder');
                
                // PREVENT FLICKERING: Only update if not already unified content
                if (dataBuilderContent && !dataBuilderContent.querySelector('.unified-data-builder')) {
                    dataBuilderContent.innerHTML = `
                        <div class="unified-data-builder">
                            <div id="unified-data-editor-container" style="padding: 20px;">
                                <!-- UnifiedSpreadsheetEditor will be initialized here -->
                            </div>
                        </div>
                    `;
                } else {
                    console.log('📊 Unified data builder already exists, skipping recreation');
                }
                
                // Initialize unified spreadsheet editor with proper timing
                setTimeout(() => {
                    if (typeof UnifiedSpreadsheetEditor !== 'undefined') {
                        if (!window.unifiedDataEditor) {
                            // Wait for chart to be fully initialized
                            const waitForChart = () => {
                                if (window.pulseApp && window.pulseApp.chart) {
                                    const chartInstance = window.pulseApp.chart;
                                    const chartType = window.pulseApp.currentChartType || 'bar';
                                    
                                    // Destroy existing editor if it exists and is wrong type
                                    if (window.unifiedDataEditor && window.unifiedDataEditor.chartType !== chartType) {
                                        window.unifiedDataEditor.destroy();
                                        window.unifiedDataEditor = null;
                                    }
                                    
                                    if (!window.unifiedDataEditor) {
                                        window.unifiedDataEditor = new UnifiedSpreadsheetEditor('unified-data-editor-container', chartInstance, chartType);
                                        console.log('✅ UnifiedSpreadsheetEditor initialized for', chartType);
                                    }
                                } else {
                                    setTimeout(waitForChart, 100);
                                }
                            };
                            waitForChart();
                        } else {
                            console.log('📊 UnifiedDataEditor already exists, checking chart type compatibility');
                            
                            // Check if existing editor is compatible with current chart type
                            const currentChartType = window.pulseApp?.currentChartType || 'bar';
                            if (window.unifiedDataEditor.chartType !== currentChartType) {
                                console.log(`📊 Switching unified editor from ${window.unifiedDataEditor.chartType} to ${currentChartType}`);
                                window.unifiedDataEditor.switchChartType(currentChartType);
                            }
                        }
                    } else {
                        console.error('❌ UnifiedSpreadsheetEditor class not available');
                    }
                }, 300);
                
            } else if (chartType === 'sankey') {
                
                // **CRITICAL FIX: Use the app's switchChartType method for consistency**
                if (window.pulseApp && window.pulseApp.switchChartType) {
                    window.pulseApp.switchChartType('sankey');
                }
                
                // Update data builder content for Sankey charts to use unified system
                const dataBuilderContent = document.getElementById('data-builder');
                if (dataBuilderContent && !dataBuilderContent.querySelector('.unified-data-builder')) {
                    dataBuilderContent.innerHTML = `
                        <div class="unified-data-builder">
                            <div id="unified-data-editor-container" style="padding: 20px;">
                                <!-- UnifiedSpreadsheetEditor will be initialized here -->
                            </div>
                        </div>
                    `;
                    
                    // Initialize unified spreadsheet editor for Sankey
                    setTimeout(() => {
                        if (typeof UnifiedSpreadsheetEditor !== 'undefined') {
                            const waitForChart = () => {
                                if (window.pulseApp && window.pulseApp.chart) {
                                    const chartInstance = window.pulseApp.chart;
                                    // Destroy existing editor if it exists and is wrong type
                                    if (window.unifiedDataEditor && window.unifiedDataEditor.chartType !== 'sankey') {
                                        window.unifiedDataEditor.destroy();
                                        window.unifiedDataEditor = null;
                                    }
                                    
                                    if (!window.unifiedDataEditor) {
                                        window.unifiedDataEditor = new UnifiedSpreadsheetEditor('unified-data-editor-container', chartInstance, 'sankey');
                                        console.log('✅ UnifiedSpreadsheetEditor initialized for Sankey');
                                    }
                                } else {
                                    setTimeout(waitForChart, 100);
                                }
                            };
                            waitForChart();
                        } else {
                            console.error('❌ UnifiedSpreadsheetEditor class not available');
                        }
                    }, 200);
                }
                
                // Tab system removed - no tab labels or visibility to manage
            }
            
            // Update URL to reflect chart type
            const url = new URL(window.location);
            url.searchParams.set('chartType', chartType);
            window.history.replaceState({}, '', url);
        }
        
        function initializeBarChartMode() {
            
            // Check if app is ready and has bar chart support
            if (window.pulseApp && window.pulseApp.chartRegistry && window.pulseApp.chartRegistry.bar) {
                
                // Initialize bar chart type
                window.pulseApp.initializeChartType('bar')
                    .then(() => {
                    })
                    .catch(error => {
                        console.error('❌ Bar chart initialization failed:', error);
                    });
            } else {
                console.warn('⚠️ Bar chart support not available');
            }
        }
        
        function loadBarChartSample() {
            
            // Load the sample data
            fetch('data/samples/bar-chart-sample.json')
                .then(response => response.json())
                .then(data => {
                    
                    // Render the bar chart
                    renderBarChart(data);
                    
                    // Show data preview
                    showBarDataPreview(data);
                    
                })
                .catch(error => {
                    console.error('❌ Failed to load bar chart sample:', error);
                    alert('Failed to load bar chart sample data. Please check the console for details.');
                });
        }
        
        function handleBarFileUpload(input) {
            const file = input.files[0];
            if (!file) return;
            
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    let barData = null;
                    
                    if (file.name.toLowerCase().endsWith('.json')) {
                        const jsonData = JSON.parse(content);
                        barData = convertToBarChartData(jsonData);
                    } else {
                        barData = parseCSVToBarData(content);
                    }
                    
                    
                    // Render the chart
                    renderBarChart(barData);
                    
                    // Show data preview
                    showBarDataPreview(barData);
                    
                    
                } catch (error) {
                    console.error('❌ File processing error:', error);
                    alert(`Failed to process "${file.name}": ${error.message}`);
                }
            };
            
            reader.readAsText(file);
        }
        
        function convertToBarChartData(data) {
            // Handle different JSON formats
            if (data.categories && data.values) {
                return data;
            }
            
            if (Array.isArray(data)) {
                const categories = [];
                const values = [];
                
                data.forEach(item => {
                    const category = item.category || item.name || item.label;
                    const value = parseFloat(item.value || item.amount || item.y);
                    
                    if (category && !isNaN(value)) {
                        categories.push(category);
                        values.push(value);
                    }
                });
                
                return {
                    metadata: { chartType: "bar", title: "Bar Chart Data" },
                    categories: categories,
                    values: values,
                    labels: categories
                };
            }
            
            throw new Error('Unrecognized JSON format');
        }
        
        function parseCSVToBarData(content) {
            const lines = content.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                throw new Error('CSV must have header and data rows');
            }
            
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const categoryIndex = headers.findIndex(h => h.includes('category') || h.includes('name') || h.includes('label'));
            const valueIndex = headers.findIndex(h => h.includes('value') || h.includes('amount') || h.includes('count'));
            
            if (categoryIndex === -1 || valueIndex === -1) {
                throw new Error('Could not find category and value columns');
            }
            
            const categories = [];
            const values = [];
            
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(',').map(cell => cell.trim());
                if (row.length > Math.max(categoryIndex, valueIndex)) {
                    const category = row[categoryIndex];
                    const value = parseFloat(row[valueIndex]);
                    
                    if (category && !isNaN(value)) {
                        categories.push(category);
                        values.push(value);
                    }
                }
            }
            
            return {
                metadata: { chartType: "bar", title: "Bar Chart Data" },
                categories: categories,
                values: values,
                labels: categories
            };
        }
        
        function renderBarChart(data) {
            
            // **CLEAN: Only use app's updateData method, no fallbacks or conflicts**
            if (window.pulseApp && window.pulseApp.updateData) {
                window.pulseApp.updateData(data, 'chart-html');
                window.currentBarChartData = data;
            } else {
                console.error('❌ PulseApp not available');
            }
        }
        
        function showBarDataPreview(data) {
            const previewDiv = document.getElementById('bar-data-preview');
            const currentDataDiv = document.getElementById('bar-current-data');
            
            if (previewDiv && currentDataDiv && data) {
                let preview = `Categories: ${data.categories.length} items\n\n`;
                
                data.categories.forEach((category, index) => {
                    preview += `${category}: ${data.values[index]}\n`;
                });
                
                previewDiv.textContent = preview;
                currentDataDiv.style.display = 'block';
            }
        }

        function resetChart() {
            if (confirm('This will reset the chart and return to chart type selection. Continue?')) {
                // Redirect to sankey chart type selector
                window.location.href = 'js/charts/sankey/sankey-type-selector.html';
            }
        }

        function clearAllFlowData() {
            if (confirm('⚠️ This will permanently delete all flow data. Are you sure you want to continue?')) {
                // Clear all flows
                flowData.flows = [];
                
                // Reset metadata to defaults
                flowData.metadata = {
                    title: "Financial Flow Analysis",
                    currency: "USD",
                    unit: "millions",
                    company: "Your Company",
                    period: "Current Period",
                    colorPalette: {
                        revenue: "#3498db",
                        profit: "#27ae60",
                        expense: "#e67e22"
                    }
                };
                
                // Form fields removed - metadata now handled via click-to-edit title
                
                // Re-render the table (which will show empty state)
                renderFlowTable();
                
                // Update statistics
                updateAllStats();
                
                // Clear the chart
                if (window.chart) {
                    try {
                        // Clear chart by rendering empty data
                        const emptyData = generateNodesAndLinksFromFlows();
                        window.chart.render(emptyData);
                    } catch (error) {
                        console.log('Chart cleared due to empty data');
                    }
                }
                
                // Show success notification
                showNotification('✅ All flow data cleared successfully', 'success');
                
            }
        }

        function showNotification(message, type = 'info') {
            // Create a notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            // Add styles
            Object.assign(notification.style, {
                position: 'fixed',
                top: '20px',
                right: '20px',
                background: type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6',
                color: 'white',
                padding: '12px 20px',
                borderRadius: '8px',
                fontSize: '14px',
                fontWeight: '500',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
                zIndex: '10000',
                opacity: '0',
                transform: 'translateX(100%)',
                transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
            });
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // Animate out and remove
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // ===== GOOGLE SHEETS-STYLE SPREADSHEET FUNCTIONALITY =====
        class SpreadsheetController {
            constructor() {
                this.selectedCell = null;
                this.selectedCells = new Set(); // For multi-cell selection
                this.selectionStart = null; // Starting cell for range selection
                this.editingCell = null;
                this.copiedCells = new Set(); // For multi-cell copy
                this.isDragging = false;
                this.dragStartCell = null;
                this.dragCurrentCell = null;
                this.initializeSpreadsheet();
            }

            initializeSpreadsheet() {
                // Add event listeners for spreadsheet functionality
                document.addEventListener('click', this.handleCellClick.bind(this));
                document.addEventListener('keydown', this.handleKeyNavigation.bind(this));
                document.addEventListener('dblclick', this.handleCellDoubleClick.bind(this));
                document.addEventListener('paste', this.handlePaste.bind(this));
                
                // Copy/Paste and Drag-to-fill functionality
                document.addEventListener('keydown', this.handleCopyPaste.bind(this));
                document.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));
            }

            handleCellClick(event) {
                const cell = event.target.closest('.spreadsheet-cell');
                if (!cell) {
                    this.clearSelection();
                    return;
                }

                // Check if this is a SELECT type cell for immediate editing
                const isSelectCell = cell.dataset.type === 'select';
                const isCategoryCell = cell.dataset.type === 'category';
                
                // For category cells, implement hybrid interaction
                if (isCategoryCell) {
                    if (this.selectedCell === cell && !this.editingCell) {
                        // Second click on already selected cell - show dropdown
                        this.startEditingCategory(cell, 'select');
                    } else if (this.editingCell === cell) {
                        // Cell is already being edited - check if we should toggle to dropdown
                        const textEditor = cell.querySelector('.cell-editor-text');
                        const selectEditor = cell.querySelector('.cell-editor-select');
                        
                        // If currently in text mode, switch to dropdown
                        if (textEditor.style.display === 'block') {
                            this.stopEditingCategory();
                            setTimeout(() => {
                                this.startEditingCategory(cell, 'select');
                            }, 10);
                        }
                    } else {
                        // First click - select cell and activate text input
                        this.selectCell(cell);
                        setTimeout(() => {
                            this.startEditingCategory(cell, 'text');
                        }, 10);
                    }
                } else {
                    this.selectCell(cell);
                    
                    // For SELECT elements, start editing immediately on single click
                    if (isSelectCell) {
                        // Prevent the double-click requirement for dropdowns
                        setTimeout(() => {
                            this.startEditing(cell);
                        }, 10);
                    }
                }
            }

            handleCellDoubleClick(event) {
                const cell = event.target.closest('.spreadsheet-cell');
                if (cell) {
                    if (cell.dataset.type === 'category') {
                        // Double click should show dropdown
                        this.startEditingCategory(cell, 'select');
                    } else {
                        this.startEditing(cell);
                    }
                }
            }

            selectCell(cell) {
                // Clear previous selection
                this.clearSelection();
                
                // Set new selection
                this.selectedCell = cell;
                this.selectedCells.clear();
                this.selectedCells.add(cell);
                this.selectionStart = null; // Reset range selection
                
                cell.classList.add('selected');
                cell.setAttribute('tabindex', '0');
                cell.focus();
            }

            clearSelection() {
                if (this.selectedCell) {
                    this.selectedCell.classList.remove('selected');
                    this.selectedCell.removeAttribute('tabindex');
                }
                
                // Clear multi-selection
                this.selectedCells.forEach(cell => {
                    cell.classList.remove('selected', 'multi-selected');
                });
                
                this.selectedCell = null;
                this.selectedCells.clear();
                this.selectionStart = null;
            }

            startEditingCategory(cell, mode) {
                if (this.editingCell) {
                    this.stopEditing();
                }

                this.editingCell = cell;
                cell.classList.add('editing');
                
                const content = cell.querySelector('.cell-content');
                const textEditor = cell.querySelector('.cell-editor-text');
                const selectEditor = cell.querySelector('.cell-editor-select');
                
                // Get current flow data for this cell
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const currentFlow = flowData.flows[row];
                
                content.style.display = 'none';
                
                if (mode === 'text') {
                    // Use text input with autocomplete
                    textEditor.style.display = 'block';
                    selectEditor.style.display = 'none';
                    textEditor.value = currentFlow[col] || '';
                    textEditor.focus();
                    textEditor.select();
                    
                    // Set up autocomplete
                    this.setupCategoryAutocomplete(textEditor, selectEditor);
                    
                    // Add event listeners for text editor
                    textEditor.addEventListener('blur', () => this.stopEditingCategory());
                    textEditor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                } else {
                    // Use select dropdown
                    selectEditor.style.display = 'block';
                    textEditor.style.display = 'none';
                    selectEditor.value = currentFlow[col] || '';
                    selectEditor.focus();
                    
                    // Add event listeners for select editor
                    selectEditor.addEventListener('blur', () => this.stopEditingCategory());
                    selectEditor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                }
            }

            setupCategoryAutocomplete(textEditor, selectEditor) {
                // Get available options from the select element
                const options = Array.from(selectEditor.options).map(option => option.value).filter(v => v);
                
                textEditor.addEventListener('input', (e) => {
                    const value = e.target.value.toLowerCase();
                    if (value.length > 0) {
                        const matches = options.filter(option => option.toLowerCase().includes(value));
                        if (matches.length > 0) {
                            const exactMatch = matches.find(match => match.toLowerCase() === value);
                            if (exactMatch) {
                                textEditor.style.backgroundColor = '#e8f5e8'; // Light green for exact match
                                textEditor.style.borderColor = '#28a745';
                            } else {
                                textEditor.style.backgroundColor = '#fff3cd'; // Light yellow for partial match
                                textEditor.style.borderColor = '#ffc107';
                            }
                        } else {
                            textEditor.style.backgroundColor = '#f8d7da'; // Light red for no match
                            textEditor.style.borderColor = '#dc3545';
                        }
                    } else {
                        textEditor.style.backgroundColor = 'white';
                        textEditor.style.borderColor = '#ddd';
                    }
                });
                
                // Add Tab key support for autocomplete
                textEditor.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const value = textEditor.value.toLowerCase();
                        if (value.length > 0) {
                            const matches = options.filter(option => option.toLowerCase().includes(value));
                            if (matches.length > 0) {
                                // Auto-complete with first match
                                textEditor.value = matches[0];
                                textEditor.style.backgroundColor = '#e8f5e8';
                                textEditor.style.borderColor = '#28a745';
                                textEditor.select();
                            }
                        }
                    } else if (e.key === 'ArrowDown') {
                        // Switch to dropdown mode on arrow down
                        e.preventDefault();
                        const cell = textEditor.closest('.spreadsheet-cell');
                        this.stopEditingCategory();
                        setTimeout(() => {
                            this.startEditingCategory(cell, 'select');
                        }, 10);
                    }
                });
            }

            startEditingHybrid(cell, mode) {
                if (this.editingCell) {
                    this.stopEditing();
                }

                this.editingCell = cell;
                cell.classList.add('editing');
                
                const content = cell.querySelector('.cell-content');
                const textEditor = cell.querySelector('.cell-editor-text');
                const selectEditor = cell.querySelector('.cell-editor-select');
                
                // Get current flow data for this cell
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const currentFlow = flowData.flows[row];
                
                content.style.display = 'none';
                
                if (mode === 'text') {
                    // Use text input
                    textEditor.style.display = 'block';
                    selectEditor.style.display = 'none';
                    textEditor.value = currentFlow[col] || '';
                    textEditor.focus();
                    textEditor.select();
                    
                    // Add event listeners for text editor
                    textEditor.addEventListener('blur', () => this.stopEditingHybrid(), { once: true });
                    textEditor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                } else {
                    // Use select dropdown
                    selectEditor.style.display = 'block';
                    textEditor.style.display = 'none';
                    selectEditor.value = currentFlow[col] || '';
                    selectEditor.focus();
                    
                    // Add event listeners for select editor
                    selectEditor.addEventListener('blur', () => this.stopEditingHybrid(), { once: true });
                    selectEditor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                }
            }

            startEditing(cell) {
                if (this.editingCell) {
                    this.stopEditing();
                }

                this.editingCell = cell;
                cell.classList.add('editing');
                
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Get current flow data for this cell
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const currentFlow = flowData.flows[row];
                
                // Set editor value from flow data (not display text)
                if (editor.tagName === 'SELECT') {
                    editor.value = currentFlow[col];
                } else {
                    // For number inputs, handle the 0 default value issue
                    if (editor.type === 'number' && (col === 'value' || col === 'previousValue')) {
                        const currentValue = currentFlow[col];
                        // If the value is 0 and it's a previousValue, set empty string
                        if (currentValue === 0 && col === 'previousValue') {
                            editor.value = '';
                        } else {
                            editor.value = currentValue;
                        }
                    } else {
                        editor.value = currentFlow[col];
                    }
                }
                
                // Show editor and hide content
                content.style.display = 'none';
                editor.style.display = 'block';
                editor.focus();
                
                // Select all text for quick editing - now works for number inputs too
                if (editor.tagName !== 'SELECT') {
                    // For number inputs, select all text
                    if (editor.type === 'number') {
                        editor.select();
                    } else {
                        editor.select();
                    }
                }

                // Add event listeners with enhanced cross-browser SELECT element handling
                if (editor.tagName === 'SELECT') {
                    // Cross-browser dropdown fix: Force dropdown to open and stay open
                    const openDropdown = () => {
                        // Force focus first
                        editor.focus();
                        
                        // For WebKit browsers (Safari, Chrome), trigger the dropdown
                        if (editor.showPicker && typeof editor.showPicker === 'function') {
                            try {
                                editor.showPicker();
                            } catch (e) {
                                // Fallback for older browsers
                                editor.click();
                            }
                        } else {
                            // Fallback: simulate click to open dropdown
                            const clickEvent = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                view: window
                            });
                            editor.dispatchEvent(clickEvent);
                        }
                    };
                    
                    // Delay opening to ensure proper rendering
                    setTimeout(openDropdown, 20);
                    
                    // Prevent event bubbling that could close the dropdown
                    editor.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                    });
                    
                    editor.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    
                    // Handle selection change
                    editor.addEventListener('change', () => {
                        this.stopEditing();
                    }, { once: true });
                    
                    editor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                    
                    // Enhanced blur handling for SELECT stability
                    let blurTimeout;
                    let isInteracting = false;
                    
                    editor.addEventListener('mousedown', () => {
                        isInteracting = true;
                        if (blurTimeout) {
                            clearTimeout(blurTimeout);
                            blurTimeout = null;
                        }
                    });
                    
                    editor.addEventListener('mouseup', () => {
                        setTimeout(() => {
                            isInteracting = false;
                        }, 50);
                    });
                    
                    editor.addEventListener('blur', (e) => {
                        if (blurTimeout) clearTimeout(blurTimeout);
                        
                        blurTimeout = setTimeout(() => {
                            if (!isInteracting && document.activeElement !== editor) {
                                this.stopEditing();
                            }
                        }, 300); // Increased delay for better stability
                    }, { once: true });
                    
                    // Restore focus if dropdown was accidentally closed
                    editor.addEventListener('focus', () => {
                        if (blurTimeout) {
                            clearTimeout(blurTimeout);
                            blurTimeout = null;
                        }
                    });
                } else {
                    editor.addEventListener('blur', () => this.stopEditing(), { once: true });
                    editor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                }
            }

            stopEditingCategory() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const textEditor = cell.querySelector('.cell-editor-text');
                const selectEditor = cell.querySelector('.cell-editor-select');
                
                // Get cell data attributes
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                
                let newValue = '';
                
                // Determine which editor is active
                if (textEditor.style.display !== 'none') {
                    newValue = textEditor.value;
                    textEditor.style.backgroundColor = 'white'; // Reset background color
                } else if (selectEditor.style.display !== 'none') {
                    newValue = selectEditor.value;
                }
                
                // Update content display
                content.textContent = newValue;
                content.style.display = 'flex';
                
                // Hide editors
                textEditor.style.display = 'none';
                selectEditor.style.display = 'none';
                
                // Update the flow data
                if (flowData.flows[row] && col) {
                    flowData.flows[row][col] = newValue;
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    
                    // Live update - trigger chart update immediately
                    updateAllStats();
                    refreshChart();
                }
                
                cell.classList.remove('editing');
                this.editingCell = null;
                cell.focus();
            }

            stopEditingHybrid() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const textEditor = cell.querySelector('.cell-editor-text');
                const selectEditor = cell.querySelector('.cell-editor-select');
                
                // Get cell data attributes
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                
                let newValue = '';
                let activeEditor = null;
                
                // Determine which editor is active
                if (textEditor.style.display !== 'none') {
                    activeEditor = textEditor;
                    newValue = textEditor.value;
                } else if (selectEditor.style.display !== 'none') {
                    activeEditor = selectEditor;
                    newValue = selectEditor.value;
                }
                
                // Update content display
                content.textContent = newValue;
                content.style.display = 'flex';
                
                // Hide editors
                textEditor.style.display = 'none';
                selectEditor.style.display = 'none';
                
                // Update the flow data
                if (flowData.flows[row] && col) {
                    flowData.flows[row][col] = newValue;
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    
                    // Live update - trigger chart update immediately
                    updateAllStats();
                    refreshChart();
                }
                
                cell.classList.remove('editing');
                this.editingCell = null;
                cell.focus();
            }

            stopEditing() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Get cell data attributes
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const type = cell.dataset.type;
                
                let newValue = editor.value;
                
                // Update content with editor value and format based on type
                if (editor.tagName === 'SELECT') {
                    const selectedOption = editor.options[editor.selectedIndex];
                    content.textContent = selectedOption.text;
                    newValue = selectedOption.value;
                } else {
                    if (type === 'number') {
                        newValue = parseFloat(editor.value) || 0;
                        // Format numbers with commas for display
                        content.textContent = newValue > 0 ? newValue.toLocaleString() : (newValue === 0 ? '0' : '');
                    } else {
                        content.textContent = editor.value || '';
                    }
                }
                
                // Update the flow data
                if (flowData.flows[row] && col) {
                    flowData.flows[row][col] = newValue;
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    
                    // Live update - trigger chart update immediately
                    updateAllStats();
                    refreshChart();
                    
                    // Update variance display if this was a value change
                    if (col === 'value' || col === 'previousValue') {
                        const varianceCell = cell.closest('tr').querySelector('.variance-cell div');
                        if (varianceCell) {
                            varianceCell.textContent = flowData.flows[row].getVarianceDisplay();
                            // Apply colors immediately after updating variance display
                            const variance = flowData.flows[row].getVariance();
                            varianceCell.className = ''; // Clear existing classes
                            
                            if (variance.trend === 'up') {
                                varianceCell.classList.add('variance-positive');
                                varianceCell.style.color = '#16a34a';
                                varianceCell.style.fontWeight = '700';
                            } else if (variance.trend === 'down') {
                                varianceCell.classList.add('variance-negative');
                                varianceCell.style.color = '#dc2626';
                                varianceCell.style.fontWeight = '700';
                            } else {
                                varianceCell.classList.add('variance-neutral');
                                varianceCell.style.color = '#6b7280';
                                varianceCell.style.fontWeight = '600';
                            }
                        }
                    }
                }
                
                // Hide editor and show content
                editor.style.display = 'none';
                content.style.display = 'flex';
                
                cell.classList.remove('editing');
                this.editingCell = null;
                
                // Return focus to cell
                cell.focus();
            }

            handleEditorKeys(event) {
                switch (event.key) {
                    case 'Enter':
                        event.preventDefault();
                        this.stopEditingCell();
                        // Add small delay to prevent auto-editing next cell
                        setTimeout(() => {
                            this.moveSelection('down');
                        }, 10);
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.cancelEditing();
                        break;
                    case 'Tab':
                        event.preventDefault();
                        this.stopEditingCell();
                        this.moveSelection(event.shiftKey ? 'left' : 'right');
                        break;
                }
            }

            stopEditingCell() {
                if (!this.editingCell) return;
                
                const cell = this.editingCell;
                const cellType = cell.dataset.type;
                
                // Call the appropriate stop editing method based on cell type
                if (cellType === 'category') {
                    this.stopEditingCategory();
                } else if (cellType === 'hybrid') {
                    this.stopEditingHybrid();
                } else {
                    this.stopEditing();
                }
            }

            cancelEditing() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Don't update content, just hide editor
                editor.style.display = 'none';
                content.style.display = 'flex';
                
                cell.classList.remove('editing');
                this.editingCell = null;
                cell.focus();
            }

            handleKeyNavigation(event) {
                if (!this.selectedCell || this.editingCell) {
                    return;
                }

                switch (event.key) {
                    case 'ArrowUp':
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.extendSelection('up');
                        } else {
                            this.moveSelection('up');
                        }
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.extendSelection('down');
                        } else {
                            this.moveSelection('down');
                        }
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.extendSelection('left');
                        } else {
                            this.moveSelection('left');
                        }
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        if (event.shiftKey) {
                            this.extendSelection('right');
                        } else {
                            this.moveSelection('right');
                        }
                        break;
                    case 'Enter':
                        event.preventDefault();
                        // Only start editing if user explicitly presses Enter on a selected cell
                        // Don't auto-edit when navigating with Enter from editing mode
                        if (this.selectedCell && !this.editingCell) {
                            if (this.selectedCell.dataset.type === 'category') {
                                this.startEditingCategory(this.selectedCell, 'text');
                            } else {
                                this.startEditing(this.selectedCell);
                            }
                        }
                        break;
                    case 'F2':
                        event.preventDefault();
                        if (this.selectedCell.dataset.type === 'category') {
                            this.startEditingCategory(this.selectedCell, 'text');
                        } else {
                            this.startEditing(this.selectedCell);
                        }
                        break;
                    case 'Delete':
                    case 'Backspace':
                        event.preventDefault();
                        this.clearCellContent();
                        break;
                    case 'Tab':
                        event.preventDefault();
                        this.moveSelection(event.shiftKey ? 'left' : 'right');
                        break;
                    default:
                        // Start editing on alphanumeric key press
                        if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
                            if (this.selectedCell.dataset.type === 'category') {
                                this.startEditingCategory(this.selectedCell, 'text');
                            } else {
                                this.startEditing(this.selectedCell);
                            }
                        }
                        break;
                }
            }

            moveSelection(direction) {
                if (!this.selectedCell) return;

                const currentRow = this.selectedCell.closest('tr');
                const currentCellIndex = Array.from(currentRow.children).indexOf(this.selectedCell);
                let targetCell = null;

                switch (direction) {
                    case 'up':
                        const prevRow = currentRow.previousElementSibling;
                        if (prevRow) {
                            targetCell = prevRow.children[currentCellIndex];
                        }
                        break;
                    case 'down':
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) {
                            targetCell = nextRow.children[currentCellIndex];
                        }
                        break;
                    case 'left':
                        const prevCell = this.selectedCell.previousElementSibling;
                        if (prevCell && prevCell.classList.contains('spreadsheet-cell')) {
                            targetCell = prevCell;
                        }
                        break;
                    case 'right':
                        const nextCell = this.selectedCell.nextElementSibling;
                        if (nextCell && nextCell.classList.contains('spreadsheet-cell')) {
                            targetCell = nextCell;
                        }
                        break;
                }

                if (targetCell && targetCell.classList.contains('spreadsheet-cell')) {
                    this.selectCell(targetCell);
                }
            }

            extendSelection(direction) {
                if (!this.selectedCell) return;

                // Initialize selection range if this is the first extend
                if (!this.selectionStart) {
                    this.selectionStart = this.selectedCell;
                    this.selectedCells.add(this.selectedCell);
                }

                const currentRow = this.selectedCell.closest('tr');
                const currentCellIndex = Array.from(currentRow.children).indexOf(this.selectedCell);
                let targetCell = null;

                switch (direction) {
                    case 'up':
                        const prevRow = currentRow.previousElementSibling;
                        if (prevRow) {
                            targetCell = prevRow.children[currentCellIndex];
                        }
                        break;
                    case 'down':
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) {
                            targetCell = nextRow.children[currentCellIndex];
                        }
                        break;
                    case 'left':
                        const prevCell = this.selectedCell.previousElementSibling;
                        if (prevCell && prevCell.classList.contains('spreadsheet-cell')) {
                            targetCell = prevCell;
                        }
                        break;
                    case 'right':
                        const nextCell = this.selectedCell.nextElementSibling;
                        if (nextCell && nextCell.classList.contains('spreadsheet-cell')) {
                            targetCell = nextCell;
                        }
                        break;
                }

                if (targetCell && targetCell.classList.contains('spreadsheet-cell')) {
                    this.selectedCell = targetCell;
                    this.updateSelectionRange();
                }
            }

            updateSelectionRange() {
                if (!this.selectionStart || !this.selectedCell) return;

                // Clear current selection display
                this.selectedCells.forEach(cell => {
                    cell.classList.remove('selected', 'multi-selected');
                });
                this.selectedCells.clear();

                // Get start and end coordinates
                const startRow = parseInt(this.selectionStart.dataset.row);
                const startCol = this.getCellColumnIndex(this.selectionStart);
                const endRow = parseInt(this.selectedCell.dataset.row);
                const endCol = this.getCellColumnIndex(this.selectedCell);

                // Calculate selection bounds
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                const minCol = Math.min(startCol, endCol);
                const maxCol = Math.max(startCol, endCol);

                // Select all cells in range
                const table = this.selectedCell.closest('table');
                const rows = table.querySelectorAll('tbody tr');
                
                for (let r = minRow; r <= maxRow; r++) {
                    if (rows[r]) {
                        const cells = rows[r].querySelectorAll('.spreadsheet-cell');
                        for (let c = minCol; c <= maxCol; c++) {
                            if (cells[c]) {
                                this.selectedCells.add(cells[c]);
                                cells[c].classList.add('multi-selected');
                            }
                        }
                    }
                }

                // Highlight current active cell
                this.selectedCell.classList.add('selected');
            }

            getCellColumnIndex(cell) {
                if (!cell) return -1;
                
                const row = cell.closest('tr');
                if (!row) return -1;
                
                const cells = row.querySelectorAll('.spreadsheet-cell');
                if (!cells) return -1;
                
                return Array.from(cells).indexOf(cell);
            }

            clearCellContent() {
                if (!this.selectedCell) return;
                
                const content = this.selectedCell.querySelector('.cell-content');
                const row = parseInt(this.selectedCell.dataset.row);
                const col = this.selectedCell.dataset.col;
                const type = this.selectedCell.dataset.type;
                
                // Clear display
                content.textContent = '';
                
                // Clear data based on type
                if (flowData.flows[row] && col) {
                    if (type === 'number') {
                        flowData.flows[row][col] = 0;
                        content.textContent = '0';
                    } else {
                        flowData.flows[row][col] = '';
                    }
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    updateAllStats();
                    debouncedRealTimeUpdate();
                }
            }

            // ===== ENHANCED EXCEL/CSV PASTE FUNCTIONALITY =====
            handlePaste(event) {
                console.log('📋 OLD SpreadsheetController: Paste event detected', event);
                
                // More aggressive paste detection
                const target = event.target;
                const cell = target.closest('.spreadsheet-cell');
                const table = target.closest('.flow-table');
                
                // Handle paste if we have a selected cell OR if event is within flow table
                const shouldHandle = cell || table || this.selectedCell;
                
                console.log('📋 OLD SpreadsheetController: Should handle paste?', shouldHandle);
                
                if (!shouldHandle) {
                    console.log('📋 OLD SpreadsheetController: Ignoring paste - not in flow table area');
                    return; // Not in our spreadsheet
                }

                console.log('📋 OLD SpreadsheetController: Handling paste event');
                event.preventDefault();
                
                // Get clipboard data
                const clipboardData = event.clipboardData || window.clipboardData;
                const pastedText = clipboardData.getData('text');
                
                if (!pastedText) {
                    return;
                }

                
                // Determine starting cell
                let startCell = cell || this.selectedCell;
                if (!startCell) {
                    // Find first cell if none selected
                    startCell = document.querySelector('.spreadsheet-cell[data-row="0"][data-col="source"]');
                }
                
                if (!startCell) {
                    console.error('❌ No starting cell found for paste operation');
                    return;
                }

                try {
                    this.pasteDataToTable(pastedText, startCell);
                } catch (error) {
                    console.error('❌ Paste operation failed:', error);
                    this.showPasteError(error.message);
                }
            }

            pasteDataToTable(pastedText, startCell) {
                // Parse the pasted data (could be CSV, TSV, or simple text)
                const parsedData = this.parseClipboardData(pastedText);
                
                if (parsedData.length === 0) {
                    throw new Error('No valid data found in clipboard');
                }


                // Get starting position
                const startRow = parseInt(startCell.dataset.row);
                const startCol = startCell.dataset.col;
                
                // Define column mapping for flow data
                const columnMap = {
                    'source': 0,
                    'target': 1, 
                    'value': 2,
                    'previousValue': 3,
                    'description': 4
                };
                
                const columnOrder = ['source', 'target', 'value', 'previousValue', 'description'];
                const startColIndex = columnOrder.indexOf(startCol);
                
                if (startColIndex === -1) {
                    throw new Error(`Invalid starting column: ${startCol}`);
                }

                // Process each row of pasted data
                let rowsProcessed = 0;
                let cellsUpdated = 0;

                for (let i = 0; i < parsedData.length; i++) {
                    const dataRow = parsedData[i];
                    const targetRowIndex = startRow + i;
                    
                    // Ensure we have enough flow rows
                    while (flowData.flows.length <= targetRowIndex) {
                        this.addNewFlowRow();
                    }
                    
                    // Process each column in the data row
                    for (let j = 0; j < dataRow.length; j++) {
                        const targetColIndex = startColIndex + j;
                        
                        if (targetColIndex >= columnOrder.length) {
                            continue; // Skip columns beyond our table
                        }
                        
                        const targetCol = columnOrder[targetColIndex];
                        const cellValue = dataRow[j];
                        
                        if (cellValue !== null && cellValue !== '') {
                            this.updateCellValue(targetRowIndex, targetCol, cellValue);
                            cellsUpdated++;
                        }
                    }
                    rowsProcessed++;
                }

                // Update statistics and chart first
                autoCalculateFlowProperties();
                updateAllStats();
                
                // Force refresh the entire table to show the pasted data
                // Clear any cached state and force a complete re-render
                document.getElementById('flows-tbody').innerHTML = '';
                renderFlowTable();
                
                // Trigger chart update
                debouncedRealTimeUpdate();
                
                // Additional debug: log table state
                
                // Show success message
                this.showPasteSuccess(rowsProcessed, cellsUpdated);
                
            }

            parseClipboardData(text) {
                // Split into lines and remove empty lines
                const lines = text.split(/\r?\n/).filter(line => line.trim());
                
                if (lines.length === 0) {
                    return [];
                }

                // Detect delimiter (tab, comma, or semicolon)
                const firstLine = lines[0];
                let delimiter = '\t'; // Default to tab (Excel/Google Sheets)
                
                if (firstLine.includes('\t')) {
                    delimiter = '\t';
                } else if (firstLine.includes(',')) {
                    delimiter = ',';
                } else if (firstLine.includes(';')) {
                    delimiter = ';';
                }


                // Parse each line
                return lines.map(line => {
                    return line.split(delimiter).map(cell => {
                        // Clean up the cell value
                        let value = cell.trim();
                        
                        // Remove quotes if present
                        if ((value.startsWith('"') && value.endsWith('"')) || 
                            (value.startsWith("'") && value.endsWith("'"))) {
                            value = value.slice(1, -1);
                        }
                        
                        // Convert numeric values
                        if (/^\d+\.?\d*$/.test(value)) {
                            return parseFloat(value);
                        }
                        
                        return value;
                    });
                });
            }

            updateCellValue(rowIndex, columnName, value) {
                // Validate the value based on column type
                let processedValue = value;
                
                switch (columnName) {
                    case 'value':
                    case 'previousValue':
                        processedValue = parseFloat(value) || 0;
                        break;
                    default:
                        processedValue = value.toString();
                }
                
                // Update the flow data
                if (flowData.flows[rowIndex]) {
                    flowData.flows[rowIndex][columnName] = processedValue;
                }
            }

            addNewFlowRow() {
                // Add a new empty flow to the data
                const newFlow = new BusinessFlow({
                    id: `flow_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    source: '',
                    target: '',
                    value: 0,
                    flowType: 'revenue_flow',
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceOrder: 1,
                    targetOrder: 1,
                    sourceCategory: 'revenue',
                    targetCategory: 'revenue',
                    description: ''
                });
                
                flowData.flows.push(newFlow);
            }

            showPasteSuccess(rows, cells) {
                const message = `✅ Successfully pasted ${rows} row${rows !== 1 ? 's' : ''} and updated ${cells} cell${cells !== 1 ? 's' : ''}`;
                this.showToast(message, 'success');
            }

            showPasteError(errorMessage) {
                const message = `❌ Paste failed: ${errorMessage}`;
                this.showToast(message, 'error');
            }

            showToast(message, type = 'info') {
                // Create a toast notification
                const toast = document.createElement('div');
                toast.className = `paste-toast paste-toast-${type}`;
                toast.textContent = message;
                
                // Add styles
                Object.assign(toast.style, {
                    position: 'fixed',
                    top: '20px',
                    right: '20px',
                    background: type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6',
                    color: 'white',
                    padding: '12px 20px',
                    borderRadius: '8px',
                    fontSize: '14px',
                    fontWeight: '500',
                    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
                    zIndex: '10000',
                    opacity: '0',
                    transform: 'translateX(100%)',
                    transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                });
                
                document.body.appendChild(toast);
                
                // Animate in
                setTimeout(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translateX(0)';
                }, 10);
                
                // Animate out and remove
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            document.body.removeChild(toast);
                        }
                    }, 300);
                }, 3000);
            }

            // ===== GOOGLE SHEETS-LIKE COPY/PASTE FUNCTIONALITY =====
            
            handleCopyPaste(event) {
                // Enhanced copy/paste handling
                if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
                    if (this.selectedCell) {
                        event.preventDefault();
                        console.log('📋 OLD SpreadsheetController: Copy detected');
                        this.copyCells();
                    }
                } else if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
                    console.log('📋 OLD SpreadsheetController: 🚨 CTRL+V DETECTED 🚨');
                    console.log('📋 OLD SpreadsheetController: Selected cell:', this.selectedCell);
                    
                    // Handle paste if we have ANY selected cell OR if we're in the flow table area
                    const shouldHandle = this.selectedCell || document.querySelector('.flow-table:hover');
                    
                    if (shouldHandle) {
                        event.preventDefault();
                        console.log('📋 OLD SpreadsheetController: 🎯 HANDLING CTRL+V');
                        
                        // Try async clipboard API first (more reliable for external data)
                        navigator.clipboard.readText().then(text => {
                            if (text && text.trim()) {
                                console.log('📋 OLD SpreadsheetController: ✅ Got external clipboard data:', text.substring(0, 100) + '...');
                                this.pasteDataToTable(text, this.selectedCell);
                            } else {
                                console.log('📋 OLD SpreadsheetController: No async clipboard data, using internal paste');
                                this.pasteCells();
                            }
                        }).catch(err => {
                            console.log('📋 OLD SpreadsheetController: Async clipboard failed, using internal paste:', err);
                            this.pasteCells();
                        });
                    } else {
                        console.log('📋 OLD SpreadsheetController: ❌ Not handling paste - no selected cell');
                    }
                }
            }
            
            copyCells() {
                if (this.selectedCells.size === 0) return;
                
                // Clear previous copied cell styling
                this.copiedCells.forEach(cell => {
                    cell.classList.remove('copied');
                });
                this.copiedCells.clear();
                
                // Copy current selection
                this.selectedCells.forEach(cell => {
                    this.copiedCells.add(cell);
                    cell.classList.add('copied');
                });
                
                // Create clipboard content
                const clipboardData = this.createClipboardData();
                navigator.clipboard.writeText(clipboardData).catch(() => {
                });
                
                const count = this.copiedCells.size;
                const message = count === 1 ? 'Cell copied!' : `${count} cells copied!`;
                
                // Remove copied styling after 3 seconds
                setTimeout(() => {
                    this.copiedCells.forEach(cell => {
                        cell.classList.remove('copied');
                    });
                }, 3000);
            }
            
            pasteCells() {
                if (!this.selectedCell || this.copiedCells.size === 0) return;
                
                // Get paste target area
                const pasteStartRow = parseInt(this.selectedCell.dataset.row);
                const pasteStartCol = this.getCellColumnIndex(this.selectedCell);
                
                // Validate starting position
                if (isNaN(pasteStartRow) || pasteStartCol < 0) return;
                
                // Get copied data dimensions
                const copiedArray = Array.from(this.copiedCells);
                const copiedRows = new Set();
                const copiedCols = new Set();
                
                // Filter out invalid cells
                const validCopiedCells = copiedArray.filter(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = this.getCellColumnIndex(cell);
                    if (!isNaN(row) && col >= 0) {
                        copiedRows.add(row);
                        copiedCols.add(col);
                        return true;
                    }
                    return false;
                });
                
                if (validCopiedCells.length === 0) return;
                
                const minCopiedRow = Math.min(...copiedRows);
                const minCopiedCol = Math.min(...copiedCols);
                
                let pastedCount = 0;
                
                // Paste each copied cell with relative offset
                validCopiedCells.forEach((sourceCell, index) => {
                    const sourceRow = parseInt(sourceCell.dataset.row);
                    const sourceCol = this.getCellColumnIndex(sourceCell);
                    
                    // Skip if invalid (extra safety check)
                    if (isNaN(sourceRow) || sourceCol < 0) return;
                    
                    // Calculate relative position
                    const rowOffset = sourceRow - minCopiedRow;
                    const colOffset = sourceCol - minCopiedCol;
                    
                    // Find target cell
                    const targetRow = pasteStartRow + rowOffset;
                    const targetCol = pasteStartCol + colOffset;
                    
                    const targetCell = this.getCellAt(targetRow, targetCol);
                    if (targetCell) {
                        const sourceValue = this.getCellValue(sourceCell);
                        this.setCellValue(targetCell, sourceValue);
                        pastedCount++;
                    }
                });
                
                // Simple chart update after all cells are pasted (no table rebuild needed)
                if (pastedCount > 0) {
                    debouncedRealTimeUpdate();
                }
                
                const message = pastedCount === 1 ? 'Cell pasted!' : `${pastedCount} cells pasted!`;
            }

            createClipboardData() {
                if (this.copiedCells.size === 0) return '';
                
                // Group cells by row
                const cellsByRow = new Map();
                this.copiedCells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    if (!cellsByRow.has(row)) {
                        cellsByRow.set(row, []);
                    }
                    cellsByRow.get(row).push(cell);
                });
                
                // Sort rows and create tab-separated data
                const sortedRows = Array.from(cellsByRow.keys()).sort((a, b) => a - b);
                const clipboardRows = [];
                
                sortedRows.forEach(rowNum => {
                    const rowCells = cellsByRow.get(rowNum);
                    rowCells.sort((a, b) => this.getCellColumnIndex(a) - this.getCellColumnIndex(b));
                    
                    const rowData = rowCells.map(cell => this.getCellValue(cell));
                    clipboardRows.push(rowData.join('\t'));
                });
                
                return clipboardRows.join('\n');
            }

            getCellAt(row, col) {
                if (!this.selectedCell) return null;
                
                const table = this.selectedCell.closest('table');
                if (!table) return null;
                
                const rows = table.querySelectorAll('tbody tr');
                if (!rows || row < 0 || row >= rows.length) return null;
                
                const targetRow = rows[row];
                if (!targetRow) return null;
                
                const cells = targetRow.querySelectorAll('.spreadsheet-cell');
                if (!cells || col < 0 || col >= cells.length) return null;
                
                return cells[col] || null;
            }
            
            getCellValue(cell) {
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const flow = flowData.flows[row];
                
                if (!flow) return '';
                
                return flow[col] || '';
            }
            
            setCellValue(cell, value) {
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const type = cell.dataset.type;
                
                if (!flowData.flows[row]) return;
                
                // Type conversion based on cell type
                let processedValue = value;
                if (type === 'number') {
                    processedValue = parseFloat(value) || 0;
                } else {
                    processedValue = value.toString();
                }
                
                // Update flow data
                flowData.flows[row][col] = processedValue;
                
                // Update display
                const cellContent = cell.querySelector('.cell-content');
                if (cellContent) {
                    if (type === 'number' && processedValue !== 0) {
                        cellContent.textContent = processedValue.toLocaleString();
                    } else {
                        cellContent.textContent = processedValue;
                    }
                }
                
                // Auto-recalculate variance if value or previousValue changed
                if (col === 'value' || col === 'previousValue') {
                    this.updateVarianceForRow(row);
                }
            }
            
            updateVarianceForRow(rowIndex) {
                const flow = flowData.flows[rowIndex];
                if (!flow) return;
                
                // Find the variance cell for this row (more robust selector)
                const table = document.querySelector('#main-flow-table tbody');
                if (!table) return;
                
                const tableRows = table.querySelectorAll('tr');
                const tableRow = tableRows[rowIndex];
                if (!tableRow) return;
                
                const varianceCell = tableRow.querySelector('.variance-cell');
                if (!varianceCell) return;
                
                // Update variance display
                const varianceDiv = varianceCell.querySelector('div');
                if (varianceDiv) {
                    const isEmpty = !flow.source && !flow.target && flow.value === 0;
                    varianceDiv.textContent = isEmpty ? '' : flow.getVarianceDisplay();
                    
                    // Apply variance colors
                    const variance = flow.getVariance();
                    
                    // Clear existing classes
                    varianceDiv.className = '';
                    varianceDiv.style.color = '';
                    varianceDiv.style.fontWeight = '';
                    
                    // Apply color based on variance trend
                    if (variance.trend === 'up') {
                        varianceDiv.style.color = '#16a34a';
                        varianceDiv.style.fontWeight = '700';
                    } else if (variance.trend === 'down') {
                        varianceDiv.style.color = '#dc2626';
                        varianceDiv.style.fontWeight = '700';
                    } else {
                        varianceDiv.style.color = '#6b7280';
                        varianceDiv.style.fontWeight = '600';
                    }
                }
            }
            
            updateFlowData(cell) {
                // Trigger the same updates as cell editing
                autoCalculateFlowProperties();
                updateAllStats();
                
                // Re-render the table to show changes (like normal cell editing does)
                renderFlowTable();
                
                // Trigger chart update
                debouncedRealTimeUpdate();
            }
            
            // ===== DRAG-TO-FILL FUNCTIONALITY =====
            
            handleMouseDown(event) {
                const cell = event.target.closest('.spreadsheet-cell');
                if (!cell || !cell.classList.contains('selected')) return;
                
                // Check if clicking on the drag handle (bottom-right corner)
                const rect = cell.getBoundingClientRect();
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                const handleSize = 6;
                
                const isOnHandle = (
                    mouseX >= rect.right - handleSize - 2 &&
                    mouseX <= rect.right + 2 &&
                    mouseY >= rect.bottom - handleSize - 2 &&
                    mouseY <= rect.bottom + 2
                );
                
                if (isOnHandle) {
                    event.preventDefault();
                    this.startDragFill(cell, event);
                }
            }
            
            startDragFill(cell, event) {
                this.isDragging = true;
                this.dragStartCell = cell;
                this.dragCurrentCell = cell;
                
                document.body.style.cursor = 'crosshair';
                event.preventDefault();
            }
            
            handleMouseMove(event) {
                if (!this.isDragging) return;
                
                const cell = event.target.closest('.spreadsheet-cell');
                if (!cell) return;
                
                // Clear previous fill range
                this.clearFillRange();
                
                this.dragCurrentCell = cell;
                this.highlightFillRange();
            }
            
            handleMouseUp(event) {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                document.body.style.cursor = '';
                
                if (this.dragCurrentCell && this.dragCurrentCell !== this.dragStartCell) {
                    this.performDragFill();
                }
                
                this.clearFillRange();
                this.dragStartCell = null;
                this.dragCurrentCell = null;
            }
            
            highlightFillRange() {
                if (!this.dragStartCell || !this.dragCurrentCell) return;
                
                const startRow = parseInt(this.dragStartCell.dataset.row);
                const startCol = this.dragStartCell.dataset.col;
                const endRow = parseInt(this.dragCurrentCell.dataset.row);
                const endCol = this.dragCurrentCell.dataset.col;
                
                // For now, only support vertical fill (same column)
                if (startCol !== endCol) return;
                
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                
                for (let row = minRow; row <= maxRow; row++) {
                    const targetCell = document.querySelector(`[data-row="${row}"][data-col="${startCol}"]`);
                    if (targetCell) {
                        targetCell.classList.add('fill-range');
                    }
                }
            }
            
            clearFillRange() {
                document.querySelectorAll('.fill-range').forEach(cell => {
                    cell.classList.remove('fill-range');
                });
            }
            
            performDragFill() {
                if (!this.dragStartCell || !this.dragCurrentCell) return;
                
                const startRow = parseInt(this.dragStartCell.dataset.row);
                const startCol = this.dragStartCell.dataset.col;
                const endRow = parseInt(this.dragCurrentCell.dataset.row);
                const endCol = this.dragCurrentCell.dataset.col;
                
                // Only support vertical fill for now
                if (startCol !== endCol) {
                    return;
                }
                
                const sourceValue = this.getCellValue(this.dragStartCell);
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                
                let fillCount = 0;
                for (let row = minRow; row <= maxRow; row++) {
                    if (row === startRow) continue; // Skip source cell
                    
                    const targetCell = document.querySelector(`[data-row="${row}"][data-col="${startCol}"]`);
                    if (targetCell) {
                        // Smart fill: try to detect patterns for numbers
                        let fillValue = sourceValue;
                        if (this.dragStartCell.dataset.type === 'number' && !isNaN(parseFloat(sourceValue))) {
                            // For numbers, we could implement pattern detection
                            // For now, just copy the same value
                            fillValue = sourceValue;
                        }
                        
                        this.setCellValue(targetCell, fillValue);
                        fillCount++;
                    }
                }
                
                if (fillCount > 0) {
                    // Update data after filling
                    autoCalculateFlowProperties();
                    updateAllStats();
                    
                    // Re-render the table to show changes
                    renderFlowTable();
                    
                    // Trigger chart update
                    debouncedRealTimeUpdate();
                }
            }
            
        }

        // ===== UNIFIED DROPDOWN SYSTEM (IIFE PATTERN) =====
        
        (function() {
            'use strict';
            
            let initialized = false;
            
            // Unified dropdown manager
            const DropdownManager = {
                dropdowns: new Map(),
                
                init() {
                    if (initialized) {
                        this.cleanup();
                    }
                    
                    
                    // Initialize control menu dropdowns (data, style, layout, etc.)
                    this.initializeControlMenus();
                    
                    // Initialize export dropdown (separate system)
                    this.initializeExportDropdown();
                    
                    // Set up global click handler
                    this.setupGlobalEvents();
                    
                    initialized = true;
                },
                
                initializeControlMenus() {
                    const menuTriggers = document.querySelectorAll('.horizontal-controls-menu .menu-trigger');
                    const menuDropdowns = document.querySelectorAll('.horizontal-controls-menu .menu-dropdown');
                    
                    if (menuTriggers.length === 0) {
                        setTimeout(() => this.init(), 100);
                        return;
                    }
                    
                    menuTriggers.forEach(trigger => {
                        const target = trigger.getAttribute('data-target');
                        const dropdown = document.getElementById(`${target}-dropdown`);
                        const section = trigger.closest('.menu-section');
                        
                        if (!dropdown || !section) {
                            console.warn(`⚠️ Invalid menu structure for target: ${target}`);
                            return;
                        }
                        
                        // Store dropdown info
                        this.dropdowns.set(trigger, {
                            type: 'menu',
                            target,
                            dropdown,
                            section,
                            isOpen: false
                        });
                        
                        // Add click handler
                        trigger.addEventListener('click', (e) => this.handleMenuClick(e, trigger));
                    });
                    
                },
                
                initializeExportDropdown() {
                    const exportTrigger = document.getElementById('export-trigger');
                    const exportMenu = document.getElementById('export-menu');
                    
                    if (!exportTrigger || !exportMenu) {
                        return;
                    }
                    
                    // Store export dropdown info
                    this.dropdowns.set(exportTrigger, {
                        type: 'export',
                        target: 'export',
                        dropdown: exportMenu,
                        section: null,
                        isOpen: false
                    });
                    
                    // Add click handler
                    exportTrigger.addEventListener('click', (e) => this.handleExportClick(e, exportTrigger));
                    
                    // Handle export option clicks
                    const exportOptions = exportMenu.querySelectorAll('.export-option');
                    exportOptions.forEach(option => {
                        option.addEventListener('click', (e) => {
                            e.stopPropagation();
                            option.classList.add('loading');
                            setTimeout(() => option.classList.remove('loading'), 2000);
                        });
                    });
                    
                },
                
                handleMenuClick(e, trigger) {
                    e.stopPropagation();
                    
                    const info = this.dropdowns.get(trigger);
                    if (!info) return;
                    
                    const { target, dropdown, section } = info;
                    
                    // Close all other dropdowns
                    this.closeAllExcept(dropdown);
                    
                    // Toggle current dropdown
                    const isOpen = dropdown.classList.contains('active');
                    
                    if (isOpen) {
                        this.closeDropdown(dropdown, section, trigger);
                        info.isOpen = false;
                    } else {
                        this.openDropdown(dropdown, section, trigger);
                        info.isOpen = true;
                        
                        // Debug content
                        const content = dropdown.querySelector('.dropdown-content');
                        if (content) {
                        }
                    }
                },
                
                handleExportClick(e, trigger) {
                    e.stopPropagation();
                    
                    const info = this.dropdowns.get(trigger);
                    if (!info) return;
                    
                    const { dropdown } = info;
                    
                    // Close all other dropdowns
                    this.closeAllExcept(dropdown);
                    
                    // Toggle export dropdown
                    const isOpen = dropdown.classList.contains('active');
                    
                    if (isOpen) {
                        dropdown.classList.remove('active');
                        trigger.classList.remove('active');
                        info.isOpen = false;
                    } else {
                        dropdown.classList.add('active');
                        trigger.classList.add('active');
                        info.isOpen = true;
                    }
                },
                
                openDropdown(dropdown, section, trigger) {
                    dropdown.classList.add('active');
                    if (section) section.classList.add('open');
                    trigger.classList.add('active');
                    
                    // Calculate position for fixed positioning
                    const triggerRect = trigger.getBoundingClientRect();
                    const dropdownWidth = 320;
                    const offset = 4;
                    
                    // Apply positioning styles
                    dropdown.style.opacity = '1';
                    dropdown.style.visibility = 'visible';
                    dropdown.style.display = 'block';
                    dropdown.style.pointerEvents = 'auto';
                    dropdown.style.zIndex = '2147483647';
                    dropdown.style.position = 'fixed';
                    dropdown.style.top = (triggerRect.bottom + offset) + 'px';
                    dropdown.style.left = triggerRect.left + 'px';
                },
                
                closeDropdown(dropdown, section, trigger) {
                    dropdown.classList.remove('active');
                    if (section) section.classList.remove('open');
                    trigger.classList.remove('active');
                    
                    // Force hide with inline styles
                    dropdown.style.opacity = '0';
                    dropdown.style.visibility = 'hidden';
                    dropdown.style.pointerEvents = 'none';
                },
                
                closeAllExcept(exceptDropdown) {
                    this.dropdowns.forEach((info, trigger) => {
                        if (info.dropdown !== exceptDropdown && info.isOpen) {
                            this.closeDropdown(info.dropdown, info.section, trigger);
                            info.isOpen = false;
                        }
                    });
                },
                
                closeAll() {
                    this.dropdowns.forEach((info, trigger) => {
                        if (info.isOpen) {
                            this.closeDropdown(info.dropdown, info.section, trigger);
                            info.isOpen = false;
                        }
                    });
                },
                
                setupGlobalEvents() {
                    // Close dropdowns when clicking outside
                    document.addEventListener('click', (e) => {
                        const isDropdownClick = e.target.closest('.horizontal-controls-menu, .export-dropdown');
                        if (!isDropdownClick) {
                            this.closeAll();
                        }
                    });
                    
                    // Prevent dropdown close when clicking inside
                    document.addEventListener('click', (e) => {
                        const dropdown = e.target.closest('.menu-dropdown, .export-menu');
                        if (dropdown) {
                            e.stopPropagation();
                        }
                    });
                },
                
                cleanup() {
                    // Remove old event listeners by cloning and replacing nodes
                    this.dropdowns.forEach((info, trigger) => {
                        const newTrigger = trigger.cloneNode(true);
                        trigger.parentNode.replaceChild(newTrigger, trigger);
                    });
                    this.dropdowns.clear();
                    initialized = false;
                }
            };
            
            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => DropdownManager.init());
            } else {
                DropdownManager.init();
            }
            
            // Re-initialize when controls are regenerated
            window.addEventListener('controlsGenerated', () => {
                setTimeout(() => DropdownManager.init(), 50);
            });
            
            // Expose to global scope for debugging
            window.DropdownManager = DropdownManager;
            
        })();

        // Chart Title Editing Functions with Modal
        function findChartTitle() {
            // Try multiple selectors to find the chart title
            const selectors = [
                '#main-chart text.chart-title',
                '#main-chart .chart-title', 
                '#main-chart text[text-anchor="middle"]',
                '#main-chart text[text-anchor="center"]',
                '#main-chart svg text:first-of-type',
                '#main-chart text',
                '#main-chart svg g text'
            ];
            
            for (const selector of selectors) {
                const elements = document.querySelectorAll(selector);
                for (const element of elements) {
                    const text = element.textContent.trim();
                    // Look for titles that contain typical chart title keywords
                    if (text.length > 10 && (
                        text.includes('Statement') || 
                        text.includes('Corp') || 
                        text.includes('Inc') || 
                        text.includes('Q1') || text.includes('Q2') || text.includes('Q3') || text.includes('Q4') ||
                        text.includes('2023') || text.includes('2024') || text.includes('2025') ||
                        text.includes('Income') || text.includes('Balance')
                    )) {
                        return element;
                    }
                }
            }
            
            // Fallback: get the first text element that's reasonably long
            const allTexts = document.querySelectorAll('#main-chart text');
            for (const text of allTexts) {
                if (text.textContent.trim().length > 15) {
                    return text;
                }
            }
            
            return null;
        }

        function makeChartTitleEditable() {
            let chartTitle = findChartTitle();
            
            // If no title exists, create a default clickable title
            if (!chartTitle) {
                chartTitle = createDefaultTitle();
            }
            
            if (chartTitle) {
                // Restore custom title text if it exists
                if (window.customChartTitle && chartTitle.textContent !== window.customChartTitle) {
                    chartTitle.textContent = window.customChartTitle;
                    console.log('📝 Restored custom title:', window.customChartTitle);
                }
                
                // Restore custom title styling if it exists
                if (window.customTitleFontSize) {
                    chartTitle.style.fontSize = window.customTitleFontSize + 'px';
                    chartTitle.setAttribute('font-size', window.customTitleFontSize + 'px');
                }
                if (window.customTitleColor) {
                    chartTitle.style.setProperty('--custom-color', window.customTitleColor);
                    chartTitle.style.fill = window.customTitleColor;
                    chartTitle.setAttribute('fill', window.customTitleColor);
                    chartTitle.setAttribute('data-custom-color', window.customTitleColor);
                }
                
                // Always apply/reapply styling to ensure title remains editable
                chartTitle.setAttribute('data-editable', 'true');
                chartTitle.style.cursor = 'pointer';
                chartTitle.style.transition = 'fill 0.2s ease';
                
                return true;
            }
            return false;
        }

        function updateCurrencyDisplayLive(newCurrency) {
            // Map currency values to symbols
            const currencySymbols = {
                'USD ($)': '$',
                'EUR (€)': '€',
                'GBP (£)': '£',
                'JPY (¥)': '¥'
            };
            
            const newSymbol = currencySymbols[newCurrency] || '$';
            
            // Update all currency displays on the chart immediately
            const chartContainer = document.querySelector('#main-chart');
            if (chartContainer) {
                // Find all text elements that contain currency symbols
                const textElements = chartContainer.querySelectorAll('text');
                textElements.forEach(element => {
                    const text = element.textContent;
                    // Check if text contains currency symbols
                    if (text && (text.includes('$') || text.includes('€') || text.includes('£') || text.includes('¥'))) {
                        // Replace the currency symbol
                        const newText = text.replace(/[$€£¥]/, newSymbol);
                        element.textContent = newText;
                    }
                });
            }
            
            // Store for persistence
            window.livePreviewCurrency = newCurrency;
            console.log('💱 Live currency preview:', newCurrency, '→', newSymbol);
        }

        function updateUnitsDisplayLive(newUnits) {
            // Map units to suffixes
            const unitSuffixes = {
                'Millions': 'M',
                'Thousands': 'K', 
                'Billions': 'B',
                'Actual': ''
            };
            
            const newSuffix = unitSuffixes[newUnits] || 'M';
            
            // Update all unit displays on the chart immediately
            const chartContainer = document.querySelector('#main-chart');
            if (chartContainer) {
                const textElements = chartContainer.querySelectorAll('text');
                textElements.forEach(element => {
                    const text = element.textContent;
                    // Check if text contains unit suffixes and currency symbols
                    if (text && (text.includes('K') || text.includes('M') || text.includes('B')) && 
                        (text.includes('$') || text.includes('€') || text.includes('£') || text.includes('¥'))) {
                        // Replace the unit suffix while preserving currency symbol
                        let newText = text.replace(/[KMB](?=\s*$|[^a-zA-Z])/g, newSuffix);
                        if (newSuffix === '' && newText !== text) {
                            // Remove trailing space if no suffix
                            newText = newText.replace(/\s+([€$£¥])/, '$1');
                        }
                        element.textContent = newText;
                    }
                });
            }
            
            // Store for persistence
            window.livePreviewUnits = newUnits;
        }

        function rgbToHex(rgb) {
            if (!rgb || rgb === 'none') return '#1f2937';
            if (rgb.startsWith('#')) return rgb;
            
            const match = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            return '#1f2937';
        }

        function createDefaultTitle() {
            const chartContainer = document.querySelector('#main-chart svg');
            if (!chartContainer) {
                console.log('❌ No SVG container found for title creation');
                return null;
            }

            // Check if title already exists to avoid duplicates
            const existingTitle = chartContainer.querySelector('.chart-header text');
            if (existingTitle) {
                return existingTitle;
            }

            // Use default values since form fields are removed
            const companyName = 'TechFlow SaaS Corp';
            const period = 'Q3 2025';
            const defaultTitle = `${companyName} ${period} Income Statement`;

            // Get SVG dimensions
            const svgRect = chartContainer.getBoundingClientRect();
            const centerX = svgRect.width / 2 || 600;

            // Create title group
            const headerGroup = d3.select(chartContainer)
                .append('g')
                .attr('class', 'chart-header');

            // Create title text element
            const titleElement = headerGroup.append('text')
                .attr('x', centerX)
                .attr('y', 40)
                .attr('text-anchor', 'middle')
                .attr('font-size', '28px')
                .attr('font-weight', '600')
                .attr('font-family', 'Inter, sans-serif')
                .attr('fill', '#1f2937')
                .attr('class', 'chart-title')
                .text(defaultTitle);

            return titleElement.node();
        }

        function openTitleEditModal() {
            // Parse current chart title to get existing values
            const chartTitle = findChartTitle();
            let companyName = 'TechFlow SaaS Corp';
            let period = 'Q3 2025';
            let currency = 'USD ($)';
            let statementType = 'Income Statement';
            let units = 'Millions';
            let periodType = 'Q/Q';
            
            // Try to get values from multiple sources
            if (typeof flowData !== 'undefined' && flowData.metadata) {
                companyName = flowData.metadata.company || companyName;
                period = flowData.metadata.period || period;
                currency = flowData.metadata.currency || currency;
                units = flowData.metadata.unit || units;
                periodType = flowData.metadata.periodType || periodType;
            } else {
                // Initialize flowData.metadata if it doesn't exist
                if (typeof flowData !== 'undefined') {
                    if (!flowData.metadata) {
                        flowData.metadata = {};
                    }
                    // Set defaults if not already set
                    flowData.metadata.company = flowData.metadata.company || companyName;
                    flowData.metadata.period = flowData.metadata.period || period;
                    flowData.metadata.currency = flowData.metadata.currency || currency;
                    flowData.metadata.unit = flowData.metadata.unit || units;
                    flowData.metadata.periodType = flowData.metadata.periodType || periodType;
                }
            }
            
            // Also check for chart-specific metadata as additional fallback
            const app = window.pulseApp;
            if (app && app.chart && app.chart.data && app.chart.data.metadata) {
                const chartMeta = app.chart.data.metadata;
                currency = chartMeta.currency || currency;
                units = chartMeta.unit || chartMeta.units || units;
                companyName = chartMeta.company || companyName;
                period = chartMeta.period || period;
                periodType = chartMeta.periodType || periodType;
            }
            
            if (chartTitle && chartTitle.textContent) {
                const titleText = chartTitle.textContent.trim();
                // Try to parse existing title: "Company Period Statement Type"
                if (titleText.includes('Income Statement')) {
                    statementType = 'Income Statement';
                    const parts = titleText.replace(' Income Statement', '').trim().split(' ');
                    if (parts.length >= 2) {
                        period = parts.pop(); // Last part is period
                        companyName = parts.join(' '); // Rest is company name
                    }
                } else if (titleText.includes('Balance Sheet')) {
                    statementType = 'Balance Sheet';
                    const parts = titleText.replace(' Balance Sheet', '').trim().split(' ');
                    if (parts.length >= 2) {
                        period = parts.pop();
                        companyName = parts.join(' ');
                    }
                }
            }
            
            // Get current title styling
            let titleFontSize = 40;
            let titleColor = '#1f2937';
            const currentTitle = findChartTitle();
            if (currentTitle) {
                const computedStyle = window.getComputedStyle(currentTitle);
                titleFontSize = parseInt(computedStyle.fontSize) || 40;
                
                // Get color from multiple sources (SVG text elements use fill attribute)
                let detectedColor = null;
                
                // Check style.fill first (inline styles)
                if (currentTitle.style.fill) {
                    detectedColor = currentTitle.style.fill;
                }
                // Check fill attribute (SVG attribute)
                else if (currentTitle.getAttribute('fill')) {
                    detectedColor = currentTitle.getAttribute('fill');
                }
                // Check data-custom-color attribute
                else if (currentTitle.getAttribute('data-custom-color')) {
                    detectedColor = currentTitle.getAttribute('data-custom-color');
                }
                // Check global custom title color
                else if (window.customTitleColor) {
                    detectedColor = window.customTitleColor;
                }
                // Check computed style color as fallback
                else if (computedStyle.color) {
                    detectedColor = computedStyle.color;
                }
                
                // Convert to hex if we found a color
                if (detectedColor) {
                    titleColor = rgbToHex(detectedColor) || detectedColor;
                }
                
            }
            
            // Populate modal fields
            const modalCompanyName = document.getElementById('modal-company-name');
            const modalPeriod = document.getElementById('modal-period');
            const modalCurrency = document.getElementById('modal-currency');
            const modalStatementType = document.getElementById('modal-statement-type');
            const modalUnits = document.getElementById('modal-units');
            const modalPeriodType = document.getElementById('modal-period-type');
            const modalTitleFontSize = document.getElementById('modal-title-font-size');
            const modalTitleFontSizeValue = document.getElementById('modal-title-font-size-value');
            const modalTitleColor = document.getElementById('modal-title-color');
            
            // Show the modal first
            document.getElementById('chart-title-modal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            
            // Use setTimeout to ensure modal is rendered before setting values
            setTimeout(() => {
                
                if (modalCompanyName) modalCompanyName.value = companyName;
                if (modalPeriod) modalPeriod.value = period;
                if (modalCurrency) {
                    // Normalize currency values to match dropdown options
                    const currencyMap = {
                        'USD': 'USD ($)',
                        'EUR': 'EUR (€)',
                        'GBP': 'GBP (£)',
                        'JPY': 'JPY (¥)'
                    };
                    const normalizedCurrency = currencyMap[currency] || currency;
                    modalCurrency.value = normalizedCurrency;
                }
                if (modalStatementType) modalStatementType.value = statementType;
                if (modalUnits) {
                    // Normalize units values to match dropdown options
                    const unitsMap = {
                        'millions': 'Millions',
                        'thousands': 'Thousands',
                        'billions': 'Billions',
                        'actual': 'Actual'
                    };
                    const normalizedUnits = unitsMap[units.toLowerCase()] || units;
                    modalUnits.value = normalizedUnits;
                }
                if (modalPeriodType) modalPeriodType.value = periodType;
                if (modalTitleFontSize) {
                    modalTitleFontSize.value = titleFontSize;
                    if (modalTitleFontSizeValue) modalTitleFontSizeValue.textContent = titleFontSize + 'px';
                }
                if (modalTitleColor) modalTitleColor.value = titleColor;
            }, 10);
            
            // Add event listeners for live preview
            if (modalTitleFontSize && modalTitleFontSizeValue) {
                modalTitleFontSize.addEventListener('input', function() {
                    const newSize = this.value + 'px';
                    modalTitleFontSizeValue.textContent = newSize;
                    
                    // Live preview on chart title
                    const liveTitle = findChartTitle();
                    if (liveTitle) {
                        liveTitle.style.fontSize = newSize;
                        liveTitle.setAttribute('font-size', newSize);
                    }
                });
            }
            
            // Add event listener for live color preview
            if (modalTitleColor) {
                modalTitleColor.addEventListener('input', function() {
                    const newColor = this.value;
                    
                    // Live preview on chart title
                    const liveTitle = findChartTitle();
                    if (liveTitle) {
                        liveTitle.style.fill = newColor;
                        liveTitle.setAttribute('fill', newColor);
                        liveTitle.setAttribute('data-custom-color', newColor);
                    }
                });
            }
            
            // Add event listener for live currency preview
            if (modalCurrency) {
                modalCurrency.addEventListener('change', function() {
                    const newCurrency = this.value;
                    updateCurrencyDisplayLive(newCurrency);
                });
            }
            
            // Add event listener for live units preview
            if (modalUnits) {
                modalUnits.addEventListener('change', function() {
                    const newUnits = this.value;
                    updateUnitsDisplayLive(newUnits);
                });
            }
            
            // Store original values for cancel functionality
            window.originalTitleValues = {
                text: chartTitle ? chartTitle.textContent : '',
                fontSize: titleFontSize,
                color: titleColor
            };
            
            // Modal already shown above - just focus on first input
            setTimeout(() => {
                if (modalCompanyName) {
                    modalCompanyName.focus();
                    modalCompanyName.select();
                }
            }, 20);
        }

        function saveTitleEdit() {
            // Get values from modal (with null checks)
            const companyName = document.getElementById('modal-company-name')?.value || 'TechFlow SaaS Corp';
            const period = document.getElementById('modal-period')?.value || 'Q3 2025';
            const currency = document.getElementById('modal-currency')?.value || 'USD ($)';
            const statementType = document.getElementById('modal-statement-type')?.value || 'Income Statement';
            const units = document.getElementById('modal-units')?.value || 'Millions';
            const periodType = document.getElementById('modal-period-type')?.value || 'Q/Q';
            const titleFontSize = document.getElementById('modal-title-font-size')?.value || '40';
            const titleColor = document.getElementById('modal-title-color')?.value || '#1f2937';
            
            // Update global metadata with all values
            if (typeof flowData !== 'undefined' && flowData.metadata) {
                flowData.metadata.company = companyName;
                flowData.metadata.period = period;
                flowData.metadata.currency = currency;
                flowData.metadata.unit = units;
                flowData.metadata.periodType = periodType;
            }
            
            // Create new title
            const newTitle = `${companyName} ${period} ${statementType}`;
            
            // Update chart title (styling already applied via live preview)
            const chartTitle = findChartTitle();
            if (chartTitle) {
                // Store the title and styling for persistence
                window.customChartTitle = newTitle;
                window.customTitleFontSize = titleFontSize;
                window.customTitleColor = titleColor;
                
                // Only update the text content (styling already done by live preview)
                chartTitle.textContent = newTitle;
                
                // Ensure title remains editable
                chartTitle.setAttribute('data-editable', 'true');
                chartTitle.style.cursor = 'pointer';
                
                console.log('Chart title updated to:', newTitle);
                console.log('Title styling updated:', { fontSize: titleFontSize + 'px', color: titleColor });
                console.log('Metadata updated:', { companyName, period, currency, units, periodType });
            }
            
            // No chart re-render needed - all changes are applied live!
            // Just ensure title remains editable
            setTimeout(() => {
                makeChartTitleEditable();
            }, 50);
            
            // Clear original values since we're saving
            delete window.originalTitleValues;
            
            // Close modal
            document.getElementById('chart-title-modal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function cancelTitleEdit() {
            // Restore original title values if they exist
            if (window.originalTitleValues) {
                const chartTitle = findChartTitle();
                if (chartTitle) {
                    chartTitle.textContent = window.originalTitleValues.text;
                    chartTitle.style.fontSize = window.originalTitleValues.fontSize + 'px';
                    chartTitle.style.fill = window.originalTitleValues.color;
                    chartTitle.setAttribute('font-size', window.originalTitleValues.fontSize + 'px');
                    chartTitle.setAttribute('fill', window.originalTitleValues.color);
                    chartTitle.setAttribute('data-custom-color', window.originalTitleValues.color);
                    
                    // Restore global values
                    window.customTitleFontSize = window.originalTitleValues.fontSize;
                    window.customTitleColor = window.originalTitleValues.color;
                }
                delete window.originalTitleValues;
            }
            
            document.getElementById('chart-title-modal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Universal event delegation for chart title editing
        document.addEventListener('click', function(e) {
            // Check if clicked element is a chart title
            if (e.target.closest('#main-chart') && 
                (e.target.tagName === 'text' || e.target.tagName === 'TEXT') &&
                e.target.hasAttribute('data-editable')) {
                e.stopPropagation();
                console.log('Chart title clicked:', e.target.textContent);
                openTitleEditModal();
            }
        });

        // Universal hover effects with better clickability indication
        document.addEventListener('mouseover', function(e) {
            if (e.target.closest('#main-chart') && 
                (e.target.tagName === 'text' || e.target.tagName === 'TEXT') &&
                e.target.hasAttribute('data-editable')) {
                
                // Store original styles
                e.target.setAttribute('data-original-opacity', e.target.style.opacity || '1');
                e.target.setAttribute('data-original-filter', e.target.style.filter || 'none');
                
                // Get current title color for glow effect
                const currentColor = e.target.style.fill || e.target.getAttribute('fill') || e.target.getAttribute('data-custom-color') || window.customTitleColor || '#1f2937';
                
                // Convert color to rgba format for glow effect
                let glowColor = currentColor;
                if (currentColor.startsWith('#')) {
                    // Convert hex to rgba
                    const hex = currentColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    glowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                } else if (currentColor.startsWith('rgb')) {
                    // Convert rgb to rgba with alpha
                    glowColor = currentColor.replace('rgb(', 'rgba(').replace(')', ', 0.6)');
                }
                
                // Apply hover effects: slightly reduce opacity and add glow using current color
                e.target.style.opacity = '0.8';
                e.target.style.filter = `drop-shadow(0 0 4px ${glowColor})`;
                e.target.style.transition = 'opacity 0.2s ease, filter 0.2s ease';
                
                // Add visual cue that it's clickable
                e.target.style.cursor = 'pointer';
            }
        });

        document.addEventListener('mouseout', function(e) {
            if (e.target.closest('#main-chart') && 
                (e.target.tagName === 'text' || e.target.tagName === 'TEXT') &&
                e.target.hasAttribute('data-editable')) {
                
                // Restore original styles
                const originalOpacity = e.target.getAttribute('data-original-opacity') || '1';
                const originalFilter = e.target.getAttribute('data-original-filter') || 'none';
                
                e.target.style.opacity = originalOpacity;
                e.target.style.filter = originalFilter;
            }
        });

        // Initialize chart title editing
        document.addEventListener('DOMContentLoaded', function() {
            let attempts = 0;
            const maxAttempts = 50;
            
            const titleCheckInterval = setInterval(() => {
                attempts++;
                
                if (makeChartTitleEditable() || attempts >= maxAttempts) {
                    clearInterval(titleCheckInterval);
                    if (attempts >= maxAttempts) {
                    }
                }
            }, 500);
            
            // Also try when window loads and when charts are rendered
            window.addEventListener('load', () => {
                setTimeout(makeChartTitleEditable, 1000);
                setTimeout(makeChartTitleEditable, 3000);
            });
            
            // Listen for chart rendering events
            document.addEventListener('chartRendered', () => {
                setTimeout(makeChartTitleEditable, 200);
            });
            
            // Also listen for DOM mutations to catch chart re-renders
            const chartContainer = document.getElementById('main-chart');
            if (chartContainer) {
                const observer = new MutationObserver(() => {
                    // Debounce the re-enable function
                    clearTimeout(window.titleEditableTimeout);
                    window.titleEditableTimeout = setTimeout(() => {
                        makeChartTitleEditable();
                    }, 500);
                });
                
                observer.observe(chartContainer, {
                    childList: true,
                    subtree: true
                });
            }
        });

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('chart-title-modal');
            if (e.target === modal) {
                cancelTitleEdit();
            }
        });


    </script>
</body>
</html>