<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Analytics Platform</title>
    
    <!-- External Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.min.js"></script>
    
    <!-- Google Fonts for Title Font Control -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Lato:wght@400;700&family=Montserrat:wght@400;600;700&family=Poppins:wght@400;500;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Consolidated Application Styles -->
    <link rel="stylesheet" href="css/pulse-analytics.css">
    
    <!-- Styles moved to css/pulse-analytics.css -->
</head>
<body>
    <div class="pulse-app">
        <!-- Application Header -->
        <header class="app-header">
            <h1>Pulse Analytics Platform</h1>
            <div class="header-controls">
                <div class="chart-selector">
                    <label for="chart-type-select" style="color: white; margin-right: 8px;">Chart:</label>
                    <select id="chart-type-select">
                        <option value="sankey">üåä Sankey Flow</option>
                        <option value="bar">üìä Bar Chart</option>
                        <option value="line">üìà Line Chart</option>
                    </select>
                </div>
            </div>
        </header>

        <!-- Main Tabs Navigation -->
        <div class="main-tabs">
            <button class="main-tab" onclick="switchMainTab('data-builder', true)">
                üí∞ Flow Builder
            </button>
            <button class="main-tab active" onclick="switchMainTab('chart-view', true)">
                üìä Chart View
            </button>
        </div>

        <!-- Flow Builder Tab -->
        <div id="data-builder" class="tab-content">
            <div class="flow-builder-container">
                <!-- Top Menu Bar -->
                <div class="top-menu-bar">
                    <div class="menu-section stats-menu">
                        <span class="menu-label">üìä</span>
                        <div class="stat-item">
                            <span class="stat-value" id="flow-count">0</span>
                            <span class="stat-label">Flows</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="node-count">0</span>
                            <span class="stat-label">Nodes</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="layer-count">0</span>
                            <span class="stat-label">Layers</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="balance-score">0%</span>
                            <span class="stat-label">Balance</span>
                        </div>
                    </div>
                    
                    <div class="menu-section actions-menu">
                        <span class="menu-label">üõ†Ô∏è</span>
                        <button class="menu-btn" onclick="importFlowsFromCSV()">üì§ Upload Data</button>
                        <button class="menu-btn" onclick="downloadTemplate()">üìã Download Template</button>
                        <button class="menu-btn" onclick="exportFlowsToCSV()">üíæ Export</button>
                        <button class="menu-btn" onclick="resetChart()">üîÑ Reset</button>
                    </div>
                </div>

                <!-- Chart type selection removed - now handled by separate page -->

                <!-- Company Information Section -->
                <div class="collapsible-section">
                    <div class="collapsible-header" onclick="toggleSection('company')">
                        <h3 class="collapsible-title">üè¢ Company Information</h3>
                        <span class="collapsible-chevron">‚ñº</span>
                    </div>
                    <div class="collapsible-content" id="company-content">
                        <div style="padding: 20px;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
                                <div>
                                    <label style="display: block; font-size: 12px; font-weight: 500; color: #374151; margin-bottom: 4px;">Company Name</label>
                                    <input type="text" class="flow-input" id="company-name" value="TechFlow Corporation" onchange="updateMetadata()">
                                </div>
                                <div>
                                    <label style="display: block; font-size: 12px; font-weight: 500; color: #374151; margin-bottom: 4px;">Period</label>
                                    <input type="text" class="flow-input" id="period" value="Q3 2025" onchange="updateMetadata()">
                                </div>
                                <div>
                                    <label style="display: block; font-size: 12px; font-weight: 500; color: #374151; margin-bottom: 4px;">Currency</label>
                                    <select class="flow-select" id="currency" onchange="updateMetadata()">
                                        <option value="USD">USD ($)</option>
                                        <option value="EUR">EUR (‚Ç¨)</option>
                                        <option value="GBP">GBP (¬£)</option>
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; font-size: 12px; font-weight: 500; color: #374151; margin-bottom: 4px;">Units</label>
                                    <select class="flow-select" id="units" onchange="updateMetadata()">
                                        <option value="millions">Millions</option>
                                        <option value="billions">Billions</option>
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; font-size: 12px; font-weight: 500; color: #374151; margin-bottom: 4px;">Period Type</label>
                                    <select class="flow-select" id="period-type" onchange="updateMetadata()">
                                        <option value="Q/Q">Quarter-over-Quarter (Q/Q)</option>
                                        <option value="Y/Y">Year-over-Year (Y/Y)</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Business Flows Section -->
                <div class="collapsible-section">
                    <div class="collapsible-header" onclick="toggleSection('flows')">
                        <h3 class="collapsible-title">
                            üí∞ Business Flows
                            <div class="flow-controls-group">
                                <button id="flows-update-toggle" class="update-mode-toggle live" onclick="toggleFlowsUpdateMode()" title="Toggle between Live and Manual update modes">
                                    <span class="mode-indicator"></span>
                                    <span class="mode-text">Live</span>
                                </button>
                                <div class="period-comparison-toggle">
                                    <input type="checkbox" id="comparison-mode-toggle" onchange="toggleComparisonMode()">
                                    <label for="comparison-mode-toggle" title="Shows variance % and trends between periods">üìà</label>
                                </div>
                            </div>
                        </h3>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <button class="add-flow-btn" onclick="addFlow()">+ Add Flow</button>
                            <span class="collapsible-chevron">‚ñº</span>
                        </div>
                    </div>
                    <div class="collapsible-content" id="flows-content">
                        <div style="overflow-x: auto;">
                            <table class="flow-table">
                                <thead>
                                    <tr>
                                        <th style="width: 80px;">Actions</th>
                                        <th style="width: 200px;">From (Source)</th>
                                        <th style="width: 200px;">To (Target)</th>
                                        <th style="width: 100px;">Current Value</th>
                                        <th style="width: 100px;" id="previous-value-col">Previous Value</th>
                                        <th style="width: 80px;" id="variance-col">Variance</th>
                                        <th style="width: 120px;">Source Category</th>
                                        <th style="width: 120px;">Target Category</th>
                                        <th style="width: 250px;">Description</th>
                                    </tr>
                                </thead>
                                <tbody id="flows-tbody">
                                    <!-- Rows will be dynamically generated by renderFlowTable() -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="applyFlowChanges()">üöÄ Apply Changes</button>
                    <button class="btn btn-secondary" onclick="validateFlows()">‚úÖ Validate</button>
                    <button class="btn btn-secondary" onclick="resetToChartData()">üîÑ Reset to Chart</button>
                </div>
            </div>
        </div>

        <!-- Chart View Tab (Original) -->
        <div id="chart-view" class="tab-content active">
            <div class="app-content">
                <!-- Chart Area -->
                <div class="chart-area">
                    <!-- Modern Chart Header -->
                    <div class="chart-header">
                        <div class="chart-info">
                            <span id="data-status" class="status-indicator status-loading">
                                <div class="status-dot"></div>
                                <span class="status-text">Loading...</span>
                            </span>
                        </div>
                        
                        <!-- Redesigned Export Controls -->
                        <div class="export-section">
                            <div class="export-dropdown">
                                <button class="export-trigger" id="export-trigger">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="7,10 12,15 17,10"/>
                                        <line x1="12" y1="15" x2="12" y2="3"/>
                                    </svg>
                                    <span>Export</span>
                                    <svg class="chevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="6,9 12,15 18,9"/>
                                    </svg>
                                </button>
                                <div class="export-menu" id="export-menu">
                                    <button class="export-option" id="export-png">
                                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                            <circle cx="8.5" cy="8.5" r="1.5"/>
                                            <polyline points="21,15 16,10 5,21"/>
                                        </svg>
                                        <span>PNG Image</span>
                                        <span class="export-desc">High-quality raster image</span>
                                    </button>
                                    <button class="export-option" id="export-svg">
                                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <polygon points="13,2 3,14 12,14 11,22 21,10 12,10"/>
                                        </svg>
                                        <span>SVG Vector</span>
                                        <span class="export-desc">Scalable vector format</span>
                                    </button>
                                    <button class="export-option" id="export-data">
                                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                            <polyline points="14,2 14,8 20,8"/>
                                            <line x1="16" y1="13" x2="8" y2="13"/>
                                            <line x1="16" y1="17" x2="8" y2="17"/>
                                            <polyline points="10,9 9,9 8,9"/>
                                        </svg>
                                        <span>CSV Data</span>
                                        <span class="export-desc">Raw data for analysis</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Chart Container -->
                    <div id="main-chart" class="chart-container">
                        <div class="chart-loading">
                            <div class="loading-spinner"></div>
                            <p>Initializing Pulse Analytics Platform...</p>
                        </div>
                    </div>
                </div>

                <!-- Redesigned Control Panel -->
                <div class="control-panel">
                    <div class="control-panel-header">
                        <div class="control-header-content">
                            <div class="control-title">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="3"/>
                                    <path d="m12 1 2.09 6.26L22 9l-6.26 2.09L14 23l-2.09-6.26L2 15l6.26-2.09L10 1Z"/>
                                </svg>
                                <h3>Chart Controls</h3>
                            </div>
                            <div class="control-actions">
                                <button id="reset-defaults" class="control-btn reset-btn">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                                        <path d="M21 3v5h-5"/>
                                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                                        <path d="M8 16H3v5"/>
                                    </svg>
                                    Reset
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="dynamic-controls" class="control-panel-content">
                        <div class="controls-loading">
                            <div class="loading-pulse"></div>
                            <div class="loading-content">
                                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="3"/>
                                    <path d="m12 1 2.09 6.26L22 9l-6.26 2.09L14 23l-2.09-6.26L2 15l6.26-2.09L10 1Z"/>
                                </svg>
                                <p>Loading chart controls...</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" style="display: none;" accept=".json">
    <input type="file" id="csv-file-input" style="display: none;" accept=".csv,.json">

    <!-- Core Scripts -->
    <script src="js/utils/ExportUtils.js"></script>
    <script src="js/core/DataManager.js"></script>
    <script src="js/core/ControlPanel.js"></script>
    <script src="js/charts/sankey/SankeyChart.js"></script>
    <script src="js/charts/sankey/SankeyControls.js"></script>
    
    <!-- Enhanced app.js -->
    <script src="js/app.js"></script>
    
    <!-- Data Bridge Integration -->
    <script>
        window.PulseDataBridge = {
            currentData: null,
            chartInstance: null,
            isInitialized: false,
            realTimeMode: true,
            appReadyCallbacks: [],
            
            init() {
                this.isInitialized = true;
                console.log('üåâ Real-time Data Bridge initialized');
                
                this.waitForAppReady().then(() => {
                    this.setupEventListeners();
                });
            },
            
            onAppReady(callback) {
                if (window.pulseApp) {
                    callback();
                } else {
                    this.appReadyCallbacks.push(callback);
                }
            },
            
            setData(data, source = 'unknown') {
                this.currentData = data;
                console.log(`üìä Data updated from ${source}:`, data);
                this.notifyDataChanged(source);
            },
            
            getData() {
                if (this.currentData) {
                    return this.currentData;
                }
                
                if (window.pulseApp?.getCurrentData()) {
                    this.currentData = window.pulseApp.getCurrentData();
                    return this.currentData;
                }
                
                if (window.pulseApp?.getCurrentChart()?.data) {
                    this.currentData = window.pulseApp.getCurrentChart().data;
                    return this.currentData;
                }
                
                return null;
            },
            
            setChartInstance(chart) {
                this.chartInstance = chart;
                console.log('üìà Chart instance registered');
            },
            
            setRealTimeMode(enabled) {
                this.realTimeMode = enabled;
                console.log(`üîÑ Real-time mode ${enabled ? 'ENABLED' : 'DISABLED'}`);
                this.updateRealTimeIndicator();
            },
            
            notifyDataChanged(source) {
                console.log(`üîÑ Broadcasting data change from ${source}`);
                
                if (this.chartInstance && this.currentData && source !== 'chart-update') {
                    console.log('üé® Updating chart with new data');
                    this.chartInstance.render(this.currentData);
                }
                
                if (window.currentMainTab === 'data-builder') {
                    this.refreshFlowBuilder();
                }
                
                if (window.pulseApp && source !== 'app' && source !== 'app-initial') {
                    window.pulseApp.currentData = this.currentData;
                }
                
                window.dispatchEvent(new CustomEvent('pulseDataChanged', {
                    detail: { data: this.currentData, source }
                }));
            },
            
            refreshFlowBuilder() {
                console.log('üîß Refreshing Flow Builder...');
                
                const data = this.getData();
                if (data && data.nodes && data.links) {
                    console.log('‚úÖ Found data for Flow Builder refresh:', data);
                    window.flowData = convertSankeyDataToFlows(data);
                    
                    if (typeof renderFlowTable === 'function') {
                        renderFlowTable();
                        updateAllStats();
                        console.log('‚úÖ Flow Builder refreshed successfully');
                    }
                } else {
                    console.warn('‚ö†Ô∏è No data available for Flow Builder refresh');
                }
            },
            
            updateRealTimeIndicator() {
                const indicator = document.getElementById('realtime-indicator');
                const button = document.getElementById('realtime-toggle');
                
                if (indicator && button) {
                    if (this.realTimeMode) {
                        indicator.className = 'realtime-indicator live';
                        button.textContent = '‚ö™ Disable Live Updates';
                        button.className = 'btn btn-secondary';
                    } else {
                        indicator.className = 'realtime-indicator manual';
                        button.textContent = 'üî¥ Enable Live Updates';
                        button.className = 'btn btn-primary';
                    }
                }
            },
            
            applyImmediateChange(newData) {
                if (this.realTimeMode) {
                    console.log('‚ö° Applying immediate change in real-time mode');
                    this.setData(newData, 'flow-builder-realtime');
                }
            },
            
            applyFlowBuilderChanges(newData) {
                console.log('‚úÖ Applying Flow Builder changes:', newData);
                this.setData(newData, 'flow-builder');
            },
            
            setupEventListeners() {
                window.addEventListener('pulseTabSwitch', (e) => {
                    this.handleTabSwitch(e.detail.tabName);
                });
            },
            
            async waitForAppReady() {
                const maxAttempts = 50;
                const checkInterval = 200;
                let attempts = 0;
                
                return new Promise((resolve, reject) => {
                    const checkApp = () => {
                        attempts++;
                        
                        if (window.pulseApp && window.pulseApp.isInitialized) {
                            console.log('‚úÖ Main app found and ready, hooking into data flow');
                            this.hookIntoApp();
                            
                            this.appReadyCallbacks.forEach(callback => callback());
                            this.appReadyCallbacks = [];
                            
                            resolve();
                            return;
                        }
                        
                        // Also check if app exists but is still initializing
                        if (window.pulseApp && !window.pulseApp.isInitialized) {
                            console.log(`‚è≥ App found but still initializing (attempt ${attempts}/${maxAttempts})`);
                        }
                        
                        if (attempts >= maxAttempts) {
                            console.warn('‚ö†Ô∏è Main app initialization timeout - continuing without full integration');
                            // Try to hook into app anyway if it exists
                            if (window.pulseApp) {
                                this.hookIntoApp();
                            }
                            resolve();
                            return;
                        }
                        
                        setTimeout(checkApp, checkInterval);
                    };
                    
                    checkApp();
                });
            },
            
            hookIntoApp() {
                const app = window.pulseApp;
                if (!app) return;
                
                const originalLoadDataset = app.loadDataset.bind(app);
                app.loadDataset = async function(datasetKey) {
                    const result = await originalLoadDataset(datasetKey);
                    window.PulseDataBridge.setData(result, `dataset-${datasetKey}`);
                    return result;
                };
                
                if (app.chart) {
                    this.setChartInstance(app.chart);
                }
                
                const initialData = app.getCurrentData();
                if (initialData) {
                    this.setData(initialData, 'app-initial');
                }
                
                console.log('üîó Successfully hooked into main app');
            },
            
            handleTabSwitch(tabName) {
                console.log(`üîÑ Tab switched to: ${tabName}`);
                
                if (tabName === 'data-builder') {
                    if (!this.currentData && window.pulseApp) {
                        const appData = window.pulseApp.getCurrentData();
                        if (appData) {
                            this.currentData = appData;
                            console.log('üìä Retrieved data from app for flow builder');
                        }
                    }
                    
                    setTimeout(() => {
                        this.refreshFlowBuilder();
                    }, 50);
                } else if (tabName === 'chart-view') {
                    const data = this.getData();
                    if (data && this.chartInstance) {
                        this.chartInstance.render(data);
                    }
                }
            }
        };

        // Initialize Data Bridge after DOM is ready and app.js has loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => window.PulseDataBridge.init(), 100);
            });
        } else {
            setTimeout(() => window.PulseDataBridge.init(), 100);
        }
    </script>
    
    <!-- Flow Builder Implementation -->
    <script>
        let currentMainTab = 'chart-view';
        let selectedChartType = null; // 'income' or 'balance'
        let isInitialized = false; // Prevent multiple initializations
        let lockChartView = false; // Lock chart view when coming from type selector
        let flowData = {
            metadata: {
                title: "Financial Flow",
                currency: "USD",
                unit: "millions",
                company: "Your Company",
                period: "Current Period",
                colorPalette: {} // CRITICAL: Always preserve color palette
            },
            flows: []
        };

        let flowIdCounter = 0;

        // Parse URL parameters to get chart type
        function getURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            return {
                type: urlParams.get('type'), // 'income' or 'balance'
                tab: urlParams.get('tab') // 'data-builder' or 'chart-view'
            };
        }

        // Load JSON data file based on chart type
        async function loadChartTypeData(chartType) {
            try {
                let dataFile = '';
                if (chartType === 'income') {
                    dataFile = 'data/samples/saas-company.json';
                } else if (chartType === 'balance') {
                    dataFile = 'data/samples/medocare.json';
                } else {
                    console.warn('Unknown chart type:', chartType);
                    return null;
                }

                console.log(`üìÅ Loading ${chartType} data from ${dataFile}`);
                const response = await fetch(dataFile);
                
                if (!response.ok) {
                    throw new Error(`Failed to load ${dataFile}: ${response.status}`);
                }
                
                const data = await response.json();
                console.log(`‚úÖ Successfully loaded ${chartType} data:`, data);
                console.log(`üìä Data nodes:`, data.nodes?.slice(0, 3));
                console.log(`üîó Data links:`, data.links?.slice(0, 3));
                return data;
                
            } catch (error) {
                console.error('Error loading chart type data:', error);
                alert(`Error loading sample data: ${error.message}`);
                return null;
            }
        }

        // FIXED: Add missing convertSankeyDataToFlows function
        function convertSankeyDataToFlows(sankeyData) {
            const flows = [];
            
            sankeyData.links.forEach((link, index) => {
                const sourceNode = sankeyData.nodes.find(n => n.id === link.source);
                const targetNode = sankeyData.nodes.find(n => n.id === link.target);
                
                if (sourceNode && targetNode) {
                    flows.push(new BusinessFlow({
                        source: link.source,
                        target: link.target,
                        value: link.value,
                        previousValue: link.previousValue || 0,
                        flowType: link.type || 'revenue_flow',
                        sourceLayer: sourceNode.depth || 0,
                        targetLayer: targetNode.depth || 1,
                        sourceCategory: sourceNode.category || 'revenue',
                        targetCategory: targetNode.category || 'revenue',
                        description: link.description || targetNode.description || ''
                    }));
                }
            });

            return {
                metadata: {
                    title: sankeyData.metadata?.title || "Financial Flow",
                    currency: sankeyData.metadata?.currency || "USD",
                    unit: sankeyData.metadata?.unit || "millions",
                    company: sankeyData.metadata?.company || "Your Company",
                    period: sankeyData.metadata?.period || "Current Period",
                    comparisonMode: sankeyData.metadata?.comparisonMode || false,
                    // CRITICAL: Preserve the existing color palette
                    colorPalette: sankeyData.metadata?.colorPalette || flowData.metadata?.colorPalette || {}
                },
                flows: flows
            };
        }

        // FIXED: Comparison Mode Toggle with color preservation
        function toggleComparisonMode() {
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            
            // CRITICAL: Store existing colors before any changes
            const existingColors = { ...flowData.metadata.colorPalette };
            
            // Show/hide comparison columns
            const previousCol = document.getElementById('previous-value-col');
            const varianceCol = document.getElementById('variance-col');
            
            if (comparisonMode) {
                previousCol.style.display = 'table-cell';
                varianceCol.style.display = 'table-cell';
            } else {
                previousCol.style.display = 'none';
                varianceCol.style.display = 'none';
            }
            
            // Update metadata with comparison mode but preserve colors
            flowData.metadata.comparisonMode = comparisonMode;
            flowData.metadata.colorPalette = existingColors; // CRITICAL: Restore colors
            
            // Re-render table
            renderFlowTable();
            
            // If in real-time mode, trigger update with color preservation
            if (window.PulseDataBridge.realTimeMode) {
                const sankeyData = generateNodesAndLinksFromFlows();
                // CRITICAL: Ensure colors are preserved in the generated data
                sankeyData.metadata.colorPalette = existingColors;
                debouncedRealTimeUpdate();
            }
            
            console.log(`üìà Comparison mode ${comparisonMode ? 'ENABLED' : 'DISABLED'} with colors preserved`);
        }

        // Flow structure definition
        class BusinessFlow {
            constructor(options = {}) {
                this.id = options.id || `flow_${++flowIdCounter}`;
                this.source = options.source || '';
                this.target = options.target || '';
                this.value = options.value || 0;
                this.previousValue = options.previousValue || 0;
                this.flowType = options.flowType || 'revenue_flow';
                this.sourceLayer = options.sourceLayer || 0;
                this.targetLayer = options.targetLayer || 1;
                this.sourceOrder = options.sourceOrder || 1;
                this.targetOrder = options.targetOrder || 1;
                this.sourceCategory = options.sourceCategory || 'revenue';
                this.targetCategory = options.targetCategory || 'revenue';
                this.description = options.description || '';
            }
            
            // Calculate variance between current and previous period
            getVariance() {
                if (this.previousValue === 0) {
                    return this.value > 0 ? { amount: this.value, percentage: 100, trend: 'new' } : { amount: 0, percentage: 0, trend: 'none' };
                }
                
                const amount = this.value - this.previousValue;
                const percentage = (amount / Math.abs(this.previousValue)) * 100;
                let trend = 'none';
                
                if (percentage > 0.1) trend = 'up';
                else if (percentage < -0.1) trend = 'down';
                
                return { amount, percentage, trend };
            }
            
            // Get formatted variance display
            getVarianceDisplay() {
                const variance = this.getVariance();
                if (variance.trend === 'none') return '‚Üí 0%';
                if (variance.trend === 'new') return ''; // Return empty string for new items (consistent with getGrowthDeclineDisplay)
                
                const symbol = variance.trend === 'up' ? '‚ÜóÔ∏è' : '‚ÜòÔ∏è';
                const sign = variance.percentage > 0 ? '+' : '';
                return `${symbol} ${sign}${variance.percentage.toFixed(1)}%`;
            }
            
            // Calculate margin percentage (for Income Statement only)
            getMarginPercentage(revenueBase) {
                if (!revenueBase || revenueBase === 0) {
                    return { percentage: 0, display: 'N/A' };
                }
                
                const percentage = (this.value / revenueBase) * 100;
                return {
                    percentage: percentage,
                    display: `${percentage.toFixed(1)}%`
                };
            }
            
            // Get formatted growth/decline display (for both IS and BS)
            getGrowthDeclineDisplay() {
                const variance = this.getVariance();
                if (variance.trend === 'none') return ''; // Return empty string for no change
                if (variance.trend === 'new') return ''; // Return empty string for new items too
                
                const sign = variance.percentage > 0 ? '+' : '';
                const periodIndicator = this.getPeriodIndicator();
                return `${sign}${variance.percentage.toFixed(1)}% ${periodIndicator}`;
            }
            
            // Get period indicator (Y/Y or Q/Q) based on user selection
            getPeriodIndicator() {
                // Use user-selected period type if available
                if (flowData.metadata?.periodType) {
                    return flowData.metadata.periodType;
                }
                
                // Fallback to automatic detection for backward compatibility
                const period = flowData.metadata?.period || '';
                const periodLower = period.toLowerCase();
                
                // Check for quarter indicators
                if (periodLower.includes('q1') || periodLower.includes('q2') || 
                    periodLower.includes('q3') || periodLower.includes('q4') || 
                    periodLower.includes('quarter')) {
                    return 'Q/Q';
                }
                
                // Default to Q/Q for quarterly periods, Y/Y otherwise
                return 'Y/Y';
            }
        }

        // Find revenue base by looking for Total Revenue node (calculated sum)
        function findRevenueBase(flowData) {
            if (!flowData || !flowData.flows) return 0;
            
            // Build a map of nodes and their incoming flows to find the aggregated total
            const nodeInflows = new Map();
            
            flowData.flows.forEach(flow => {
                if (!nodeInflows.has(flow.target)) {
                    nodeInflows.set(flow.target, []);
                }
                nodeInflows.get(flow.target).push({
                    source: flow.source,
                    value: flow.value
                });
            });
            
            // Look for "Total Revenue" node or a node that aggregates multiple revenue sources
            let revenueBase = 0;
            let revenueNodeName = null;
            
            for (const [nodeName, inflows] of nodeInflows) {
                const lowerName = nodeName.toLowerCase();
                
                // Check if this is "Total Revenue" or aggregates multiple revenue sources
                if (lowerName.includes('total') && lowerName.includes('revenue')) {
                    // Calculate the sum of incoming revenue flows
                    const totalIncoming = inflows.reduce((sum, inflow) => sum + inflow.value, 0);
                    revenueBase = totalIncoming;
                    revenueNodeName = nodeName;
                    console.log(`‚úÖ Found Total Revenue node: ${nodeName} = ${totalIncoming}`);
                    break;
                } else if (lowerName.includes('revenue') && inflows.length >= 2) {
                    // Revenue node with multiple inputs (likely an aggregation)
                    const revenueInflows = inflows.filter(inflow => {
                        const sourceLower = inflow.source.toLowerCase();
                        return sourceLower.includes('revenue') || 
                               sourceLower.includes('subscription') ||
                               sourceLower.includes('service') ||
                               sourceLower.includes('platform') ||
                               sourceLower.includes('sales');
                    });
                    
                    if (revenueInflows.length >= 2) {
                        const totalIncoming = revenueInflows.reduce((sum, inflow) => sum + inflow.value, 0);
                        if (totalIncoming > revenueBase) {
                            revenueBase = totalIncoming;
                            revenueNodeName = nodeName;
                            console.log(`‚úÖ Found revenue aggregation node: ${nodeName} = ${totalIncoming}`);
                        }
                    }
                }
            }
            
            // Fallback: if no aggregation found, sum all primary revenue sources
            if (revenueBase === 0) {
                console.log('üîç No total revenue node found, summing primary revenue sources...');
                const primarySources = flowData.flows.filter(flow => {
                    const sourceLower = flow.source.toLowerCase();
                    return (sourceLower.includes('revenue') || 
                           sourceLower.includes('subscription') ||
                           sourceLower.includes('service') ||
                           sourceLower.includes('platform')) &&
                           !nodeInflows.has(flow.source); // Primary source (no inputs)
                });
                
                revenueBase = primarySources.reduce((sum, flow) => sum + flow.value, 0);
                revenueNodeName = `Calculated from ${primarySources.length} primary sources`;
            }
            
            console.log(`üí∞ Revenue base: ${revenueNodeName} = ${revenueBase}`);
            return revenueBase;
        }

        // Get percentage of revenue for any node value
        function getRevenuePercentage(nodeValue, revenueBase) {
            if (!revenueBase || revenueBase === 0) return 'N/A';
            
            // If this is the revenue base itself, it's 100%
            if (nodeValue === revenueBase) {
                return '100.0%';
            }
            
            const percentage = (nodeValue / revenueBase) * 100;
            return `${percentage.toFixed(1)}%`;
        }

        // Debounce function for real-time updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedRealTimeUpdate = debounce(() => {
            if (window.PulseDataBridge.realTimeMode) {
                console.log('‚ö° Triggering debounced real-time update');
                const sankeyData = generateNodesAndLinksFromFlows();
                window.PulseDataBridge.applyImmediateChange(sankeyData);
            }
        }, 500);

        // Collapsible Section Management
        function toggleSection(sectionName) {
            const header = document.querySelector(`[onclick="toggleSection('${sectionName}')"]`);
            const content = document.getElementById(`${sectionName}-content`);
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.style.height = 'auto';
                header.classList.remove('collapsed');
            } else {
                content.style.height = content.scrollHeight + 'px';
                setTimeout(() => {
                    content.classList.add('collapsed');
                    header.classList.add('collapsed');
                }, 10);
            }
        }

        // Toggle function for the compact Business Flows update mode button
        function toggleFlowsUpdateMode() {
            const toggle = document.getElementById('flows-update-toggle');
            const isLive = toggle.classList.contains('live');
            
            if (isLive) {
                toggle.classList.remove('live');
                toggle.classList.add('manual');
                toggle.querySelector('.mode-text').textContent = 'Manual';
                toggle.title = 'Click to enable Live updates';
            } else {
                toggle.classList.remove('manual');
                toggle.classList.add('live');
                toggle.querySelector('.mode-text').textContent = 'Live';
                toggle.title = 'Click to enable Manual updates';
            }
            
            // Also toggle the main realtime mode
            toggleRealTimeMode();
        }

        function toggleRealTimeMode() {
            const currentMode = window.PulseDataBridge.realTimeMode;
            const newMode = !currentMode;
            window.PulseDataBridge.setRealTimeMode(newMode);
            
            console.log(`üîÑ Real-time mode ${newMode ? 'ENABLED' : 'DISABLED'}`);
        }

        function switchMainTab(tabName, isManualClick = false) {
            // Check if chart view is locked (from type selector) - but allow manual clicks
            if (lockChartView && tabName === 'data-builder' && !isManualClick) {
                console.log('üîí Chart view is locked, ignoring automatic switch to data-builder');
                return;
            }
            
            console.log(`üéØ Switching to tab: ${tabName}`);
            
            // If user manually clicks any tab, unlock chart view
            if (isManualClick) {
                lockChartView = false;
                console.log('üîì Chart view unlocked by manual click');
            }
            
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const targetTab = document.querySelector(`[onclick="switchMainTab('${tabName}')"]`);
            if (targetTab) {
                targetTab.classList.add('active');
            }
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const targetContent = document.getElementById(tabName);
            if (targetContent) {
                targetContent.classList.add('active');
            }
            
            currentMainTab = tabName;
            
            window.dispatchEvent(new CustomEvent('pulseTabSwitch', {
                detail: { tabName }
            }));
            
            if (tabName === 'data-builder') {
                // Only initialize if not already done
                if (!isInitialized) {
                    setTimeout(() => {
                        initializeFlowBuilder();
                    }, 100);
                } else {
                    console.log('üìä Data-builder tab activated, data already loaded');
                }
            }
        }

        async function initializeFlowBuilder() {
            if (isInitialized) {
                console.log('‚ö†Ô∏è Flow Builder already initialized, skipping...');
                return;
            }
            
            console.log('üîß Initializing Flow Builder...');
            
            // Get URL parameters once at the beginning
            const urlParams = getURLParameters();
            
            // Check for existing data first (priority for uploaded/custom data)
            let existingData = null;
            
            if (window.PulseDataBridge && window.PulseDataBridge.currentData) {
                existingData = window.PulseDataBridge.currentData;
                console.log('üìä Found existing data in Data Bridge:', existingData);
            } else if (window.pulseApp && window.pulseApp.getCurrentData()) {
                existingData = window.pulseApp.getCurrentData();
                console.log('üìä Found existing data from pulseApp:', existingData);
            }
            
            // If we have existing custom data, use it instead of loading sample data
            if (existingData && existingData.nodes && existingData.links) {
                console.log('‚úÖ Using existing custom data, skipping sample data load');
                // CRITICAL: Preserve existing colors before conversion
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData = convertSankeyDataToFlows(existingData);
                
                // CRITICAL: Restore colors after conversion
                flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                
                updateMetadataInputs();
                renderFlowTable();
                updateAllStats();
                
                // Handle tab switching based on URL parameter
                if (urlParams.tab === 'data-builder') {
                    currentMainTab = 'data-builder';
                    setTimeout(() => switchMainTab('data-builder'), 100);
                } else {
                    currentMainTab = 'chart-view';
                    console.log('üìä Staying on chart-view with existing data');
                }
                
                console.log('‚úÖ Flow Builder initialized with existing custom data');
                isInitialized = true;
                return;
            }
            
            // Check for URL parameters (only if no existing data)
            
            if (urlParams.type) {
                console.log(`üéØ Chart type specified in URL: ${urlParams.type}`);
                selectedChartType = urlParams.type;
                
                // Load the appropriate sample data
                const sampleData = await loadChartTypeData(urlParams.type);
                if (sampleData) {
                    // CRITICAL: Preserve existing colors before conversion
                    const existingColors = { ...flowData.metadata.colorPalette };
                    
                    flowData = convertSankeyDataToFlows(sampleData);
                    
                    // CRITICAL: Restore colors after conversion
                    flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                    
                    updateMetadataInputs();
                    renderFlowTable();
                    updateAllStats();
                    
                    // CRITICAL: Update the chart data bridge with the new data
                    const sankeyData = generateNodesAndLinksFromFlows();
                    console.log(`üìä Setting ${urlParams.type} data in bridge:`, sankeyData);
                    window.PulseDataBridge.setData(sankeyData, `chart-type-${urlParams.type}`);
                    
                    // Handle tab switching based on URL parameter
                    if (urlParams.tab === 'data-builder') {
                        // Only switch to data-builder if explicitly requested
                        currentMainTab = 'data-builder';
                        setTimeout(() => switchMainTab('data-builder'), 100);
                    } else {
                        // Explicitly stay on chart-view and prevent any tab switching
                        currentMainTab = 'chart-view';
                        console.log('üìä Staying on chart-view with loaded data');
                        
                        // Ensure chart-view tab stays active
                        document.querySelectorAll('.main-tab').forEach(tab => {
                            tab.classList.remove('active');
                        });
                        const chartViewTab = document.querySelector(`[onclick="switchMainTab('chart-view')"]`);
                        if (chartViewTab) {
                            chartViewTab.classList.add('active');
                        }
                        
                        document.querySelectorAll('.tab-content').forEach(content => {
                            content.classList.remove('active');
                        });
                        const chartViewContent = document.getElementById('chart-view');
                        if (chartViewContent) {
                            chartViewContent.classList.add('active');
                        }
                        
                        // Lock chart view to prevent automatic switching
                        lockChartView = true;
                        
                        console.log('üìä Chart view explicitly activated and locked');
                    }
                    
                    console.log(`‚úÖ Flow Builder initialized with ${urlParams.type} sample data`);
                    isInitialized = true;
                    return;
                }
            }
            
            // No URL parameters and no existing data - redirect to chart type selector or show empty state  
            console.log('‚ö†Ô∏è No data found and no chart type specified');
            if (!urlParams.type) {
                window.location.href = 'js/charts/sankey/sankey-type-selector.html';
            } else {
                console.log('üìä Flow Builder ready for manual input');
                isInitialized = true; // Mark as initialized even with no data
            }
        }

        function loadCurrentChartData() {
            const data = window.PulseDataBridge.getData();
            if (data) {
                // CRITICAL: Preserve existing colors
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData = convertSankeyDataToFlows(data);
                
                // CRITICAL: Restore colors
                flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                
                updateMetadataInputs();
                renderFlowTable();
                updateAllStats();
                
                alert('‚úÖ Successfully loaded current chart data for editing!');
            } else {
                alert('‚ùå No chart data available. Please load a dataset in Chart View first.');
            }
        }

        function loadCompleteTemplate() {
            // CRITICAL: Preserve existing colors
            const existingColors = { ...flowData.metadata.colorPalette };
            
            flowData.metadata.company = "TechFlow Corporation";
            flowData.metadata.title = "TechFlow Financial Flow";
            
            // CRITICAL: Restore colors
            flowData.metadata.colorPalette = existingColors;
            
            flowData.flows = [
                new BusinessFlow({
                    source: "Subscription Revenue",
                    target: "Total Revenue",
                    value: 300,
                    previousValue: 250,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Recurring subscription income"
                }),
                new BusinessFlow({
                    source: "Professional Services",
                    target: "Total Revenue",
                    value: 60,
                    previousValue: 55,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Implementation and consulting"
                }),
                new BusinessFlow({
                    source: "Platform & Other",
                    target: "Total Revenue",
                    value: 135,
                    previousValue: 120,
                    flowType: "revenue_flow",
                    sourceLayer: 0,
                    targetLayer: 1,
                    sourceCategory: "revenue",
                    targetCategory: "revenue",
                    description: "Platform fees and other revenue"
                }),
                new BusinessFlow({
                    source: "Total Revenue",
                    target: "Gross Profit",
                    value: 340,
                    previousValue: 290,
                    flowType: "profit_flow",
                    sourceLayer: 1,
                    targetLayer: 2,
                    sourceCategory: "revenue",
                    targetCategory: "profit",
                    description: "Revenue after cost of revenue"
                }),
                new BusinessFlow({
                    source: "Total Revenue",
                    target: "Cost of Revenue",
                    value: 55,
                    previousValue: 50,
                    flowType: "expense_flow",
                    sourceLayer: 1,
                    targetLayer: 2,
                    sourceCategory: "revenue",
                    targetCategory: "expense",
                    description: "Direct costs to deliver services"
                }),
                new BusinessFlow({
                    source: "Gross Profit",
                    target: "Operating Profit",
                    value: 65,
                    previousValue: 55,
                    flowType: "profit_flow",
                    sourceLayer: 2,
                    targetLayer: 3,
                    sourceCategory: "profit",
                    targetCategory: "profit",
                    description: "Profit from core operations"
                }),
                new BusinessFlow({
                    source: "Gross Profit",
                    target: "Operating Expenses",
                    value: 155,
                    previousValue: 140,
                    flowType: "expense_flow",
                    sourceLayer: 2,
                    targetLayer: 3,
                    sourceCategory: "profit",
                    targetCategory: "expense",
                    description: "Total operating expenses"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "Sales & Marketing",
                    value: 85,
                    previousValue: 75,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "Customer acquisition expenses"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "R&D",
                    value: 45,
                    previousValue: 40,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "Research and development"
                }),
                new BusinessFlow({
                    source: "Operating Expenses",
                    target: "G&A",
                    value: 20,
                    previousValue: 18,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "expense",
                    targetCategory: "expense",
                    description: "General and administrative"
                }),
                new BusinessFlow({
                    source: "Operating Profit",
                    target: "Net Income",
                    value: 50,
                    previousValue: 42,
                    flowType: "profit",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "profit",
                    targetCategory: "profit",
                    description: "Final net income"
                }),
                new BusinessFlow({
                    source: "Operating Profit",
                    target: "Tax Expense",
                    value: 12,
                    previousValue: 10,
                    flowType: "expense_flow",
                    sourceLayer: 3,
                    targetLayer: 4,
                    sourceCategory: "profit",
                    targetCategory: "expense",
                    description: "Income tax expense"
                })
            ];
            
            document.getElementById('company-name').value = flowData.metadata.company;
            renderFlowTable();
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        function loadBlankFlows() {
            if (confirm('This will clear all current flows. Continue?')) {
                // CRITICAL: Preserve existing colors
                const existingColors = { ...flowData.metadata.colorPalette };
                
                flowData.flows = [
                    new BusinessFlow({
                        source: "Revenue Source",
                        target: "Total Revenue",
                        value: 100,
                        previousValue: 0,
                        description: "Start building your flow here"
                    })
                ];
                
                // CRITICAL: Restore colors
                flowData.metadata.colorPalette = existingColors;
                
                renderFlowTable();
                updateAllStats();
                debouncedRealTimeUpdate();
            }
        }

        function resetToChartData() {
            const proceed = confirm('This will reset all your changes to match the current chart data. Continue?');
            if (proceed) {
                loadCurrentChartData();
            }
        }

        function updateMetadataInputs() {
            const fields = [
                { id: 'company-name', value: flowData.metadata.company },
                { id: 'period', value: flowData.metadata.period },
                { id: 'currency', value: flowData.metadata.currency },
                { id: 'units', value: flowData.metadata.unit },
                { id: 'period-type', value: flowData.metadata.periodType || 'Q/Q' }
            ];
            
            fields.forEach(({ id, value }) => {
                const element = document.getElementById(id);
                if (element && value) {
                    element.value = value;
                }
            });
        }

        function renderFlowTable() {
            const tbody = document.getElementById('flows-tbody');
            tbody.innerHTML = '';
            
            if (flowData.flows.length === 0) {
                const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
                const colSpan = comparisonMode ? 9 : 7; // Updated for new column count
                tbody.innerHTML = `
                    <tr>
                        <td colspan="${colSpan}" style="text-align: center; padding: 40px; color: #6b7280;">
                            <div style="font-size: 16px; margin-bottom: 8px;">üí°</div>
                            <div>No flows defined. Click "Add Flow" to start building your financial structure.</div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Auto-calculate layers and flow types before rendering
            autoCalculateFlowProperties();
            
            flowData.flows.forEach((flow, index) => {
                const row = createFlowRow(flow, index);
                tbody.appendChild(row);
            });
        }

        function createFlowRow(flow, index) {
            const tr = document.createElement('tr');
            tr.setAttribute('data-row', index);
            
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            
            let rowHTML = `
                <td class="control-cell">
                    <div class="flow-controls">
                        <button class="flow-control-btn up" onclick="moveFlowUp(${index})" title="Move Up" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                        <button class="flow-control-btn down" onclick="moveFlowDown(${index})" title="Move Down" ${index === flowData.flows.length - 1 ? 'disabled' : ''}>‚Üì</button>
                        <button class="flow-control-btn duplicate" onclick="duplicateFlow(${index})" title="Duplicate">‚ßâ</button>
                        <button class="flow-control-btn remove" onclick="removeFlow(${index})" title="Remove">√ó</button>
                    </div>
                </td>
                <td class="spreadsheet-cell" data-col="source" data-row="${index}" data-type="text">
                    <div class="cell-content">${flow.source}</div>
                    <input type="text" class="cell-editor" style="display: none;">
                </td>
                <td class="spreadsheet-cell" data-col="target" data-row="${index}" data-type="text">
                    <div class="cell-content">${flow.target}</div>
                    <input type="text" class="cell-editor" style="display: none;">
                </td>
                <td class="spreadsheet-cell" data-col="value" data-row="${index}" data-type="number">
                    <div class="cell-content">${flow.value}</div>
                    <input type="number" class="cell-editor" style="display: none;">
                </td>`;
            
            // Add previous value and variance columns if comparison mode is enabled
            if (comparisonMode) {
                rowHTML += `
                <td class="spreadsheet-cell" data-col="previousValue" data-row="${index}" data-type="number">
                    <div class="cell-content">${flow.previousValue || 0}</div>
                    <input type="number" class="cell-editor" style="display: none;">
                </td>
                <td class="variance-cell">
                    <div style="font-size: 11px; font-weight: 600; text-align: center;">${flow.getVarianceDisplay()}</div>
                </td>`;
            }
            
            rowHTML += `
                <td class="spreadsheet-cell" data-col="sourceCategory" data-row="${index}" data-type="select">
                    <div class="cell-content">${getCategoryDisplay(flow.sourceCategory)}</div>
                    <select class="cell-editor" style="display: none;">
                        <option value="revenue">Revenue</option>
                        <option value="cost">Cost</option>
                        <option value="expense">Expense</option>
                        <option value="profit">Profit</option>
                        <option value="income">Income</option>
                        <option value="tax">Tax</option>
                        <option value="asset">Asset</option>
                        <option value="liability">Liability</option>
                        <option value="equity">Equity</option>
                    </select>
                </td>
                <td class="spreadsheet-cell" data-col="targetCategory" data-row="${index}" data-type="select">
                    <div class="cell-content">${getCategoryDisplay(flow.targetCategory)}</div>
                    <select class="cell-editor" style="display: none;">
                        <option value="revenue">Revenue</option>
                        <option value="cost">Cost</option>
                        <option value="expense">Expense</option>
                        <option value="profit">Profit</option>
                        <option value="income">Income</option>
                        <option value="tax">Tax</option>
                        <option value="asset">Asset</option>
                        <option value="liability">Liability</option>
                        <option value="equity">Equity</option>
                    </select>
                </td>
                <td class="spreadsheet-cell" data-col="description" data-row="${index}" data-type="text">
                    <div class="cell-content">${flow.description}</div>
                    <input type="text" class="cell-editor" style="display: none;" placeholder="Flow description">
                </td>
            `;
            
            tr.innerHTML = rowHTML;
            return tr;
        }

        // Helper functions for display formatting
        function getFlowTypeDisplay(flowType) {
            const types = {
                'revenue_flow': 'Revenue Flow',
                'expense_flow': 'Expense Flow', 
                'profit_flow': 'Profit Flow'
            };
            return types[flowType] || flowType;
        }

        function getCategoryDisplay(category) {
            return category.charAt(0).toUpperCase() + category.slice(1);
        }

        // Auto-calculate layers and flow types when flows are updated
        function autoCalculateFlowProperties() {
            if (!flowData.flows || flowData.flows.length === 0) return;

            // Build a node hierarchy map
            const nodeInputs = new Map(); // node -> list of sources
            const nodeOutputs = new Map(); // node -> list of targets
            
            flowData.flows.forEach(flow => {
                if (!nodeInputs.has(flow.target)) nodeInputs.set(flow.target, []);
                if (!nodeOutputs.has(flow.source)) nodeOutputs.set(flow.source, []);
                
                nodeInputs.get(flow.target).push(flow.source);
                nodeOutputs.get(flow.source).push(flow.target);
            });

            // Calculate layers using topological ordering
            const layers = new Map();
            const processed = new Set();
            
            // Start with nodes that have no inputs (sources)
            const queue = [];
            for (let flow of flowData.flows) {
                if (!nodeInputs.has(flow.source) || nodeInputs.get(flow.source).length === 0) {
                    if (!layers.has(flow.source)) {
                        layers.set(flow.source, 0);
                        queue.push(flow.source);
                    }
                }
            }
            
            // Process nodes level by level
            while (queue.length > 0) {
                const currentNode = queue.shift();
                if (processed.has(currentNode)) continue;
                processed.add(currentNode);
                
                const currentLayer = layers.get(currentNode) || 0;
                
                // Update targets to be at least one layer deeper
                if (nodeOutputs.has(currentNode)) {
                    for (let target of nodeOutputs.get(currentNode)) {
                        const targetLayer = Math.max(layers.get(target) || 0, currentLayer + 1);
                        layers.set(target, targetLayer);
                        queue.push(target);
                    }
                }
            }

            // Apply calculated layers and auto-determine flow types
            flowData.flows.forEach(flow => {
                flow.sourceLayer = layers.get(flow.source) || 0;
                flow.targetLayer = layers.get(flow.target) || flow.sourceLayer + 1;
                
                // Auto-determine flow type based on categories
                if (flow.sourceCategory === 'revenue' && flow.targetCategory === 'revenue') {
                    flow.flowType = 'revenue_flow';
                } else if (flow.targetCategory === 'expense' || flow.targetCategory === 'cost' || flow.targetCategory === 'tax') {
                    flow.flowType = 'expense_flow';
                } else if (flow.sourceCategory === 'profit' || flow.targetCategory === 'profit' || flow.targetCategory === 'income') {
                    flow.flowType = 'profit_flow';
                } else if (flow.sourceCategory === 'cost' || flow.sourceCategory === 'expense') {
                    flow.flowType = 'expense_flow';
                } else if (flow.sourceCategory === 'asset' || flow.targetCategory === 'asset') {
                    flow.flowType = 'asset_flow';
                } else if (flow.sourceCategory === 'liability' || flow.targetCategory === 'liability') {
                    flow.flowType = 'liability_flow';
                } else if (flow.sourceCategory === 'equity' || flow.targetCategory === 'equity') {
                    flow.flowType = 'equity_flow';
                } else {
                    flow.flowType = 'revenue_flow'; // default
                }
            });
        }

        function getFlowBalanceIndicator(flow) {
            const isValid = flow.source && flow.target && flow.value > 0 && flow.sourceLayer < flow.targetLayer;
            return `<div class="balance-indicator ${isValid ? 'balanced' : 'unbalanced'}">${isValid ? '‚úì' : '‚ö†'}</div>`;
        }

        function addFlow() {
            const newFlow = new BusinessFlow({
                source: "New Source",
                target: "New Target", 
                value: 100,
                previousValue: 0,
                sourceCategory: "revenue",
                targetCategory: "revenue"
            });
            
            flowData.flows.push(newFlow);
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        function removeFlow(index) {
            flowData.flows.splice(index, 1);
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        function moveFlowUp(index) {
            if (index > 0) {
                [flowData.flows[index], flowData.flows[index - 1]] = [flowData.flows[index - 1], flowData.flows[index]];
                renderFlowTable(); // This will call autoCalculateFlowProperties()
                updateAllStats();
                debouncedRealTimeUpdate();
            }
        }

        function moveFlowDown(index) {
            if (index < flowData.flows.length - 1) {
                [flowData.flows[index], flowData.flows[index + 1]] = [flowData.flows[index + 1], flowData.flows[index]];
                renderFlowTable(); // This will call autoCalculateFlowProperties()
                updateAllStats();
                debouncedRealTimeUpdate();
            }
        }

        function duplicateFlow(index) {
            const originalFlow = flowData.flows[index];
            const duplicatedFlow = new BusinessFlow({
                source: originalFlow.source + " Copy",
                target: originalFlow.target,
                value: originalFlow.value,
                previousValue: originalFlow.previousValue,
                sourceCategory: originalFlow.sourceCategory,
                targetCategory: originalFlow.targetCategory,
                description: originalFlow.description + " (Copy)"
            });
            
            flowData.flows.splice(index + 1, 0, duplicatedFlow);
            renderFlowTable(); // This will call autoCalculateFlowProperties()
            updateAllStats();
            debouncedRealTimeUpdate();
        }

        function updateMetadata() {
            flowData.metadata.company = document.getElementById('company-name').value;
            flowData.metadata.period = document.getElementById('period').value;
            flowData.metadata.currency = document.getElementById('currency').value;
            flowData.metadata.unit = document.getElementById('units').value;
            flowData.metadata.periodType = document.getElementById('period-type').value;
            flowData.metadata.title = `${flowData.metadata.company} Financial Flow`;
            
            debouncedRealTimeUpdate();
        }

        function updateAllStats() {
            const nodeMap = new Map();
            
            flowData.flows.forEach(flow => {
                nodeMap.set(flow.source, flow.sourceLayer);
                nodeMap.set(flow.target, flow.targetLayer);
            });
            
            const flowCount = flowData.flows.length;
            const nodeCount = nodeMap.size;
            const layerCount = new Set(Array.from(nodeMap.values())).size;
            
            let balancedFlows = 0;
            flowData.flows.forEach(flow => {
                const isValid = flow.source && flow.target && flow.value > 0 && flow.sourceLayer < flow.targetLayer;
                if (isValid) balancedFlows++;
            });
            
            const balanceScore = flowCount > 0 ? Math.round((balancedFlows / flowCount) * 100) : 0;
            
            document.getElementById('flow-count').textContent = flowCount;
            document.getElementById('node-count').textContent = nodeCount;
            document.getElementById('layer-count').textContent = layerCount;
            document.getElementById('balance-score').textContent = balanceScore + '%';
        }

        function applyFlowChanges() {
            console.log('üöÄ Applying Flow Builder changes...');
            
            flowData.metadata.company = document.getElementById('company-name').value;
            flowData.metadata.period = document.getElementById('period').value;
            flowData.metadata.currency = document.getElementById('currency').value;
            flowData.metadata.unit = document.getElementById('units').value;
            flowData.metadata.title = `${flowData.metadata.company} Financial Flow`;
            
            const sankeyData = generateNodesAndLinksFromFlows();
            window.PulseDataBridge.applyFlowBuilderChanges(sankeyData);
            
            switchMainTab('chart-view');
            
            console.log('‚úÖ Changes applied and switched to Chart View');
        }

        function validateFlows() {
            const errors = [];
            const warnings = [];
            
            if (flowData.flows.length === 0) {
                errors.push('No flows defined');
            }
            
            flowData.flows.forEach((flow, index) => {
                if (!flow.source || !flow.target) {
                    errors.push(`Flow ${index + 1}: Missing source or target`);
                }
                
                if (flow.value <= 0) {
                    errors.push(`Flow ${index + 1}: Invalid value (${flow.value})`);
                }
                
                if (flow.sourceLayer >= flow.targetLayer) {
                    errors.push(`Flow ${index + 1}: Source layer must be less than target layer`);
                }
                
                if (flow.source === flow.target) {
                    errors.push(`Flow ${index + 1}: Source and target cannot be the same`);
                }
            });
            
            let message = '‚úÖ Flow Validation Results\n\n';
            
            if (errors.length > 0) {
                message += '‚ùå Errors:\n' + errors.map(e => `‚Ä¢ ${e}`).join('\n') + '\n\n';
            }
            
            if (warnings.length > 0) {
                message += '‚ö†Ô∏è Warnings:\n' + warnings.map(w => `‚Ä¢ ${w}`).join('\n') + '\n\n';
            }
            
            if (errors.length === 0 && warnings.length === 0) {
                message += 'Perfect! All flows are valid.\n\n';
            }
            
            const balanceScore = document.getElementById('balance-score').textContent;
            message += `üìä Summary:\n‚Ä¢ ${flowData.flows.length} flows\n‚Ä¢ Balance Score: ${balanceScore}`;
            
            alert(message);
        }

        function exportFlowsToCSV() {
            let csv = 'Source,Target,Current Value,Previous Value,Source Category,Target Category,Description\n';
            
            flowData.flows.forEach(flow => {
                csv += `"${flow.source}","${flow.target}",${flow.value},${flow.previousValue || 0},"${flow.sourceCategory}","${flow.targetCategory}","${flow.description}"\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${flowData.metadata.company.replace(/[^a-zA-Z0-9]/g, '').toLowerCase()}-flows.csv`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importFlowsFromCSV() {
            document.getElementById('csv-file-input').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                
                if (file.name.endsWith('.json')) {
                    try {
                        const data = JSON.parse(content);
                        
                        // CRITICAL: Preserve existing colors before import
                        const existingColors = { ...flowData.metadata.colorPalette };
                        
                        if (data.flows) {
                            flowData = data;
                        } else if (data.nodes && data.links) {
                            flowData = convertSankeyDataToFlows(data);
                        }
                        
                        // CRITICAL: Restore colors after import
                        flowData.metadata.colorPalette = { ...existingColors, ...flowData.metadata.colorPalette };
                        
                        renderFlowTable(); // This calls autoCalculateFlowProperties()
                        updateAllStats();
                        
                        // Force chart update with the imported data
                        debouncedRealTimeUpdate();
                        
                        alert('‚úÖ Successfully imported flows!');
                    } catch (error) {
                        alert('‚ùå Error parsing JSON: ' + error.message);
                    }
                } else if (file.name.endsWith('.csv')) {
                    parseCSVFlows(content);
                }
            };
            reader.readAsText(file);
        }

        function parseCSVFlows(csvContent) {
            const lines = csvContent.split('\n').filter(line => line.trim() && !line.startsWith('#'));
            if (lines.length < 2) {
                alert('‚ùå CSV file must have header and at least one data row');
                return;
            }
            
            // Parse header to detect column positions
            const headers = parseCSVLine(lines[0]).map(h => h.toLowerCase().trim());
            const columnMap = {
                source: Math.max(headers.indexOf('source'), headers.indexOf('from')),
                target: Math.max(headers.indexOf('target'), headers.indexOf('to')),
                amount: Math.max(headers.indexOf('amount'), headers.indexOf('current value'), headers.indexOf('value')),
                previousAmount: Math.max(headers.indexOf('previous amount'), headers.indexOf('previous value')),
                sourceCategory: Math.max(headers.indexOf('source category'), headers.indexOf('source cat')),
                targetCategory: Math.max(headers.indexOf('target category'), headers.indexOf('target cat')),
                description: headers.indexOf('description')
            };
            
            // CRITICAL: Preserve existing colors before import
            const existingColors = { ...flowData.metadata.colorPalette };
            
            const flows = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                
                // Get source and target values with fallback logic
                const sourceValue = columnMap.source >= 0 ? values[columnMap.source] : `Flow ${i} Source`;
                const targetValue = columnMap.target >= 0 ? values[columnMap.target] : `Flow ${i} Target`;
                const amountValue = columnMap.amount >= 0 ? parseFloat(values[columnMap.amount]) : 100;
                
                // Minimum requirement: at least one meaningful value
                if (values.length >= 1 && (sourceValue || targetValue || amountValue)) {
                    const previousValue = columnMap.previousAmount >= 0 && values[columnMap.previousAmount] 
                        ? parseFloat(values[columnMap.previousAmount]) || 0 
                        : 0;
                    
                    flows.push(new BusinessFlow({
                        source: sourceValue || `Flow ${i} Source`,
                        target: targetValue || `Flow ${i} Target`,
                        value: amountValue || 100,
                        previousValue: previousValue,
                        sourceCategory: (columnMap.sourceCategory >= 0 ? values[columnMap.sourceCategory] : null) || 'revenue',
                        targetCategory: (columnMap.targetCategory >= 0 ? values[columnMap.targetCategory] : null) || 'revenue',
                        description: (columnMap.description >= 0 ? values[columnMap.description] : null) || `Flow from ${sourceValue || 'Source'} to ${targetValue || 'Target'}`
                        // Note: flowType, sourceLayer, targetLayer will be auto-calculated
                    }));
                }
            }
            
            if (flows.length > 0) {
                flowData.flows = flows;
                
                // CRITICAL: Restore colors after import
                flowData.metadata.colorPalette = existingColors;
                
                // Enable comparison mode if any previous values exist
                const hasPreviousValues = flows.some(flow => flow.previousValue > 0);
                if (hasPreviousValues) {
                    document.getElementById('comparison-mode-toggle').checked = true;
                    toggleComparisonMode();
                }
                
                renderFlowTable(); // This calls autoCalculateFlowProperties()
                updateAllStats();
                
                // Force chart update with the imported data
                debouncedRealTimeUpdate();
                
                console.log('‚úÖ Flow Builder refreshed successfully');
                
                // Provide helpful feedback about what was imported
                let message = `‚úÖ Successfully imported ${flows.length} flows from CSV!\n\n`;
                
                if (columnMap.source < 0 || columnMap.target < 0) {
                    message += '‚ö†Ô∏è Note: Some source/target columns were missing and have been auto-generated. ';
                    message += 'You can edit these in the table below.\n\n';
                }
                
                if (columnMap.sourceCategory < 0 || columnMap.targetCategory < 0) {
                    message += '‚ÑπÔ∏è Categories have been set to default values. You can adjust them using the dropdown menus.\n\n';
                }
                
                message += 'The chart will update automatically as you edit the data.';
                
                alert(message);
            } else {
                alert('‚ùå No valid flows found in CSV file');
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result.map(field => field.replace(/^"|"$/g, ''));
        }

        // FIXED: Generate nodes and links with proper color preservation and percentage metrics
        function generateNodesAndLinksFromFlows() {
            const comparisonMode = document.getElementById('comparison-mode-toggle').checked;
            const result = PulseSankeyChart.generateNodesAndLinksFromFlows(flowData, comparisonMode);
            
            // Preserve the comparison mode in metadata
            result.metadata.comparisonMode = comparisonMode;
            
            // Determine chart type based on categories
            const isBalanceSheet = flowData.flows.some(flow => 
                flow.sourceCategory === 'asset' || flow.targetCategory === 'asset' ||
                flow.sourceCategory === 'liability' || flow.targetCategory === 'liability' ||
                flow.sourceCategory === 'equity' || flow.targetCategory === 'equity'
            );
            
            result.metadata.statementType = isBalanceSheet ? 'balance' : 'income';
            
            // Calculate percentage metrics
            if (isBalanceSheet) {
                // For Balance Sheet: Add growth/decline percentages
                result.nodes.forEach(node => {
                    const matchingFlow = flowData.flows.find(flow => 
                        flow.source === node.id || flow.target === node.id
                    );
                    if (matchingFlow) {
                        node.growthDecline = matchingFlow.getGrowthDeclineDisplay();
                        node.hasPercentages = true;
                    }
                });
            } else {
                // For Income Statement: Add both growth/decline and margin percentages
                const revenueBase = findRevenueBase(flowData);
                
                result.nodes.forEach(node => {
                    const matchingFlow = flowData.flows.find(flow => 
                        flow.source === node.id || flow.target === node.id
                    );
                    if (matchingFlow) {
                        node.growthDecline = matchingFlow.getGrowthDeclineDisplay();
                        // Calculate percentage of revenue for this node's value
                        node.marginPercentage = getRevenuePercentage(node.value, revenueBase);
                        node.hasPercentages = true;
                    }
                });
                
                result.metadata.revenueBase = revenueBase;
            }
            
            console.log(`üìä Generated ${result.metadata.statementType} chart data with percentage metrics`);
            return result;
        }

        // Setup file import handler
        document.addEventListener('DOMContentLoaded', function() {
            const csvFileInput = document.getElementById('csv-file-input');
            if (csvFileInput) {
                csvFileInput.addEventListener('change', handleFileImport);
            }
            
            // Initialize comparison columns as hidden
            const previousCol = document.getElementById('previous-value-col');
            const varianceCol = document.getElementById('variance-col');
            if (previousCol) previousCol.style.display = 'none';
            if (varianceCol) varianceCol.style.display = 'none';

            // Initialize spreadsheet functionality
            window.spreadsheetController = new SpreadsheetController();
            
            // Initialize modern export dropdown
            initializeExportDropdown();
            
            // CRITICAL: Initialize flow builder on page load to handle URL parameters
            setTimeout(() => {
                initializeFlowBuilder();
            }, 200);
        });

        // Modern Export Dropdown Functionality
        function initializeExportDropdown() {
            const exportTrigger = document.getElementById('export-trigger');
            const exportMenu = document.getElementById('export-menu');
            
            if (!exportTrigger || !exportMenu) return;
            
            // Toggle dropdown
            exportTrigger.addEventListener('click', (e) => {
                e.stopPropagation();
                exportMenu.classList.toggle('active');
                exportTrigger.classList.toggle('active');
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!exportTrigger.contains(e.target) && !exportMenu.contains(e.target)) {
                    exportMenu.classList.remove('active');
                    exportTrigger.classList.remove('active');
                }
            });
            
            // Handle export option clicks with visual feedback
            const exportOptions = exportMenu.querySelectorAll('.export-option');
            exportOptions.forEach(option => {
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Add loading state
                    option.classList.add('loading');
                    
                    // Close dropdown
                    exportMenu.classList.remove('active');
                    exportTrigger.classList.remove('active');
                    
                    // Remove loading state after brief delay
                    setTimeout(() => {
                        option.classList.remove('loading');
                    }, 1000);
                });
            });
        }

        // ===== TEMPLATE DOWNLOAD FUNCTIONALITY =====

        function downloadTemplate() {
            if (!selectedChartType) {
                alert('Please select a chart type first by clicking on Income Statement or Balance Sheet.');
                return;
            }
            
            let csv = '';
            let filename = '';
            
            if (selectedChartType === 'income') {
                csv = 'Source,Target,Current Value,Previous Value,Source Category,Target Category,Description\n';
                csv += '"Subscription Revenue","Total Revenue",300,250,"revenue","revenue","Recurring subscription income"\n';
                csv += '"Professional Services","Total Revenue",60,55,"revenue","revenue","Implementation and consulting"\n';
                csv += '"Total Revenue","Gross Profit",290,245,"revenue","profit","Revenue after cost of revenue"\n';
                csv += '"Total Revenue","Cost of Revenue",70,60,"revenue","cost","Direct costs to deliver services"\n';
                csv += '"Gross Profit","Operating Profit",120,100,"profit","profit","Profit from core operations"\n';
                csv += '"Gross Profit","Operating Expenses",170,145,"profit","expense","Total operating expenses"\n';
                csv += '"Operating Profit","Net Income",95,80,"profit","income","Final net income"\n';
                csv += '"Operating Profit","Tax Expense",25,20,"profit","tax","Income tax expense"\n';
                filename = 'income-statement-template.csv';
            } else if (selectedChartType === 'balance') {
                csv = 'Source,Target,Current Value,Previous Value,Source Category,Target Category,Description\n';
                csv += '"Current Assets","Total Assets",500,450,"revenue","revenue","Cash, receivables, inventory"\n';
                csv += '"Non-Current Assets","Total Assets",800,750,"revenue","revenue","Property, equipment, intangibles"\n';
                csv += '"Total Assets","Current Liabilities",300,280,"revenue","expense","Short-term obligations"\n';
                csv += '"Total Assets","Non-Current Liabilities",400,370,"revenue","expense","Long-term debt and obligations"\n';
                csv += '"Total Assets","Shareholders Equity",600,550,"revenue","profit","Owner\'s equity in the business"\n';
                filename = 'balance-sheet-template.csv';
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function resetChart() {
            if (confirm('This will reset the chart and return to chart type selection. Continue?')) {
                // Redirect to sankey chart type selector
                window.location.href = 'js/charts/sankey/sankey-type-selector.html';
            }
        }

        // ===== GOOGLE SHEETS-STYLE SPREADSHEET FUNCTIONALITY =====
        class SpreadsheetController {
            constructor() {
                this.selectedCell = null;
                this.editingCell = null;
                this.initializeSpreadsheet();
            }

            initializeSpreadsheet() {
                // Add event listeners for spreadsheet functionality
                document.addEventListener('click', this.handleCellClick.bind(this));
                document.addEventListener('keydown', this.handleKeyNavigation.bind(this));
                document.addEventListener('dblclick', this.handleCellDoubleClick.bind(this));
            }

            handleCellClick(event) {
                const cell = event.target.closest('.spreadsheet-cell');
                if (!cell) {
                    this.clearSelection();
                    return;
                }

                // Check if this is a SELECT type cell for immediate editing
                const isSelectCell = cell.dataset.type === 'select';
                
                this.selectCell(cell);
                
                // For SELECT elements, start editing immediately on single click
                if (isSelectCell) {
                    // Prevent the double-click requirement for dropdowns
                    setTimeout(() => {
                        this.startEditing(cell);
                    }, 10);
                }
            }

            handleCellDoubleClick(event) {
                const cell = event.target.closest('.spreadsheet-cell');
                if (cell) {
                    this.startEditing(cell);
                }
            }

            selectCell(cell) {
                // Clear previous selection
                this.clearSelection();
                
                // Set new selection
                this.selectedCell = cell;
                cell.classList.add('selected');
                cell.setAttribute('tabindex', '0');
                cell.focus();
            }

            clearSelection() {
                if (this.selectedCell) {
                    this.selectedCell.classList.remove('selected');
                    this.selectedCell.removeAttribute('tabindex');
                }
                this.selectedCell = null;
            }

            startEditing(cell) {
                if (this.editingCell) {
                    this.stopEditing();
                }

                this.editingCell = cell;
                cell.classList.add('editing');
                
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Get current flow data for this cell
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const currentFlow = flowData.flows[row];
                
                // Set editor value from flow data (not display text)
                if (editor.tagName === 'SELECT') {
                    editor.value = currentFlow[col];
                } else {
                    editor.value = currentFlow[col];
                }
                
                // Show editor and hide content
                content.style.display = 'none';
                editor.style.display = 'block';
                editor.focus();
                
                // Select all text for quick editing
                if (editor.type !== 'number' && editor.tagName !== 'SELECT') {
                    editor.select();
                }

                // Add event listeners with enhanced cross-browser SELECT element handling
                if (editor.tagName === 'SELECT') {
                    // Cross-browser dropdown fix: Force dropdown to open and stay open
                    const openDropdown = () => {
                        // Force focus first
                        editor.focus();
                        
                        // For WebKit browsers (Safari, Chrome), trigger the dropdown
                        if (editor.showPicker && typeof editor.showPicker === 'function') {
                            try {
                                editor.showPicker();
                            } catch (e) {
                                // Fallback for older browsers
                                editor.click();
                            }
                        } else {
                            // Fallback: simulate click to open dropdown
                            const clickEvent = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                view: window
                            });
                            editor.dispatchEvent(clickEvent);
                        }
                    };
                    
                    // Delay opening to ensure proper rendering
                    setTimeout(openDropdown, 20);
                    
                    // Prevent event bubbling that could close the dropdown
                    editor.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                    });
                    
                    editor.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    
                    // Handle selection change
                    editor.addEventListener('change', () => {
                        this.stopEditing();
                    }, { once: true });
                    
                    editor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                    
                    // Enhanced blur handling for SELECT stability
                    let blurTimeout;
                    let isInteracting = false;
                    
                    editor.addEventListener('mousedown', () => {
                        isInteracting = true;
                        if (blurTimeout) {
                            clearTimeout(blurTimeout);
                            blurTimeout = null;
                        }
                    });
                    
                    editor.addEventListener('mouseup', () => {
                        setTimeout(() => {
                            isInteracting = false;
                        }, 50);
                    });
                    
                    editor.addEventListener('blur', (e) => {
                        if (blurTimeout) clearTimeout(blurTimeout);
                        
                        blurTimeout = setTimeout(() => {
                            if (!isInteracting && document.activeElement !== editor) {
                                this.stopEditing();
                            }
                        }, 300); // Increased delay for better stability
                    }, { once: true });
                    
                    // Restore focus if dropdown was accidentally closed
                    editor.addEventListener('focus', () => {
                        if (blurTimeout) {
                            clearTimeout(blurTimeout);
                            blurTimeout = null;
                        }
                    });
                } else {
                    editor.addEventListener('blur', () => this.stopEditing(), { once: true });
                    editor.addEventListener('keydown', this.handleEditorKeys.bind(this));
                }
            }

            stopEditing() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Get cell data attributes
                const row = parseInt(cell.dataset.row);
                const col = cell.dataset.col;
                const type = cell.dataset.type;
                
                let newValue = editor.value;
                
                // Update content with editor value and format based on type
                if (editor.tagName === 'SELECT') {
                    const selectedOption = editor.options[editor.selectedIndex];
                    content.textContent = selectedOption.text;
                    newValue = selectedOption.value;
                } else {
                    content.textContent = editor.value || '';
                    if (type === 'number') {
                        newValue = parseFloat(editor.value) || 0;
                    }
                }
                
                // Update the flow data
                if (flowData.flows[row] && col) {
                    flowData.flows[row][col] = newValue;
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    updateAllStats();
                    debouncedRealTimeUpdate();
                    
                    // Update variance display if this was a value change
                    if (col === 'value' || col === 'previousValue') {
                        const varianceCell = cell.closest('tr').querySelector('.variance-cell div');
                        if (varianceCell) {
                            varianceCell.textContent = flowData.flows[row].getVarianceDisplay();
                        }
                    }
                }
                
                // Hide editor and show content
                editor.style.display = 'none';
                content.style.display = 'flex';
                
                cell.classList.remove('editing');
                this.editingCell = null;
                
                // Return focus to cell
                cell.focus();
            }

            handleEditorKeys(event) {
                switch (event.key) {
                    case 'Enter':
                        event.preventDefault();
                        this.stopEditing();
                        this.moveSelection('down');
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.cancelEditing();
                        break;
                    case 'Tab':
                        event.preventDefault();
                        this.stopEditing();
                        this.moveSelection(event.shiftKey ? 'left' : 'right');
                        break;
                }
            }

            cancelEditing() {
                if (!this.editingCell) return;

                const cell = this.editingCell;
                const content = cell.querySelector('.cell-content');
                const editor = cell.querySelector('.cell-editor');
                
                // Don't update content, just hide editor
                editor.style.display = 'none';
                content.style.display = 'flex';
                
                cell.classList.remove('editing');
                this.editingCell = null;
                cell.focus();
            }

            handleKeyNavigation(event) {
                if (!this.selectedCell || this.editingCell) {
                    return;
                }

                switch (event.key) {
                    case 'ArrowUp':
                        event.preventDefault();
                        this.moveSelection('up');
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        this.moveSelection('down');
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        this.moveSelection('left');
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        this.moveSelection('right');
                        break;
                    case 'Enter':
                        event.preventDefault();
                        this.startEditing(this.selectedCell);
                        break;
                    case 'F2':
                        event.preventDefault();
                        this.startEditing(this.selectedCell);
                        break;
                    case 'Delete':
                    case 'Backspace':
                        event.preventDefault();
                        this.clearCellContent();
                        break;
                    case 'Tab':
                        event.preventDefault();
                        this.moveSelection(event.shiftKey ? 'left' : 'right');
                        break;
                    default:
                        // Start editing on alphanumeric key press
                        if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
                            this.startEditing(this.selectedCell);
                        }
                        break;
                }
            }

            moveSelection(direction) {
                if (!this.selectedCell) return;

                const currentRow = this.selectedCell.closest('tr');
                const currentCellIndex = Array.from(currentRow.children).indexOf(this.selectedCell);
                let targetCell = null;

                switch (direction) {
                    case 'up':
                        const prevRow = currentRow.previousElementSibling;
                        if (prevRow) {
                            targetCell = prevRow.children[currentCellIndex];
                        }
                        break;
                    case 'down':
                        const nextRow = currentRow.nextElementSibling;
                        if (nextRow) {
                            targetCell = nextRow.children[currentCellIndex];
                        }
                        break;
                    case 'left':
                        const prevCell = this.selectedCell.previousElementSibling;
                        if (prevCell && prevCell.classList.contains('spreadsheet-cell')) {
                            targetCell = prevCell;
                        }
                        break;
                    case 'right':
                        const nextCell = this.selectedCell.nextElementSibling;
                        if (nextCell && nextCell.classList.contains('spreadsheet-cell')) {
                            targetCell = nextCell;
                        }
                        break;
                }

                if (targetCell && targetCell.classList.contains('spreadsheet-cell')) {
                    this.selectCell(targetCell);
                }
            }

            clearCellContent() {
                if (!this.selectedCell) return;
                
                const content = this.selectedCell.querySelector('.cell-content');
                const row = parseInt(this.selectedCell.dataset.row);
                const col = this.selectedCell.dataset.col;
                const type = this.selectedCell.dataset.type;
                
                // Clear display
                content.textContent = '';
                
                // Clear data based on type
                if (flowData.flows[row] && col) {
                    if (type === 'number') {
                        flowData.flows[row][col] = 0;
                        content.textContent = '0';
                    } else {
                        flowData.flows[row][col] = '';
                    }
                    
                    // Auto-recalculate layers and flow types
                    autoCalculateFlowProperties();
                    updateAllStats();
                    debouncedRealTimeUpdate();
                }
            }
        }
    </script>
</body>
</html>